
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>入耳箸心</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="吾生也有涯而知也无涯，以有涯随无涯，殆已。">
<meta property="og:type" content="website">
<meta property="og:title" content="入耳箸心">
<meta property="og:url" content="http://suqun.github.io/index.html">
<meta property="og:site_name" content="入耳箸心">
<meta property="og:description" content="吾生也有涯而知也无涯，以有涯随无涯，殆已。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="入耳箸心">
<meta name="twitter:description" content="吾生也有涯而知也无涯，以有涯随无涯，殆已。">
  
    <link rel="alternative" href="/atom.xml" title="入耳箸心" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">入耳箸心</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">成长路上的点滴记录</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">所有文章</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="suqun.github.io">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-algorithm-8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/01/algorithm-8/" class="article-date">
  <time datetime="2017-05-01T07:50:10.000Z" itemprop="datePublished">2017-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/01/algorithm-8/">算法之排序-归并排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2017/05/01/algorithm-8/" data-id="cj26adtxp001d2suqtxey43d7" class="article-share-link" data-share="baidu" data-title="算法之排序-归并排序">分享到</a>
      

      
        <a href="http://suqun.github.io/2017/05/01/algorithm-8/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-algorithm-7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/30/algorithm-7/" class="article-date">
  <time datetime="2017-04-30T07:10:57.000Z" itemprop="datePublished">2017-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/30/algorithm-7/">算法之排序-希尔排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <h2 id="u7B97_u6CD5_u63CF_u8FF0"><a href="#u7B97_u6CD5_u63CF_u8FF0" class="headerlink" title="算法描述"></a>算法描述</h2><p>希尔排序为了加快速度简单的改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。</p>
<p>希尔排序的思想是使数组中任意间隔为h的元素都是有序的。这样的数组成为<code>h有序数组</code>。在进行排序时，如果h很大，就能将元素移动到很远的地方，为实现更小的h有序创造方便。</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/algorithm-h-sort.png" alt=""></p>
<h2 id="u7279_u70B9"><a href="#u7279_u70B9" class="headerlink" title="特点"></a>特点</h2><p>希尔排序更高效的原因是它权衡了子数组的规模和有序性。排序之初各个子数组都很短，排序之后的子数组都是部分有序的，这两种情况都很适合插入排序。子数组的部分有序取决于递增序列的选择。</p>
<p>对于中等大小的数组它的运行时间是可以接受的。他的代码量小，不需要额外的内存空间。后面我们会看到更加高效的算法，但是对于很大的N，它们可能只比希尔排序快2倍（可能还达不到），而且更复杂。可以考虑先用希尔排序，然后在考虑是否值得将它替换为更加复杂的排序算法。</p>
<h2 id="u4EE3_u7801"><a href="#u4EE3_u7801" class="headerlink" title="代码"></a>代码</h2><p>使用序列1/2(3的k次方 - 1)，从N/3开始递减至1。这个序列成为递增序列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将a按升序排列</span></span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; N / <span class="number">3</span>) h = h * <span class="number">3</span> + <span class="number">1</span>;<span class="comment">//1,3,13,40,121,364,1093...</span></span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="comment">//将a[i]插入到a[i-1],a[i-2],a[i-3]...之中</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (less(a[j], a[j - <span class="number">1</span>])) &#123;</span><br><span class="line">                        exchange(a, j, j - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Character[] a = &#123;<span class="string">'S'</span>,<span class="string">'H'</span>,<span class="string">'E'</span>,<span class="string">'L'</span>,<span class="string">'L'</span>,<span class="string">'S'</span>, <span class="string">'O'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, <span class="string">'E'</span>, <span class="string">'X'</span>, <span class="string">'A'</span>, <span class="string">'M'</span>, <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'E'</span>&#125;;</span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="keyword">if</span> (isSorted(a)) &#123;</span><br><span class="line">            show(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u6BD4_u8F83"><a href="#u6BD4_u8F83" class="headerlink" title="比较"></a>比较</h2><p>和选择排序和插入排序形成鲜明对比的是，希尔排序也可以用于大型数组。它对任意排序（不一定是随机的）的数组表现也很好。</p>
<p>通过SortCompare可以看到，希尔排序比插入排序要快的多，并且数组越大，优势越大。</p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2017/04/30/algorithm-7/" data-id="cj26adtxr001g2suqz2hgpkbf" class="article-share-link" data-share="baidu" data-title="算法之排序-希尔排序">分享到</a>
      

      
        <a href="http://suqun.github.io/2017/04/30/algorithm-7/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-algorithm-6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/30/algorithm-6/" class="article-date">
  <time datetime="2017-04-30T02:32:10.000Z" itemprop="datePublished">2017-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/30/algorithm-6/">算法之排序-选择排序与插入排序的比较</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>我们将通过以下步骤比较两个算法：</p>
<ul>
<li>实现并调试他们</li>
<li>分析他们的基本性质</li>
<li>对他们的相对性做出猜想</li>
<li>用实验证明我们的猜想</li>
</ul>
<p>前面两节的算法已经实现了第一步，命题A，命题B，命题C组成了第二步，下面的性质D是第三步，之后的比较两种排序算法的SortCompare类将会完成第四步。</p>
<h2 id="u6027_u8D28D"><a href="#u6027_u8D28D" class="headerlink" title="性质D"></a>性质D</h2><p>对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数。</p>
<h2 id="u6BD4_u8F83_u4E24_u79CD_u7B97_u6CD5"><a href="#u6BD4_u8F83_u4E24_u79CD_u7B97_u6CD5" class="headerlink" title="比较两种算法"></a>比较两种算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortCompare</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 对排序算法进行计时</span><br><span class="line">     * <span class="doctag">@param</span> alg 排序算法</span><br><span class="line">     * <span class="doctag">@param</span> a 数组</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">time</span><span class="params">(String alg, Double[] a)</span> </span>&#123;</span><br><span class="line">        Profiler.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (alg.equals(<span class="string">"Insertion"</span>)) &#123;</span><br><span class="line">            Insertion.sort(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (alg.equals(<span class="string">"Selection"</span>)) &#123;</span><br><span class="line">            Selection.sort(a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Profiler.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 使用算法alg将T个长度为N的数组排序</span><br><span class="line">     * <span class="doctag">@param</span> alg 算法</span><br><span class="line">     * <span class="doctag">@param</span> N 数组长度</span><br><span class="line">     * <span class="doctag">@param</span> T T个数组</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">timeRandomInput</span><span class="params">(String alg,<span class="keyword">int</span> N, <span class="keyword">int</span> T)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> total = <span class="number">0.0</span>;</span><br><span class="line">        Double[] a = <span class="keyword">new</span> Double[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; T; t++) &#123;</span><br><span class="line">            <span class="comment">//进行一次测试，生成一个数组并排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                a[i] = uniform();</span><br><span class="line">            &#125;</span><br><span class="line">           total += time(alg,a);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String alg1 = args[<span class="number">0</span>];</span><br><span class="line">        String alg2 = args[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> N = Integer.parseInt(args[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">int</span> T = Integer.parseInt(args[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> t1 = timeRandomInput(alg1,N,T);<span class="comment">//算法1的总时间</span></span><br><span class="line">        <span class="keyword">double</span> t2 = timeRandomInput(alg2,N,T);<span class="comment">//算法2的总时间</span></span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"For %d random Doubles\n %s is "</span>,N,alg1);</span><br><span class="line">        System.out.printf(<span class="string">"%.1f times faster than %s\n "</span>,t2/t1,alg2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Returns a random real number uniformly in [0, 1).</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> a random real number uniformly in [0, 1)</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">uniform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Random().nextDouble();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//程序参数为 Insertion Selection 1000 100 ,运行结果：</span></span><br><span class="line"><span class="comment">//    For 1000 random Doubles</span></span><br><span class="line"><span class="comment">//    Insertion is 1.8 times faster than Selection</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2017/04/30/algorithm-6/" data-id="cj26adtxs001i2suqajfyx8mf" class="article-share-link" data-share="baidu" data-title="算法之排序-选择排序与插入排序的比较">分享到</a>
      

      
        <a href="http://suqun.github.io/2017/04/30/algorithm-6/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MultiThread-5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/29/MultiThread-5/" class="article-date">
  <time datetime="2017-04-29T13:34:44.000Z" itemprop="datePublished">2017-04-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/29/MultiThread-5/">等待超时模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>经常遇到这样的场景：调用一个方法时等待一段时间，如果该方法能够在给定的时间段内得到结果，那么结果立刻返回，反之，超时返回默认结果。</p>
<p>前面介绍了等待/通知的经典范式，即加锁、条件循环和处理逻辑3个步骤，而这种范式无法做到超时等待。超时等待的加入，只需要对经典范式做出小改动，改动如下：</p>
<p>假设超时时间是T，那么可以推断出在当前世界now+T之后就会超时。</p>
<p>定义如下变量</p>
<ul>
<li>等待持续时间：<em>remaining = T</em></li>
<li>超时时间： <em>future = now + T</em></li>
</ul>
<p>这时只需要<code>wait(remaining)</code>即可，在<code>wait(remaining)</code>返回之后将执行：<em>remaining = future - now</em>。如果remining小于等于0，表示已经超时，直接退出，否则继续执行<code>wait(remaining)</code></p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对当前对象加锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> future = System.currentTimeMillis() + mills;</span><br><span class="line">    <span class="keyword">long</span> remaining = mills;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当超时大于0并且result返回值不满足要求</span></span><br><span class="line">    <span class="keyword">while</span> ((result == <span class="keyword">null</span>) &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        wait(remaining);</span><br><span class="line">        remaining = future - System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>超时模式就是在等待/通知模式上添加了超时控制，这使得该模式比原有的范式更具有灵活性，因为即使方法执行时间过长，也不会『永久』阻塞调用者，而是会按照调用者的要求『按时』返回。</p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2017/04/29/MultiThread-5/" data-id="cj26adtym002g2suqnq40dw8z" class="article-share-link" data-share="baidu" data-title="等待超时模式">分享到</a>
      

      
        <a href="http://suqun.github.io/2017/04/29/MultiThread-5/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java多线程/">Java多线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MultiThread-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/29/MultiThread-4/" class="article-date">
  <time datetime="2017-04-29T12:12:18.000Z" itemprop="datePublished">2017-04-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/29/MultiThread-4/">Thread.join()的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止后才从thread.join()返回。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。这两个方法表示，如果线程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回。</p>
<p>例子：</p>
<p>创建10个线程，编号0~9，每个线程调用前一个线程的join()方法，也就是线程0结束了，线程1才能从join()方法中返回，而线程0需要等待main线程结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread previous = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//每个线程拥有前一个线程的引用，需要等待前一个线程的终止，才能从等待中返回</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Domino(previous),String.valueOf(i));</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        previous = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Domino</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    Domino(Thread thread) &#123;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" terminate."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> terminate.</span><br><span class="line"><span class="number">1</span> terminate.</span><br><span class="line"><span class="number">2</span> terminate.</span><br><span class="line"><span class="number">3</span> terminate.</span><br><span class="line"><span class="number">4</span> terminate.</span><br><span class="line"><span class="number">5</span> terminate.</span><br><span class="line"><span class="number">6</span> terminate.</span><br><span class="line"><span class="number">7</span> terminate.</span><br><span class="line"><span class="number">8</span> terminate.</span><br><span class="line"><span class="number">9</span> terminate.</span><br></pre></td></tr></table></figure>
<p>从上述输出可以看到，每个线程的终止前提是前驱线程的终止，这里涉及到了等待/通知机制（等待前驱线程结束，接收前驱线程结束通知）。</p>
<p>join()方法的逻辑结构同等待/通知经典范式一致，即加锁，循环和处理逻辑3个部分。</p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2017/04/29/MultiThread-4/" data-id="cj26adtyo002j2suqi94k1ms3" class="article-share-link" data-share="baidu" data-title="Thread.join()的使用">分享到</a>
      

      
        <a href="http://suqun.github.io/2017/04/29/MultiThread-4/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java多线程/">Java多线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-algorithm-5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/20/algorithm-5/" class="article-date">
  <time datetime="2017-04-20T15:15:44.000Z" itemprop="datePublished">2017-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/20/algorithm-5/">算法之排序-插入排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <h2 id="u7B97_u6CD5_u63CF_u8FF0"><a href="#u7B97_u6CD5_u63CF_u8FF0" class="headerlink" title="算法描述"></a>算法描述</h2><p>通常人们整理桥牌的方法是一张一张的来，将每一张插入到其他已经有序额牌中的适当位置。在计算机实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。这种算法叫做插入排序。</p>
<p>与选择排序一样，当前索引左边的所有元素都是有序的，但他们的最终位置还不确定，为了给更小的元素腾出空间，他们可能会被移动。但是当索引到达数组的右端时，数组排序就完成了。</p>
<p>和选择排序不同的是，插入排序所需要的时间取决于输入中元素的初始顺序。例如，对一个很大且其中的元素已经有序（或者接近有序）的数组进行排序将会比随机顺序的数组或是逆序数组进行排序要快的多。</p>
<h2 id="u547D_u9898B"><a href="#u547D_u9898B" class="headerlink" title="命题B"></a>命题B</h2><p><strong>对于随机排列长度为N且主键不重复的数组，平均情况下插入排序需要 ~ N²/4 次比较以及 ~ N²/4 次交换。最坏情况下需要 ~ N²/2 次比较和 ~ N²/2 次交换，最好情况下需要 N-1次比较和0次交换。</strong></p>
<h2 id="u547D_u9898C"><a href="#u547D_u9898C" class="headerlink" title="命题C"></a>命题C</h2><p><strong>插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。</strong></p>
<h2 id="u7279_u70B9"><a href="#u7279_u70B9" class="headerlink" title="特点"></a>特点</h2><p>插入排序对于部分有序的数组十分高效，也适合小规模数组。</p>
<p>几种典型的部分有序数组：</p>
<ul>
<li>数组中每个元素距离它的最终位置都不远</li>
<li>一个有序的大数组接一个小数组</li>
<li>数组中只有几个元素的位置不正确</li>
</ul>
<h2 id="u4EE3_u7801"><a href="#u4EE3_u7801" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将a按升序排列</span></span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">//将a[i]插入到a[i-1],a[i-2],a[i-3]...之中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(a[j], a[j - <span class="number">1</span>])) &#123;</span><br><span class="line">                    exchange(a, j, j - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Character[] a = &#123;<span class="string">'S'</span>, <span class="string">'O'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, <span class="string">'E'</span>, <span class="string">'X'</span>, <span class="string">'A'</span>, <span class="string">'M'</span>, <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'E'</span>&#125;;</span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="keyword">if</span> (isSorted(a)) &#123;</span><br><span class="line">            show(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// A E E L M O P R S T X </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2017/04/20/algorithm-5/" data-id="cj26adtxt001k2suq9uj20lnx" class="article-share-link" data-share="baidu" data-title="算法之排序-插入排序">分享到</a>
      

      
        <a href="http://suqun.github.io/2017/04/20/algorithm-5/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MultiThread-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/19/MultiThread-3/" class="article-date">
  <time datetime="2017-04-19T14:08:08.000Z" itemprop="datePublished">2017-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/19/MultiThread-3/">ThreadLocal的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。</p>
<p>这个结构附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。</p>
<p><strong>通过set(T)方法设置一个值，在当前线程下再通过get()方法获取到原先设置的值</strong></p>
<p>例子：</p>
<p>构建了一个常用的Profiler类，具有begin和end两个方法，end()方法返回从begin()方法调用到end()方法调用时的时间差，单位是毫秒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一次get()方法调用的时候会初始化（如果set方法没有调用），每个线程会调用一次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TIME_THREADLOCAL.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() - TIME_THREADLOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Profiler.begin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"Cost:"</span> + Profiler.end() + <span class="string">"mills"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2017/04/19/MultiThread-3/" data-id="cj26adtyp002l2suqvlsp4ssx" class="article-share-link" data-share="baidu" data-title="ThreadLocal的使用">分享到</a>
      

      
        <a href="http://suqun.github.io/2017/04/19/MultiThread-3/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java多线程/">Java多线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MultiThread-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/19/MultiThread-2/" class="article-date">
  <time datetime="2017-04-19T13:47:16.000Z" itemprop="datePublished">2017-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/19/MultiThread-2/">等待通知机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <h2 id="u7B49_u5F85_u65B9_u9075_u5FAA_u539F_u5219"><a href="#u7B49_u5F85_u65B9_u9075_u5FAA_u539F_u5219" class="headerlink" title="等待方遵循原则"></a>等待方遵循原则</h2><ol>
<li>获取对象的锁</li>
<li>如果条件不满足，那么调用对象的wait()，被通知后仍要检查条件</li>
<li>条件满足则执行对应的逻辑</li>
</ol>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>( 对象 ) &#123;</span><br><span class="line">    <span class="keyword">while</span> ( 条件不满足 ) &#123;</span><br><span class="line">        对象.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u901A_u77E5_u65B9_u9075_u5FAA_u539F_u5219"><a href="#u901A_u77E5_u65B9_u9075_u5FAA_u539F_u5219" class="headerlink" title="通知方遵循原则"></a>通知方遵循原则</h2><ol>
<li>获得对象的锁</li>
<li>改变条件</li>
<li>通知所有等待在对象上的线程</li>
</ol>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> ( 对象 ) &#123;</span><br><span class="line">    改变条件</span><br><span class="line">    对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u4EE3_u7801_u793A_u4F8B"><a href="#u4EE3_u7801_u793A_u4F8B" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread waitThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Wait(),<span class="string">"WaitThread"</span>);</span><br><span class="line">        waitThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread notifyThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Notify(),<span class="string">"NotifyThread"</span>);</span><br><span class="line">        notifyThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加锁，拥有Lock的Monitor</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">//当条件不满足时，wait，释放lock的锁</span></span><br><span class="line">                <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">"flag is true. wait @ "</span></span><br><span class="line">                                + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//条件满足时，完成工作</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"flag is false. wait @ "</span></span><br><span class="line">                        + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Notify</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加锁，拥有lock的Monitor</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">//获取lock的锁，然后进行通知，通知时不会释放lock的锁</span></span><br><span class="line">                <span class="comment">//直到当前线程释放了lock后，WaitThread才能从wait方法返回</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"hold lock. notify @ "</span></span><br><span class="line">                        + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line"></span><br><span class="line">                lock.notifyAll();<span class="comment">//WaitThread从等待队列进入同步队列,通知时不会释放lock的锁</span></span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//再次加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"hold lock again. notify @ "</span></span><br><span class="line">                        + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="comment">//当前线程释放lock之后，WaitThread从同步队列出去，尝试获取锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[WaitThread,<span class="number">5</span>,main]flag is true. <span class="built_in">wait</span> @ <span class="number">21</span>:<span class="number">35</span>:<span class="number">39</span></span><br><span class="line">Thread[NotifyThread,<span class="number">5</span>,main]hold lock. notify @ <span class="number">21</span>:<span class="number">35</span>:<span class="number">40</span></span><br><span class="line">Thread[NotifyThread,<span class="number">5</span>,main]hold lock again. notify @ <span class="number">21</span>:<span class="number">35</span>:<span class="number">45</span></span><br><span class="line">Thread[WaitThread,<span class="number">5</span>,main]flag is false. <span class="built_in">wait</span> @ <span class="number">21</span>:<span class="number">35</span>:<span class="number">45</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2017/04/19/MultiThread-2/" data-id="cj26adtys002n2suqrmcc8gbv" class="article-share-link" data-share="baidu" data-title="等待通知机制">分享到</a>
      

      
        <a href="http://suqun.github.io/2017/04/19/MultiThread-2/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java多线程/">Java多线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MultiThread-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/19/MultiThread-1/" class="article-date">
  <time datetime="2017-04-19T13:43:26.000Z" itemprop="datePublished">2017-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/19/MultiThread-1/">安全的终止线程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>1、线程中断操作适合用来取消或停止任务</p>
<p>2、利用boolean变量控制需要停止任务并终止该线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程中断取消任务</span></span><br><span class="line">        Runner one = <span class="keyword">new</span> Runner();</span><br><span class="line">        Thread  countThread = <span class="keyword">new</span> Thread(one,<span class="string">"CountThread"</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);<span class="comment">//睡眠1秒</span></span><br><span class="line">        <span class="comment">//Main线程对CountThread进行中断,使CountThread能够感知中断而结束</span></span><br><span class="line">        countThread.interrupt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean变量控制取消任务</span></span><br><span class="line">        Runner two = <span class="keyword">new</span> Runner();</span><br><span class="line">        countThread = <span class="keyword">new</span> Thread(two,<span class="string">"CountThread"</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);<span class="comment">//睡眠1秒</span></span><br><span class="line">        two.cancel();<span class="comment">//Main线程对Runner Two进行取消，使CountThread能够感知on为false而结束</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> i;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> on = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (on &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"i:"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            on = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2017/04/19/MultiThread-1/" data-id="cj26adtyt002p2suqzzttoh4s" class="article-share-link" data-share="baidu" data-title="安全的终止线程">分享到</a>
      

      
        <a href="http://suqun.github.io/2017/04/19/MultiThread-1/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java多线程/">Java多线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MultiThread-0" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/18/MultiThread-0/" class="article-date">
  <time datetime="2017-04-18T12:34:56.000Z" itemprop="datePublished">2017-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/18/MultiThread-0/">线程的状态</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>Java线程在运行的周期中可能处于6种不同的状态，在给定的时刻，线程只能处于其中一个状态</p>
<table>
<thead>
<tr>
<th>状态名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NEW</td>
<td style="text-align:center">初始状态，线程被构建，但是还没有调用start()方法</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td style="text-align:center">运行状态，Java线程将操作系统中的<code>就绪</code>和<code>运行</code>两种状态笼统的成为『运行中』</td>
</tr>
<tr>
<td>BLOCKED</td>
<td style="text-align:center">阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td>WAITING</td>
<td style="text-align:center">等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）</td>
</tr>
<tr>
<td>TIME_WAITING</td>
<td style="text-align:center">超时等待状态，该状态不同于WAITING，它是可以在指定的时间自行返回</td>
</tr>
<tr>
<td>TERMINATED</td>
<td style="text-align:center">终止状态，表示当前线程已执行完毕</td>
</tr>
</tbody>
</table>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/threadthread-state.png" alt="Java线程状态变迁"></p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2017/04/18/MultiThread-0/" data-id="cj26adtyv002r2suqumuoriiv" class="article-share-link" data-share="baidu" data-title="线程的状态">分享到</a>
      

      
        <a href="http://suqun.github.io/2017/04/18/MultiThread-0/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java多线程/">Java多线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-algorithm-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/17/algorithm-4/" class="article-date">
  <time datetime="2017-04-17T13:40:06.000Z" itemprop="datePublished">2017-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/17/algorithm-4/">算法之排序-选择排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <h2 id="u7B97_u6CD5_u63CF_u8FF0"><a href="#u7B97_u6CD5_u63CF_u8FF0" class="headerlink" title="算法描述"></a>算法描述</h2><ol>
<li>首先，找到数组中最小的元素</li>
<li>其次，将它和数组的第一个元素交换位置（如果第一个是最小的，就和自己交换）</li>
<li>再次，在剩下的元素中找到最小的元素，将它与第二个元素交换位置。</li>
<li>如此往复，直到将整个数组排序</li>
</ol>
<h2 id="u547D_u9898A"><a href="#u547D_u9898A" class="headerlink" title="命题A"></a>命题A</h2><p><strong>对于长度为N的数组，选择排序需要大约N²/2次比较和N次交换</strong></p>
<h2 id="u7279_u70B9"><a href="#u7279_u70B9" class="headerlink" title="特点"></a>特点</h2><ol>
<li><p><strong>运行时间和输入无关。</strong></p>
<p> 为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息。这种性质在某些情况下是缺点，一个已经有序的数组或者主键全部相等的数组和一个元素随机排列的数组所用的排序时间一样长！</p>
</li>
<li><p><strong>数据移动是最少的。</strong></p>
<p> 每次交换都会改变两个元素的位置的值，因此选择排序用了N次交换——交换次数和数组的大小是线性关系。其他任何算法都不具备这个特征（大部分的增长数量级都是线性对数或者平方级别）</p>
</li>
</ol>
<h2 id="u4EE3_u7801"><a href="#u4EE3_u7801" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将a按升序排列</span></span><br><span class="line">        <span class="keyword">int</span> N = a.length;<span class="comment">//数组长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">//将a[i]和a[n+1...N]最小的元素交换</span></span><br><span class="line">            <span class="keyword">int</span> min = i;<span class="comment">//最小元素的索引</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(a[j],a[min])) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            exchange(a,i,min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Character[] a = &#123;<span class="string">'S'</span>,<span class="string">'O'</span>,<span class="string">'R'</span>,<span class="string">'T'</span>,<span class="string">'E'</span>,<span class="string">'X'</span>,<span class="string">'A'</span>,<span class="string">'M'</span>,<span class="string">'P'</span>,<span class="string">'L'</span>,<span class="string">'E'</span>&#125;;</span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="keyword">if</span> (isSorted(a)) &#123;</span><br><span class="line">            show(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//A E E L M O P R S T X </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中less方法和exchange方法在工具类中，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 比较两个对象大小</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> v</span><br><span class="line">     * <span class="doctag">@param</span> w</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 交换数组元素位置</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> a</span><br><span class="line">     * <span class="doctag">@param</span> i</span><br><span class="line">     * <span class="doctag">@param</span> j</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Comparable t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 打印数组元素</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> a</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 判断数组元素是否有序</span><br><span class="line">     * <span class="doctag">@param</span> a</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(a[i], a[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2017/04/17/algorithm-4/" data-id="cj26adtxv001m2suqfvycxy2o" class="article-share-link" data-share="baidu" data-title="算法之排序-选择排序">分享到</a>
      

      
        <a href="http://suqun.github.io/2017/04/17/algorithm-4/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-algorithm-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/17/algorithm-3/" class="article-date">
  <time datetime="2017-04-16T16:08:44.000Z" itemprop="datePublished">2017-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/17/algorithm-3/">算法之数据结构——树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2017/04/17/algorithm-3/" data-id="cj26adtxw001o2suqazhdwwjt" class="article-share-link" data-share="baidu" data-title="算法之数据结构——树">分享到</a>
      

      
        <a href="http://suqun.github.io/2017/04/17/algorithm-3/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-algorithm-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/03/algorithm-2/" class="article-date">
  <time datetime="2017-04-03T11:09:59.000Z" itemprop="datePublished">2017-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/03/algorithm-2/">算法之数据结构——链表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="u5355_u94FE_u8868_u7684_u521B_u5EFA_u548C_u5220_u9664"><a href="#u5355_u94FE_u8868_u7684_u521B_u5EFA_u548C_u5220_u9664" class="headerlink" title="单链表的创建和删除"></a>单链表的创建和删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * LinkList java单向链表实现及基础操作</span><br><span class="line"> * Created by larry.su on 2017/4/3.</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 指向头结点</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 指向尾节点</span><br><span class="line">     * 需要根据尾节点操作时就不用每次都从头结点循环得到尾节点</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 添加元素到链表尾端</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> value 添加的数据</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToTail</span><span class="params">(E value)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//        if (null == first) &#123;</span></span><br><span class="line"><span class="comment">//            first = node;</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            Node pNode = first;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            while (null != pNode.next) &#123;</span></span><br><span class="line"><span class="comment">//                pNode = pNode.next;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            pNode.next = node;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == first) &#123;</span><br><span class="line">            first = node;</span><br><span class="line">            last = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last.next = node;</span><br><span class="line">            last = node;<span class="comment">//使用last 可以减少循环获取最后节点步骤</span></span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 删除第一个含有该值的节点</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> object</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != first) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.getValue().equals(object)) &#123;</span><br><span class="line">                first.next = <span class="keyword">null</span>;</span><br><span class="line">                first.value = <span class="keyword">null</span>;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Node preDeleteNode = first;<span class="comment">//待删除的前一个节点</span></span><br><span class="line">            Node deleteNode;<span class="comment">//待删除的节点</span></span><br><span class="line">            <span class="keyword">while</span> (preDeleteNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (preDeleteNode.next.getValue() == object) &#123;</span><br><span class="line">                    deleteNode = preDeleteNode.next;</span><br><span class="line">                    preDeleteNode.next = deleteNode.next;</span><br><span class="line">                    deleteNode.next = <span class="keyword">null</span>;</span><br><span class="line">                    deleteNode.value = <span class="keyword">null</span>;</span><br><span class="line">                    size--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    preDeleteNode = preDeleteNode.getNext();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@AllArgsConstructor</span></span><br><span class="line">    <span class="annotation">@ToString</span></span><br><span class="line">    <span class="annotation">@Data</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E value;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkList linkList = <span class="keyword">new</span> LinkList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            linkList.addToTail(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        linkList.remove(<span class="number">5</span>);</span><br><span class="line">        System.out.println(linkList);</span><br><span class="line">        linkList.remove(<span class="number">3</span>);</span><br><span class="line">        System.out.println(linkList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2017/04/03/algorithm-2/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2017/04/03/algorithm-2/" data-id="cj26adtxy001q2suqsm8akf17" class="article-share-link" data-share="baidu" data-title="算法之数据结构——链表">分享到</a>
      

      
        <a href="http://suqun.github.io/2017/04/03/algorithm-2/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-algorithm-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/22/algorithm-1/" class="article-date">
  <time datetime="2017-03-22T02:25:07.000Z" itemprop="datePublished">2017-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/22/algorithm-1/">算法之数据结构——数组</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="u4E8C_u7EF4_u6570_u7EC4_u4E2D_u7684_u67E5_u627E"><a href="#u4E8C_u7EF4_u6570_u7EC4_u4E2D_u7684_u67E5_u627E" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p><strong>在一个二维数组中，每一行按照从左到右递增顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</strong></p>
<p>当我们要解决一个复杂的问题时，一个很有效的方法就是从一个具体的问题入手，通过分析简单的例子，试图寻找普遍的规律。</p>
<p><strong>具体的🌰</strong>：例如下面的数组就是每行每列递增排序。如果在这个数组中查找到数字7则返回true；如果查找数字5，则返回false。</p>
<p><strong>解决方法</strong>：从数组的一个角上选取数字来和要查找的数字做比较。情况会变的简单</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/algoritm-array-1.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumberExist</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> columns, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arrays = generalArray();</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> column = columns-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (column &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrays[row][column] &gt; number) &#123;</span><br><span class="line">            column--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arrays[row][column] &lt; number) &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] generalArray() &#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arrays = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span>&#125;, &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arrays;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2017/03/22/algorithm-1/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2017/03/22/algorithm-1/" data-id="cj26adtxz001s2suq0eto5kai" class="article-share-link" data-share="baidu" data-title="算法之数据结构——数组">分享到</a>
      

      
        <a href="http://suqun.github.io/2017/03/22/algorithm-1/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JVM-note-8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/08/JVM-note-8/" class="article-date">
  <time datetime="2017-03-08T14:14:36.000Z" itemprop="datePublished">2017-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/08/JVM-note-8/">JVM笔记八：Sun JDK监控和故障处理工具</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Sun JDK监控和故障处理工具:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:center">主要作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>jps</td>
<td style="text-align:center">JVM Process Status Tool，显示指定系统内所有HotSpot虚拟机进程</td>
</tr>
<tr>
<td>jstat</td>
<td style="text-align:center">JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面的运行数据</td>
</tr>
<tr>
<td>jinfo</td>
<td style="text-align:center">Configuration Info for Java，显示虚拟机配置信息</td>
</tr>
<tr>
<td>jmap</td>
<td style="text-align:center">Memory Map for Java,生成虚拟机的内存转出快照(heapdump)文件</td>
</tr>
<tr>
<td>jhat</td>
<td style="text-align:center">JVM Heap Dump Browser,用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户在浏览器上查看分析结果</td>
</tr>
<tr>
<td>jstack</td>
<td style="text-align:center">Stack Trace for Java,显示虚拟机的线程快照</td>
</tr>
</tbody>
</table>
        
          <p class="article-more-link">
            <a href="/2017/03/08/JVM-note-8/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2017/03/08/JVM-note-8/" data-id="cj26adtzq003t2suqmcvsirto" class="article-share-link" data-share="baidu" data-title="JVM笔记八：Sun JDK监控和故障处理工具">分享到</a>
      

      
        <a href="http://suqun.github.io/2017/03/08/JVM-note-8/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JVM-note-7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/21/JVM-note-7/" class="article-date">
  <time datetime="2017-02-21T02:31:45.000Z" itemprop="datePublished">2017-02-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/21/JVM-note-7/">JVM笔记七：垃圾收集器与内存分配策略——内存分配与回收策略</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对象的内存分配，往大方向讲，就是在堆上分配（也可能经过JIT编译后被拆散为标量类型并间接的在栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下分配在老生代上，分配的规则并不是百分百固定的，其细节取决于当前使用的哪种垃圾收集器组合，还有虚拟机内存相关参数的设置。</p>
<h2 id="u5BF9_u8C61_u4F18_u5148_u5728Eden_u533A_u5206_u914D"><a href="#u5BF9_u8C61_u4F18_u5148_u5728Eden_u533A_u5206_u914D" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h2><p>上一篇垃圾收集器的GC示例已经把各个收集器的内存分配测试做了一遍，可以回顾上篇内容。</p>
        
          <p class="article-more-link">
            <a href="/2017/02/21/JVM-note-7/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2017/02/21/JVM-note-7/" data-id="cj26adtzr003w2suq9bm93yv4" class="article-share-link" data-share="baidu" data-title="JVM笔记七：垃圾收集器与内存分配策略——内存分配与回收策略">分享到</a>
      

      
        <a href="http://suqun.github.io/2017/02/21/JVM-note-7/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JVM-note-6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/19/JVM-note-6/" class="article-date">
  <time datetime="2017-02-19T01:37:38.000Z" itemprop="datePublished">2017-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/19/JVM-note-6/">JVM笔记六：垃圾收集器与内存分配策略——垃圾收集器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>基于JDK1.7 Update 14之后的HotSpot虚拟机的垃圾收集器。</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-gc.png" alt=""></p>
<p>两个收集器之间有连线，说明他们可以搭配使用。收集器所处的区域，则表示他是属于新生代收集器还是老生代收集器。</p>
<h2 id="Serial_u6536_u96C6_u5668"><a href="#Serial_u6536_u96C6_u5668" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-serial.png" alt=""></p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-serial-1.png" alt="Serial / Serial Old收集器运行示意图"></p>
<p><strong>新生代收集（Minor GC）</strong></p>
<p>下面代码尝试分配3个2MB大小和1个4MB大小的对象</p>
<ul>
<li>运行通过<strong>-Xms20M</strong>（堆初始大小）、<strong>-Xmx20M</strong>（堆最大值）、<strong>-Xmn10M</strong>（新生代值）这3个参数限制了Java堆大小为20MB，不可扩展，其中10MB分配给新生代，剩下的10MB分配给老年代</li>
<li><strong>-XX:SurvivorRatio=8</strong> 决定了新生代中Eden区与一个Survivor区的空间比例为 8:1</li>
<li><strong>新生代总可用空间：9216KB（Eden区+1个Survivor区的总容量）</strong></li>
<li><strong>-XX:+PrintGCDetail</strong>，在发生垃圾收集时打印内存回收日志</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2017/02/19/JVM-note-6/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2017/02/19/JVM-note-6/" data-id="cj26adtzs003y2suqkoncifj5" class="article-share-link" data-share="baidu" data-title="JVM笔记六：垃圾收集器与内存分配策略——垃圾收集器">分享到</a>
      

      
        <a href="http://suqun.github.io/2017/02/19/JVM-note-6/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JVM-note-5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/18/JVM-note-5/" class="article-date">
  <time datetime="2017-02-18T13:11:15.000Z" itemprop="datePublished">2017-02-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/18/JVM-note-5/">JVM笔记五：垃圾收集器与内存分配策略——垃圾收集算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="u6807_u8BB0-_u6E05_u9664_u7B97_u6CD5"><a href="#u6807_u8BB0-_u6E05_u9664_u7B97_u6CD5" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>最基础的垃圾收集算法。</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-mark-sweep-1.png" alt=""></p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-mark-sweep.png" alt=""></p>
<p>参考：<a href="http://www.jianshu.com/p/b0f5d21fe031">http://www.jianshu.com/p/b0f5d21fe031</a></p>
        
          <p class="article-more-link">
            <a href="/2017/02/18/JVM-note-5/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2017/02/18/JVM-note-5/" data-id="cj26adtzt00402suq0muhxukd" class="article-share-link" data-share="baidu" data-title="JVM笔记五：垃圾收集器与内存分配策略——垃圾收集算法">分享到</a>
      

      
        <a href="http://suqun.github.io/2017/02/18/JVM-note-5/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-JVM-note-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/18/JVM-note-4/" class="article-date">
  <time datetime="2017-02-18T02:27:59.000Z" itemprop="datePublished">2017-02-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/18/JVM-note-4/">JVM笔记四：垃圾收集器与内存分配策略——对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在堆里存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还存活着，哪些已经死去（即不可能再被任何途径使用的对象）。</p>
<h3 id="u5F15_u7528_u8BA1_u6570_u6CD5"><a href="#u5F15_u7528_u8BA1_u6570_u6CD5" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用计数法（Reference Counting）：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；任何时刻计数器为0的对象是不可能被使用的。主流的Java虚拟机里没有使用引用计数法来管理内存，主要原因是它很难解决对象之间的相互循环引用的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 引用计数器算法的缺陷</span><br><span class="line"> * VM Args：-XX:+PrintGCDetails</span><br><span class="line"> * JDK1.6</span><br><span class="line"> * Created by larry.su on 2017/2/18.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1M = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个成员属性的唯一意义就是占用点内存，以便能在GC中看清楚是否被回收过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1M];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line"></span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//假设此时发生GC，objA和objB是否会被回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System)</span> [CMS: 0K-&gt;423<span class="title">K</span><span class="params">(<span class="number">63872</span>K)</span>, 0.0099285 secs] **6167K-&gt;423K**<span class="params">(<span class="number">83008</span>K)</span>, [CMS Perm : 4749K-&gt;4747<span class="title">K</span><span class="params">(<span class="number">21248</span>K)</span>], 0.0107293 secs] [Times: user</span>=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> par <span class="keyword">new</span> generation   total <span class="number">19136</span>K, used <span class="number">1021</span>K [<span class="number">7f</span>3000000, <span class="number">7f</span>44c0000, <span class="number">7f</span>44c0000)</span><br><span class="line">  eden space <span class="number">17024</span>K,   <span class="number">6</span>% used [<span class="number">7f</span>3000000, <span class="number">7f</span>30ff670, <span class="number">7f</span>40a0000)</span><br><span class="line">  from space <span class="number">2112</span>K,   <span class="number">0</span>% used [<span class="number">7f</span>40a0000, <span class="number">7f</span>40a0000, <span class="number">7f</span>42b0000)</span><br><span class="line">  to   space <span class="number">2112</span>K,   <span class="number">0</span>% used [<span class="number">7f</span>42b0000, <span class="number">7f</span>42b0000, <span class="number">7f</span>44c0000)</span><br><span class="line"> concurrent mark-sweep generation total <span class="number">63872</span>K, used <span class="number">423</span>K [<span class="number">7f</span>44c0000, <span class="number">7f</span>8320000, <span class="number">7f</span>ae00000)</span><br><span class="line"> concurrent-mark-sweep perm gen total <span class="number">21248</span>K, used <span class="number">4880</span>K [<span class="number">7f</span>ae00000, <span class="number">7f</span>c2c0000, <span class="number">800000000</span>)</span><br></pre></td></tr></table></figure>
<p><strong>6167K-&gt;423K(83008K)</strong>意味着虚拟机并没有因为这两个对象并相互引用就不回收他们，也从侧面说明虚拟机并不是通过引用计数法来判断对象是否存活的。</p>
        
          <p class="article-more-link">
            <a href="/2017/02/18/JVM-note-4/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2017/02/18/JVM-note-4/" data-id="cj26adtzu00412suqnfblkuhd" class="article-share-link" data-share="baidu" data-title="JVM笔记四：垃圾收集器与内存分配策略——对象">分享到</a>
      

      
        <a href="http://suqun.github.io/2017/02/18/JVM-note-4/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JVM-note-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/16/JVM-note-3/" class="article-date">
  <time datetime="2017-02-16T13:35:09.000Z" itemprop="datePublished">2017-02-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/16/JVM-note-3/">JVM笔记三：Java内存区域与内存溢出异常——OutOfMemoryError异常</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Java_u5806_u6EA2_u51FA"><a href="#Java_u5806_u6EA2_u51FA" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><p>Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大的容量限制后就会产生内存溢出异常。</p>
<p>下面代码限制Java堆的大小为20MB，不可扩展（将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出时Dump出当前的内存堆转储快照以便事后进行分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * HeapOOM</span><br><span class="line"> * Created by larry.su on 2017/2/7.</span><br><span class="line"> * -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid65766.hprof ...</span><br><span class="line">Heap dump file created [<span class="number">27784157</span> bytes in <span class="number">0.137</span> secs]</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2017/02/16/JVM-note-3/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2017/02/16/JVM-note-3/" data-id="cj26adtzv00432suqnnuyyvlm" class="article-share-link" data-share="baidu" data-title="JVM笔记三：Java内存区域与内存溢出异常——OutOfMemoryError异常">分享到</a>
      

      
        <a href="http://suqun.github.io/2017/02/16/JVM-note-3/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JVM-note-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/14/JVM-note-2/" class="article-date">
  <time datetime="2017-02-14T12:42:05.000Z" itemprop="datePublished">2017-02-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/14/JVM-note-2/">JVM笔记二：Java内存区域与内存溢出异常——HotSpot虚拟机对象探秘</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>以常用的虚拟机HotSpot和常用的内存区域Java堆为例，深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。</p>
<h3 id="u5BF9_u8C61_u7684_u521B_u5EFA"><a href="#u5BF9_u8C61_u7684_u521B_u5EFA" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-new.png" alt="java对象的创建"></p>
<ul>
<li>虚拟机遇到一条new指令</li>
<li><strong>检查</strong>这个指令的参数是否能在常量池中定位到一个类的符号引用。并且检查这个符号引用代表的类是否已被加载、解析、初始化过，没有必须先执行相应的类加载过程。</li>
<li><strong>指针碰撞</strong>：若干Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配的内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</li>
<li><strong>空闲列表</strong>：如果java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，JVM必须维护一个空闲列表用来记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</li>
<li>内存分配完成以后，虚拟机需要将<strong>分配到的内存空间都初始化为零值</strong>（不包括对象头），确保对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>
<li>接下来，<strong>JVM对对象进行必要的设置</strong>，例如：这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希值、对象的GC分代年龄等信息。这些信息存放在对象头（Object Header）中。</li>
<li>上面的工作完成之后，<strong>从JVM的角度，一个新的对象以及产生</strong>了。</li>
<li><strong>对Java程序来说，对象所有的字段都为零值</strong>，所以一般来说，执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象就完全产生出来。</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2017/02/14/JVM-note-2/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2017/02/14/JVM-note-2/" data-id="cj26adtzx00452suqwm0d2r54" class="article-share-link" data-share="baidu" data-title="JVM笔记二：Java内存区域与内存溢出异常——HotSpot虚拟机对象探秘">分享到</a>
      

      
        <a href="http://suqun.github.io/2017/02/14/JVM-note-2/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JVM-note-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/25/JVM-note-1/" class="article-date">
  <time datetime="2016-12-25T06:56:19.000Z" itemprop="datePublished">2016-12-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/25/JVM-note-1/">JVM笔记一：Java内存区域与内存溢出异常——运行时数据区域</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>该系列学习笔记均来自《深入理解Java虚拟机》一书。</p>
<h3 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h3><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com//jvm-runtime-3.png" alt="Java虚拟机运行时数据区"></p>
        
          <p class="article-more-link">
            <a href="/2016/12/25/JVM-note-1/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/12/25/JVM-note-1/" data-id="cj26adtzy00472suqs59chcyv" class="article-share-link" data-share="baidu" data-title="JVM笔记一：Java内存区域与内存溢出异常——运行时数据区域">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/12/25/JVM-note-1/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java-NIO-SocketChannel" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/27/Java-NIO-SocketChannel/" class="article-date">
  <time datetime="2016-11-27T13:12:38.000Z" itemprop="datePublished">2016-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/27/Java-NIO-SocketChannel/">Java NIO SocketChannel</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>原文：<a href="http://tutorials.jenkov.com/java-nio/socketchannel.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-nio/socketchannel.html</a></p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/11/27/Java-NIO-SocketChannel/" data-id="cj26adtzf003d2suq541kaxcp" class="article-share-link" data-share="baidu" data-title="Java NIO SocketChannel">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/11/27/Java-NIO-SocketChannel/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-NIO/">Java NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java-NIO-FileChannel" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/22/Java-NIO-FileChannel/" class="article-date">
  <time datetime="2016-11-21T16:14:33.000Z" itemprop="datePublished">2016-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/22/Java-NIO-FileChannel/">Java NIO FileChannel</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>原文：[<a href="http://tutorials.jenkov.com/java-nio/file-channel.html]{http://tutorials.jenkov.com/java-nio/file-channel.html}" target="_blank" rel="external">http://tutorials.jenkov.com/java-nio/file-channel.html]{http://tutorials.jenkov.com/java-nio/file-channel.html}</a></p>
<p>Java NIO中的FileChannel是一个连接文件的channel，可以使用它从文件中读取数据或向文件中写入数据。Java NIO的FileChannel是NIO的一个选择相对标准的Java IO API来说。</p>
<p>FileChannel可以设置成非阻塞模式，但是仍然会按照阻塞模式运行。</p>
<h2 id="u6253_u5F00FileChannel"><a href="#u6253_u5F00FileChannel" class="headerlink" title="打开FileChannel"></a>打开FileChannel</h2><p>在使用FileChannel时需要先打开它，但是不能直接打开。需要借助InputStream,OutputStream或者是RandomAccessFile。</p>
<p>举个🌰： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile     = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      inChannel = aFile.getChannel();</span><br></pre></td></tr></table></figure>
<h2 id="u4ECEFileChannel_u8BFB_u6570_u636E"><a href="#u4ECEFileChannel_u8BFB_u6570_u636E" class="headerlink" title="从FileChannel读数据"></a>从FileChannel读数据</h2><p>从FileChannel读数据可以调用<code>read()</code>方法。</p>
<p>举个🌰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br></pre></td></tr></table></figure>
<p>首先给Buffer分配字节， FileChannel中的数据就是读到Buffer中。</p>
<p>其次，再调用<code>FileChannel.read()</code>方法。从FileChannel中将数据读入buffer。read()的整型返回值告诉我们已经写入Buffer的字节量。如果返回<code>-1</code>,就是读到了文件的结尾。</p>
<h2 id="FileChannel_u5199_u5165_u6570_u636E"><a href="#FileChannel_u5199_u5165_u6570_u636E" class="headerlink" title="FileChannel写入数据"></a>FileChannel写入数据</h2><p>Writing data to a FileChannel is done using the FileChannel.write() method, which takes a Buffer as parameter. Here is an example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Notice how the FileChannel.write() method is called inside a while-loop. There is no guarantee of how many bytes the write() method writes to the FileChannel. Therefore we repeat the write() call until the Buffer has no further bytes to write.</p>
<h2 id="u5173_u95EDFileChannel"><a href="#u5173_u95EDFileChannel" class="headerlink" title="关闭FileChannel"></a>关闭FileChannel</h2><p>When you are done using a FileChannel you must close it. Here is how that is done:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br></pre></td></tr></table></figure>
<h2 id="FileChannel_Position"><a href="#FileChannel_Position" class="headerlink" title="FileChannel Position"></a>FileChannel Position</h2><p>When reading or writing to a FileChannel you do so at a specific position. You can obtain the current position of the FileChannel object by calling the position() method.</p>
<p>You can also set the position of the FileChannel by calling the position(long pos) method.</p>
<p>Here are two examples:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> pos channel.position();</span><br><span class="line"></span><br><span class="line">channel.position(pos +<span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<p>If you set the position after the end of the file, and try to read from the channel, you will get -1 - the end-of-file marker.</p>
<p>If you set the position after the end of the file, and write to the channel, the file will be expanded to fit the position and written data. This may result in a “file hole”, where the physical file on the disk has gaps in the written data.</p>
<h2 id="FileChannel_Size"><a href="#FileChannel_Size" class="headerlink" title="FileChannel Size"></a>FileChannel Size</h2><p>The size() method of the FileChannel object returns the file size of the file the channel is connected to. Here is a simple example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> fileSize = channel.size();</span><br></pre></td></tr></table></figure>
<h2 id="FileChannel_Truncate"><a href="#FileChannel_Truncate" class="headerlink" title="FileChannel Truncate"></a>FileChannel Truncate</h2><p>You can truncate a file by calling the FileChannel.truncate() method. When you truncate a file, you cut it off at a given length. Here is an example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.truncate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
<p>This example truncates the file at 1024 bytes in length.</p>
<h2 id="FileChannel_Force"><a href="#FileChannel_Force" class="headerlink" title="FileChannel Force"></a>FileChannel Force</h2><p>The FileChannel.force() method flushes all unwritten data from the channel to the disk. An operating system may cache data in memory for performance reasons, so you are not guaranteed that data written to the channel is actually written to disk, until you call the force() method.</p>
<p>The force() method takes a boolean as parameter, telling whether the file meta data (permission etc.) should be flushed too.</p>
<p>Here is an example which flushes both data and meta data:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.force(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/11/22/Java-NIO-FileChannel/" data-id="cj26adtzk003l2suqdyoj9yyc" class="article-share-link" data-share="baidu" data-title="Java NIO FileChannel">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/11/22/Java-NIO-FileChannel/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-NIO/">Java NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java-NIO-Selector" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/16/Java-NIO-Selector/" class="article-date">
  <time datetime="2016-11-16T14:27:08.000Z" itemprop="datePublished">2016-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/16/Java-NIO-Selector/">Java NIO Selector</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>原文：<a href="http://tutorials.jenkov.com/java-nio/selectors.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-nio/selectors.html</a></p>
<p><code>Selector</code>是Java NIO中用来检查一个或多个NIO通道的，决定哪个通道做好准备进行读写的组件。这样，一个单线程就可以管理多个通道，以便管理多个网络连接。</p>
<h2 id="u4E3A_u4F55_u4F7F_u7528Selector_3F"><a href="#u4E3A_u4F55_u4F7F_u7528Selector_3F" class="headerlink" title="为何使用Selector?"></a>为何使用Selector?</h2><p>使用单线程处理多通道的好处就是可以使用更少的线程处理多个通道。实际上可以使用只用一个线程处理多个通道。在操作系统中，线程切换开销很大。每个线程都会占用一些资源（内存）。因此，线程越少越好。</p>
<p>但是，当前操作系统和CPU多任务处理上已经非常好，多线程的开销已经变得很小了。如果一个CPU有多个内核，不使用多任务可能是在浪费CPU能力。不管怎么说，关于那种设计的讨论应该放在另一篇不同的文章中。在这里，只要知道使用Selector能够处理多个通道就足够了。</p>
<p>使用一个Selector处理3个channel的图解如下：</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/JavaNIOSelectors.png" alt="
Java NIO: A Thread uses a Selector to handle 3 Channel&#39;s"></p>
<h2 id="Selector_u7684_u521B_u5EFA"><a href="#Selector_u7684_u521B_u5EFA" class="headerlink" title="Selector的创建"></a>Selector的创建</h2><p>调用<code>Selector.open()</code>方法创建一个selector。像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>
<h2 id="Channel_u6CE8_u518C_u5230Selector_u4E0A"><a href="#Channel_u6CE8_u518C_u5230Selector_u4E0A" class="headerlink" title="Channel注册到Selector上"></a>Channel注册到Selector上</h2><p>为了结合Selector使用Channel，首先要将Channel注册到Selector上。通过方法<code>SelectableChannel.register()</code>实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>
<p>结合Selector使用时，Channel必须是非阻塞师的。这就意味着，你不能把FileChannel和Selector结合使用，因为FileChannel不能切换到非阻塞模式。Socket Channel确可以很好的结合Selector使用。</p>
<p><code>register()</code>方法的第二个参数需要注意下。这是个有趣的设置，意思是在通过Selector监听Channel时刚兴趣的事件。可以监听到以下四种事件：</p>
<ul>
<li>Connect</li>
<li>Accept</li>
<li>Read</li>
<li>Write</li>
</ul>
<p>一个channel触发了事件就是意味着该事件已就绪。因此，channel连接服务成功就是<code>Connect</code>就绪。服务socke channel准备接受进入的连接就是<code>Accept</code>就绪。服务socket channel已经准备好了可以读取的数据就是<code>Read</code>就绪。channel准备好可以写入数据就是<code>Write</code>就绪。</p>
<p>这四种事件用SelectionKey的常量表示： </p>
<ul>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ul>
<p>如果对多个事件感兴趣，那么可以用“位或”操作符将常量连接起来，像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>
<p>下面还会继续提到interest集合。</p>
<h2 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h2><p>通过前面示例可以看到，调用<code>register()</code>方法向selector上注册channel时返回<code>SelectionKey</code>对象。这个<code>SelectionKey</code>对象中包含很多有趣的属性。</p>
<ul>
<li>interest集合</li>
<li>ready 集合</li>
<li>Channel</li>
<li>Selector</li>
<li>附加对象（可选）</li>
</ul>
<p>下面会描述这些属性。</p>
<h3 id="Interest_u96C6_u5408"><a href="#Interest_u96C6_u5408" class="headerlink" title="Interest集合"></a>Interest集合</h3><p>就像向Selector注册通道一节中所描述的，interest集合是你所选择的感兴趣的事件集合。通过SelectionKey可以读写interest集合。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = interestSet &amp; SelectionKey.OP_ACCEPT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>
<p>可以看到，使用『位与』操作interest集合和给定的的SelectionKey常量，可以确定某个确定的世界是否在interest集合中。</p>
<h3 id="Ready_u96C6_u5408"><a href="#Ready_u96C6_u5408" class="headerlink" title="Ready集合"></a>Ready集合</h3><p>ready集合是channel已经准备就绪的channel集合。在一次<code>selection</code>以后，可以先获得ready集合。至于<code>selecton</code>，会再下面的章节解释。可以这样获取ready集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readySet = selectionKey.readyOps();</span><br></pre></td></tr></table></figure>
<p>可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure>
<h3 id="Channel_+_Selector"><a href="#Channel_+_Selector" class="headerlink" title="Channel + Selector"></a>Channel + Selector</h3><p>Accessing the channel + selector from the SelectionKey is trivial. Here is how it’s done:<br>从SelectionKey中获得channel和selector很简单，像这样就好:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure>
<h3 id="u9644_u52A0_u5BF9_u8C61"><a href="#u9644_u52A0_u5BF9_u8C61" class="headerlink" title="附加对象"></a>附加对象</h3><p>可以将一个对象附加到SelectionKey上。这是个识别给定的channel的简便方法，还可以附加更多信息上去。比如，附加个与channel一起使用的buffer，或者聚合更多数据的对象。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure>
<p>也可以在注册时附加对象，像这样： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure>
<h2 id="u901A_u8FC7Selector_u9009_u62E9Channel"><a href="#u901A_u8FC7Selector_u9009_u62E9Channel" class="headerlink" title="通过Selector选择Channel"></a>通过Selector选择Channel</h2><p>一旦向Selector注册了一个或多个channel，就可以调用任一<code>select()</code>方法。这些方法返回那些注册时感兴趣事件（connect，accept，read 或者 write）的channel。<br>也就是说，如果感兴趣的channel已对读数据做好准备，那么在调用<code>select()</code>方法以后，就会返回对读就绪的channel。</p>
<p>select方法有以下几种:</p>
<ol>
<li><code>int select()</code></li>
<li><code>int select(long timeout)</code></li>
<li><code>int selectNow()</code></li>
</ol>
<p><code>select()</code> 阻塞直到至少一个channel已经对监听事件做好准备。</p>
<p><code>select(long timeout)</code> 和<code>select()</code>一样，除了最长会阻塞timeout毫秒(参数)。</p>
<p><code>selectNow()</code> 不会阻塞，无论channel有没有准备好都会直接返回。（没有准备好的直接返回0）</p>
<p>select()方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。如果调用select()方法，因为有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。</p>
<h3 id="selectedKeys_28_29"><a href="#selectedKeys_28_29" class="headerlink" title="selectedKeys()"></a>selectedKeys()</h3><p>调用select()方法后，一旦其返回值表明一个或多个channel就绪，就可以通过<code>selectedKeys()</code>方法访问『selected key set』（已选择键集）中的就绪channel。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure>
<p>调用<code>Channel.register()</code>向selector注册channel以后返回<code>SelectionKey</code>对象。这个对象就代表了注册到selector的channel。可以通过SelectionKey对象的<code>electedKeySet()</code>方法获得这些对象。</p>
<p>遍历已选择的键集获得就绪的channel： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    </span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个循环遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件。</p>
<p>注意在每次遍历后调用<code>keyIterator.remove()</code>方法。Selector不会从已选择键集中自动删除SelectionKey的实例。在处理完channel后必须调用此方法。下次channel会准备好，Selector将其重新添加到已选择的键集中。 （原文：Notice the keyIterator.remove() call at the end of each iteration. The Selector does not remove the SelectionKey instances from the selected key set itself. You have to do this, when you are done processing the channel. The next time the channel becomes “ready” the Selector will add it to the selected key set again.）</p>
<p>调用<code>SelectionKey.channel()</code>方法会返回需要处理的channel。比如ServerSocketChannel或者SocketChannel等。</p>
<h3 id="wakeUp_28_29_u65B9_u6CD5"><a href="#wakeUp_28_29_u65B9_u6CD5" class="headerlink" title="wakeUp()方法"></a>wakeUp()方法</h3><p>某个线程调用select()方法以后会被阻塞，即使没有就绪的channel，也可以使其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。</p>
<p>如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wake up）”。</p>
<h3 id="close_28_29_u65B9_u6CD5"><a href="#close_28_29_u65B9_u6CD5" class="headerlink" title="close()方法"></a>close()方法</h3><p>用完Selector后调用其close()方法会关闭该Selector，且使注册到该Selector上的所有SelectionKey实例无效。通道本身并不会关闭。</p>
<h2 id="u5B8C_u6574_u7684Selector_u793A_u4F8B"><a href="#u5B8C_u6574_u7684Selector_u793A_u4F8B" class="headerlink" title="完整的Selector示例"></a>完整的Selector示例</h2><p>下面是一个完整的selector例子，open,register,监听等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> readyChannels = selector.select();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">  Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/11/16/Java-NIO-Selector/" data-id="cj26adtzg003f2suq9rxn74jk" class="article-share-link" data-share="baidu" data-title="Java NIO Selector">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/11/16/Java-NIO-Selector/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-NIO/">Java NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java-NIO-Channel-to-Channel-Transfers" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/10/Java-NIO-Channel-to-Channel-Transfers/" class="article-date">
  <time datetime="2016-11-10T03:05:11.000Z" itemprop="datePublished">2016-11-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/10/Java-NIO-Channel-to-Channel-Transfers/">Java NIO Channel之间的数据传输</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>原文：<a href="http://tutorials.jenkov.com/java-nio/channel-to-channel-transfers.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-nio/channel-to-channel-transfers.html</a></p>
<p>在Java NIO 中channel之间可以直接相互传输。比如一个FileChannel类型的channel，FileChannel类提供<code>transferTo()</code>和<code>transferFrom()</code>两个方法做这个事情。</p>
<h2 id="transferFrom_28_29"><a href="#transferFrom_28_29" class="headerlink" title="transferFrom()"></a>transferFrom()</h2><p><code>FileChannel.transferFrom()</code>方法将一个channel的数据传入FileChannel。</p>
<p>代码🌰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count    = fromChannel.size();</span><br><span class="line"></span><br><span class="line">toChannel.transferFrom(fromChannel, position, count);</span><br></pre></td></tr></table></figure>
<p>position参数确定目标文件的传输初始位置，count参数确定传输的最大数量。channel中的字节数若是少于count，就读取全部字节。<br>另外，SocketChannel传输的是其内部此时此处的就绪的数据（SocketChannel后续可能还会有更多的可用数据）。因此，从SocketChannel传输数据时，有可能不能把全部的请求数据（不足count的数据）都传入FileChannel中。</p>
<h2 id="transferTo_28_29"><a href="#transferTo_28_29" class="headerlink" title="transferTo()"></a>transferTo()</h2><p><code>transferTo()</code>方法将FileChannel数据传入其他的channel中。</p>
<p>代码🌰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count    = fromChannel.size();</span><br><span class="line"></span><br><span class="line">fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure>
<p>和上面的例子很相似。区别在于调用方法的FileChannel对象不一样。</p>
<p>关于SocketChannel的问题在transferTo()方法中同样存在。SocketChannel会一直传输数据直到目标buffer被填满。</p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/11/10/Java-NIO-Channel-to-Channel-Transfers/" data-id="cj26adtzn003p2suqo46cvmuh" class="article-share-link" data-share="baidu" data-title="Java NIO Channel之间的数据传输">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/11/10/Java-NIO-Channel-to-Channel-Transfers/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-NIO/">Java NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java-NIO-Scatter-Gather" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/09/Java-NIO-Scatter-Gather/" class="article-date">
  <time datetime="2016-11-09T15:09:19.000Z" itemprop="datePublished">2016-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/09/Java-NIO-Scatter-Gather/">Java NIO Scatter / Gather</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>原文：<a href="http://tutorials.jenkov.com/java-nio/scatter-gather.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-nio/scatter-gather.html</a></p>
<p>Java NIO 从一开始就内嵌了scatter/gather的支持。scatter/gather是从channel中读取写入的操作概念。</p>
<p><strong>scatter</strong>：从channel中将数据读到多个buffers中的操作。也就是说，channel的分散器将channel中的数据分散到多个buffers。</p>
<p><strong>gather</strong>：将多个buffers中的数据写入一个channel中的操作。也就是说，channel的收集器，将多个buffers中的数据收集到channel中。</p>
<p>scatter/gatter经常用于需要将传输的数据分开处理的场合。比如，一个信息包含head和body，你可能会将消息体和消息头分散到不同的buffer中，这样你可以方便的处理消息头和消息体。</p>
<h2 id="Scattering_Reads"><a href="#Scattering_Reads" class="headerlink" title="Scattering Reads"></a>Scattering Reads</h2><p>Scattering Reads，将单个channel中的数据读到多个buffers中，下面是原理图示： </p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/java-nio-scatter-read.png" alt="java-nio-scatter-read"></p>
<p>代码🌰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line">channel.read(bufferArray);</span><br></pre></td></tr></table></figure>
<p>注意buffer首先被插入到数组，然后再将数组作为channel.read() 的输入参数。read()方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer，当一个buffer被写满后，channel紧接着向另一个buffer中写。</p>
<p>Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这也意味着它不适用于动态大小消息。换句话说，如果存在消息头和消息体，消息头必须完成填充（例如填满128byte），Scattering Reads才能正常工作。</p>
<h2 id="Gathering_Writes"><a href="#Gathering_Writes" class="headerlink" title="Gathering Writes"></a>Gathering Writes</h2><p>Gathering Writes：将多个buffers中的数据写入单个channel，下面是原理图示：</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/java-nio-gather.png" alt="Gathering Write"></p>
<p>代码🌰：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//write data into buffers</span></span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line"></span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure></p>
<p>The array of buffers are passed into the write() method, which writes the buffers数组是write()方法的入参，write()方法会按照buffer在数组中的顺序，将数据写入到channel，注意只有position和limit之间的数据才会被写入。因此，如果一个buffer的容量为128byte，但是仅仅包含58byte的数据，那么这58byte的数据将被写入到channel中。因此与Scattering Reads相反，Gathering Writes能较好的处理动态消息。</p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/11/09/Java-NIO-Scatter-Gather/" data-id="cj26adtzh003h2suqcjcwi5a9" class="article-share-link" data-share="baidu" data-title="Java NIO Scatter / Gather">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/11/09/Java-NIO-Scatter-Gather/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-NIO/">Java NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-IntelliJ" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/18/IntelliJ/" class="article-date">
  <time datetime="2016-10-18T09:38:43.000Z" itemprop="datePublished">2016-10-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/18/IntelliJ/">IntelliJ 使用说明</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <h3 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h3><p>Windows下载地址：<a href="https://www.jetbrains.com/idea/download/#section=windows" target="_blank" rel="external">https://www.jetbrains.com/idea/download/#section=windows</a></p>
<p>版本选择Ultimate</p>
<p>下载的文件直接双击一路next安装即可。安装结束以后运行起来后，通过Server方式破解</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/%E7%A0%B4%E8%A7%A3.png" alt="破解"></p>
<p><a href="http://idea.iteblog.com/key.php" target="_blank" rel="external">http://idea.iteblog.com/key.php</a></p>
<h3 id="u9879_u76EE_u5F15_u5165"><a href="#u9879_u76EE_u5F15_u5165" class="headerlink" title="项目引入"></a>项目引入</h3><p>破解以后，一路默认启动起来。先创建个Project，Intellij里面的project相当于workplace，可以先建一个空的project的，将项目代码检出到project里面（也可以将原有的项目copy到project文件夹下，如果不想copy，直接import也可以），然后在里面import module</p>
<p>检出代码后的效果：<br><img src="http://7xpk5e.com1.z0.glb.clouddn.com/checkout.png" alt="intellij-checkout"></p>
<p>import后的效果：<br><img src="http://7xpk5e.com1.z0.glb.clouddn.com/import1.png" alt="import1"><br><img src="http://7xpk5e.com1.z0.glb.clouddn.com/import2.png" alt="import2"><br><img src="http://7xpk5e.com1.z0.glb.clouddn.com/import3.png" alt="import3"><br><img src="http://7xpk5e.com1.z0.glb.clouddn.com/import4.png" alt="import4"></p>
<h3 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h3><p>intellij的所有配置信息都在 File-&gt;Settings里面，请自行摸索。</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/settings.png" alt="intellij-settings"></p>
<p>这里说说常用的几个配置在哪里。</p>
<p>1、项目结构</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/structure1.png" alt="structure1"></p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/structure2.png" alt="structure2"><br>这里面可以配置module的语言版本，添加jdk，jar引入等</p>
<p>2、maven</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/maven1.png" alt="maven1"></p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/maven2.png" alt="maven2"></p>
<p>3、Server</p>
<p>以tomcat为例</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/Server1.png" alt="tomcat1"></p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/Server2.png" alt="tomcat2"></p>
<p>配置好Server的基本信息，完成这一步保存，然后添加具体的Server</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/Server3.png" alt="tomcat3"></p>
<p>添加本地Server，Server标签页更改端口等配置信息</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/Server4.png" alt="tomcat4"></p>
<p>Deployment里面部署war包，点击加号，选择</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/Server5.png" alt="tomcat5"></p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/Server6.png" alt="tomcat6"></p>
<h3 id="u5916_u89C2_u5B57_u4F53_u6837_u5F0F_u4FEE_u6539"><a href="#u5916_u89C2_u5B57_u4F53_u6837_u5F0F_u4FEE_u6539" class="headerlink" title="外观字体样式修改"></a>外观字体样式修改</h3><p>通过File-&gt;Import Setting可以直接导入Intellij的配置信息。我这里有个jar包，直接导入即可</p>
<p>jar地址：<a href="https://pan.baidu.com/s/1kU6DxZL" target="_blank" rel="external">https://pan.baidu.com/s/1kU6DxZL</a></p>
<p>导入重启即可，调整了字体大小，文件注释模板，默认UTF-8，使用了sublime类似的主题。</p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/10/18/IntelliJ/" data-id="cj26adu0000492suqga292mea" class="article-share-link" data-share="baidu" data-title="IntelliJ 使用说明">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/10/18/IntelliJ/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IntelliJ/">IntelliJ</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-gitcommands" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/18/gitcommands/" class="article-date">
  <time datetime="2016-10-18T08:38:01.000Z" itemprop="datePublished">2016-10-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/18/gitcommands/">git 常用命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <h3 id="u57FA_u672C_u547D_u4EE4"><a href="#u57FA_u672C_u547D_u4EE4" class="headerlink" title="基本命令"></a>基本命令</h3><p>代码检出：git clone 地址</p>
<p>文件修改添加到暂存区：git add readme.txt </p>
<p>文件提交：git commit -m “备注” </p>
<p>查看工作区当前状态：git status</p>
<p>查看差异：git diff 文件名</p>
<p>查看历史：git log –pretty=oneline</p>
<p>查看历史提交commit id：git log –pretty=oneline –abbrev-commit</p>
<p>恢复当前版本：git reset –hard HEAD</p>
<p>恢复上一个版本：git reset –hard HEAD^<br>（上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100）</p>
<p>恢复指定版本：git reset –hard 3628164</p>
<p>查看命令历史：git reflog</p>
<p>查看工作区和版本库区别：git diff HEAD – readme.txt</p>
<p>撤销修改：git checkout – readme.txt</p>
<p>撤销缓存区文件：git reset HEAD readme.txt</p>
<p>删除文件：git rm test.txt</p>
<h3 id="u5206_u652F_u547D_u4EE4"><a href="#u5206_u652F_u547D_u4EE4" class="headerlink" title="分支命令"></a>分支命令</h3><p>查看分支：git branch</p>
<p>创建分支：git branch <name></name></p>
<p>切换分支：git checkout <name></name></p>
<p>创建+切换分支：git checkout -b <name></name></p>
<p>推送远程分支：git push origin <name></name></p>
<p>创建远程分支：git checkout -b dev origin/dev</p>
<p>git checkout -b paytest_20151202_online origin/paytest_20151202_online</p>
<p>合并某分支到当前分支：git merge <name></name></p>
<p>合并分支禁用Fast forward：git merge –no-ff -m “备注” dev</p>
<p>删除分支：git branch -d <name></name></p>
<p>删除远程分支：git push origin –delete <branchname></branchname></p>
<p>强制删除分支：git branch -D <name></name></p>
<p>查看分支历史：git log –graph –pretty=oneline –abbrev-commit</p>
<p>分支合并图：git log –graph</p>
<p>储藏工作区：git stash</p>
<p>查看储藏的工作区：git stash list</p>
<p>恢复并删除储藏工作区：git stash pop</p>
<p>恢复指定工作区：git stash apply stash@{0}</p>
<p>恢复储藏工作区：git stash apply</p>
<p>删除储藏工作区：git stash drop</p>
<p>查询远程库详细信息：git remote -v</p>
<p>推送分支：git push origin dev</p>
<p>抓取最新文件：git pull 分支名</p>
<p>取远程分支：git pull origin 分支名</p>
<p>指定分支与远程分支链接：git branch –set-upstream dev origin/dev</p>
<h3 id="u6807_u7B7E_u547D_u4EE4"><a href="#u6807_u7B7E_u547D_u4EE4" class="headerlink" title="标签命令"></a>标签命令</h3><p>创建标签：git tag v1.0</p>
<p>删除本地标签：git tag -d v0.1</p>
<p>删除远程标签：git push origin :refs/tags0.9</p>
<p>删除远程标签：git push origin –delete tag <tagname></tagname></p>
<p>查看标签：git tag</p>
<p>指定commit id创建标签：git tag v0.9 6224937</p>
<p>指定标签信息：git tag -a <tagname> -m “blablabla…”</tagname></p>
<p>可以用PGP签名标签：git tag -s <tagname> -m “blablabla…”</tagname></p>
<p>查看标签信息：git show 标签名</p>
<p>推送标签到远程：git push origin v1.0</p>
<p>推送所有标签到远程：git push origin –tags</p>
<h3 id="u5176_u4ED6"><a href="#u5176_u4ED6" class="headerlink" title="其他"></a>其他</h3><p>配置别名：git config –global alias.st status</p>
<p>在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<p>撤銷git add . =&gt; git rm -r –cached .</p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/10/18/gitcommands/" data-id="cj26adtx9000l2suqb8wi8nuu" class="article-share-link" data-share="baidu" data-title="git 常用命令">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/10/18/gitcommands/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/">git</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-docker-jenkins" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/17/docker-jenkins/" class="article-date">
  <time datetime="2016-10-17T08:44:51.000Z" itemprop="datePublished">2016-10-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/17/docker-jenkins/">java应用结合Jenkins，docker部署到Kubernetes</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Jenkins_u5B89_u88C5"><a href="#Jenkins_u5B89_u88C5" class="headerlink" title="Jenkins安装"></a>Jenkins安装</h3><p>1、下载Jenkins war包安装，下载地址 <a href="/jenkins.io">jenkins.io</a>。这里使用的是Jenkins2.24版本</p>
<p>2、启动Jenkins</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JENKINS_HOME=~/.jenkins java -jar ~/Downloads/jenkins-<span class="number">2.24</span>.war --httpPort=<span class="number">9090</span></span><br></pre></td></tr></table></figure>
<p>启动后，日志会提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*************************************************************&#10;*************************************************************&#10;*************************************************************&#10; &#10;Jenkins initial setup is required. An admin user has been created and a password generated.&#10;Please use the following password to proceed to installation:&#10; &#10;3521fbc3d40448efa8942f8e464b2dd9&#10; &#10;This may also be found at: /Users/arungupta/.jenkins/secrets/initialAdminPassword&#10; &#10;*************************************************************&#10;*************************************************************&#10;*************************************************************</span><br></pre></td></tr></table></figure></p>
<p>访问localhost:9090，输入上面提示的密码，然后根据提示，安装推荐的插件，并创建用户</p>
        
          <p class="article-more-link">
            <a href="/2016/10/17/docker-jenkins/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/10/17/docker-jenkins/" data-id="cj26adtxm00182suqcixoejaf" class="article-share-link" data-share="baidu" data-title="java应用结合Jenkins，docker部署到Kubernetes">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/10/17/docker-jenkins/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/K8s/">K8s</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-dockerjavamicroservice4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/27/dockerjavamicroservice4/" class="article-date">
  <time datetime="2016-09-27T02:52:03.000Z" itemprop="datePublished">2016-09-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/27/dockerjavamicroservice4/">使用kubeadm在CentOS7上安装Kubernetes集群</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>Kubernetes1.4版本提供kubeadm命令进行简化k8s集群的安装，只要使用2个简单命令就可以完成安装。 安装kubernetes以后，使用<code>kubeadm init</code>启动master，使用<code>kubeadm joins</code>把node添加到集群里。下面是根据官方博客<a href="http://kubernetes.io/docs/getting-started-guides/kubeadm/" target="_blank" rel="external">Installing Kubernetes on Linux with kubeadm</a>练习的记录。</p>
<h4 id="u4F7F_u7528vagrant_u521B_u5EFA_u4E24_u4E2Acentos7"><a href="#u4F7F_u7528vagrant_u521B_u5EFA_u4E24_u4E2Acentos7" class="headerlink" title="使用vagrant创建两个centos7"></a>使用vagrant创建两个centos7</h4><p>在k8s-centos7-cluster文件夹下创建Vagrantfile文件。Vagrantfile配置如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- mode: ruby -*-</span></span><br><span class="line"><span class="comment"># vi: set ft=ruby :</span></span><br><span class="line"></span><br><span class="line">boxes = [</span><br><span class="line">  &#123; <span class="symbol">:name</span> =&gt; <span class="symbol">:master</span>,<span class="symbol">:ip</span> =&gt; <span class="string">'192.168.1.20'</span>,<span class="symbol">:forward</span> =&gt; <span class="number">80</span>,<span class="symbol">:cpus</span> =&gt; <span class="number">1</span>,<span class="symbol">:mem</span> =&gt; <span class="number">1024</span>&#125;,</span><br><span class="line">  &#123; <span class="symbol">:name</span> =&gt; <span class="symbol">:node1</span>,<span class="symbol">:ip</span> =&gt; <span class="string">'192.168.1.21'</span>,<span class="symbol">:forward</span> =&gt; <span class="number">80</span>,<span class="symbol">:cpus</span> =&gt; <span class="number">1</span>,<span class="symbol">:mem</span> =&gt; <span class="number">1024</span>&#125;,</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="constant">VAGRANTFILE_API_VERSION</span> = <span class="string">"2"</span></span><br><span class="line"></span><br><span class="line"><span class="constant">Vagrant</span>.configure(<span class="constant">VAGRANTFILE_API_VERSION</span>) <span class="keyword">do</span> |config|</span><br><span class="line">    boxes.each <span class="keyword">do</span> |opts|</span><br><span class="line">        config.vm.define opts[<span class="symbol">:name</span>] <span class="keyword">do</span> |config|</span><br><span class="line">            config.vm.box       = <span class="string">"centos7"</span></span><br><span class="line">            config.vm.boot_timeout = <span class="number">360</span></span><br><span class="line">            config.ssh.username = <span class="string">"vagrant"</span></span><br><span class="line">            config.ssh.password = <span class="string">"vagrant"</span></span><br><span class="line">            config.vm.synced_folder <span class="string">"."</span>, <span class="string">"/vagrant"</span>, <span class="symbol">disabled:</span><span class="keyword">true</span></span><br><span class="line">            config.vm.network  <span class="string">"public_network"</span>, <span class="symbol">ip:</span> opts[<span class="symbol">:ip</span>]</span><br><span class="line">            <span class="comment">#config.vm.network "forwarded_port", guest: 80, host: 8080</span></span><br><span class="line">            config.vm.hostname = <span class="string">"%s.vagrant"</span> % opts[<span class="symbol">:name</span>].to_s</span><br><span class="line">            config.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> |vb|</span><br><span class="line">                vb.customize [<span class="string">"modifyvm"</span>, <span class="symbol">:id</span>, <span class="string">"--cpus"</span>, opts[<span class="symbol">:cpus</span>] ] <span class="keyword">if</span> opts[<span class="symbol">:cpus</span>]</span><br><span class="line">                vb.customize [<span class="string">"modifyvm"</span>, <span class="symbol">:id</span>, <span class="string">"--memory"</span>, opts[<span class="symbol">:mem</span>] ] <span class="keyword">if</span> opts[<span class="symbol">:mem</span>]</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">#config.vm.provision "shell", inline: $update_script</span></span><br><span class="line">            <span class="comment">#config.vm.provision "shell", path: opts[:provision] if opts[:provision]</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>在Vagrantfile文件目录下，创建两个CentOS7系统，一个作为master，一个作为node<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  k8s-centos7-cluster vagrant up</span><br><span class="line">Bringing machine <span class="string">'master'</span> up with <span class="string">'virtualbox'</span> provider...</span><br><span class="line">Bringing machine <span class="string">'node1'</span> up with <span class="string">'virtualbox'</span> provider...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>Ok，下面我们开始在CentOS7中安装k8s集群</p>
<h4 id="u5B89_u88C5kubelet_u548Ckuebadm"><a href="#u5B89_u88C5kubelet_u548Ckuebadm" class="headerlink" title="安装kubelet和kuebadm"></a>安装kubelet和kuebadm</h4><p>在所有的机子上都必须安装docker，kubelet，kubectl，kubeadm，无论是master还是node。并且使用root权限进行安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  k8s-centos7-cluster vagrant ssh master <span class="comment">#输入密码登录master</span></span><br><span class="line">[vagrant@master ~]$ </span><br><span class="line">[vagrant@master ~]$ sudo su -</span><br></pre></td></tr></table></figure>
<p>登录master，切换到root用户，然后执行下面的命令:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cat &#60;&#60;EOF &#62; /etc/yum.repos.d/k8s.repo&#10;[kubelet]&#10;name=kubelet&#10;baseurl=http://files.rm-rf.ca/rpms/kubelet/&#10;enabled=1&#10;gpgcheck=0&#10;EOF&#10;# yum install docker kubelet kubeadm kubectl kubernetes-cni&#10;# systemctl enable docker &#38;&#38; systemctl start docker&#10;# systemctl enable kubelet &#38;&#38; systemctl start kubelet</span><br></pre></td></tr></table></figure>
<p>等待下载后安装。<br>安装完成后，可以使用<code>systemctl status</code> 查看安装好的组件服务状态。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># systemctl status docker</span></span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Tue <span class="number">2016</span>-<span class="number">09</span>-<span class="number">27</span> <span class="number">04</span>:<span class="number">57</span>:<span class="number">44</span> UTC; <span class="number">41</span>s ago</span><br></pre></td></tr></table></figure>
<h4 id="u521D_u59CB_u5316master"><a href="#u521D_u59CB_u5316master" class="headerlink" title="初始化master"></a>初始化master</h4><p>在master上运行控制组件，包含etcd（集群的数据库），API server（kubectl 客户端沟通用）。这些组件都在pod中通过kubelet启动运行。<br>初始化master，选择上面实现安装过kubelet和kubeadm的主机，然后运行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># kubeadm init --use-kubernetes-version v1.4.0-beta.11</span></span><br></pre></td></tr></table></figure>
<p>运行后，会下载安装集群用的数据库和控制组件，需要等待一些时间，输出内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;master/tokens&gt; generated token: <span class="string">"88958f.2068ff49c1675f8c"</span></span><br><span class="line">&lt;master/pki&gt; created keys and certificates <span class="keyword">in</span> <span class="string">"/etc/kubernetes/pki"</span></span><br><span class="line">&lt;util/kubeconfig&gt; created <span class="string">"/etc/kubernetes/kubelet.conf"</span></span><br><span class="line">&lt;util/kubeconfig&gt; created <span class="string">"/etc/kubernetes/admin.conf"</span></span><br><span class="line">&lt;master/apiclient&gt; created API client configuration</span><br><span class="line">&lt;master/apiclient&gt; created API client, waiting <span class="keyword">for</span> the control plane to become ready</span><br></pre></td></tr></table></figure>
<p>未完待续。。。</p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/09/27/dockerjavamicroservice4/" data-id="cj26adtxd000r2suqb0ujxet7" class="article-share-link" data-share="baidu" data-title="使用kubeadm在CentOS7上安装Kubernetes集群">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/09/27/dockerjavamicroservice4/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/K8s/">K8s</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-dockerjavamicroservice3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/26/dockerjavamicroservice3/" class="article-date">
  <time datetime="2016-09-26T09:14:49.000Z" itemprop="datePublished">2016-09-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/26/dockerjavamicroservice3/">基于Docker的java微服务(三) Kubernetes服务发现之环境变量</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <ol>
<li>创建两个服务</li>
<li>将服务打包成镜像</li>
<li>k8s的service</li>
<li>k8s的deployment</li>
<li>简单测试</li>
</ol>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/09/26/dockerjavamicroservice3/" data-id="cj26adtxf000v2suqd23t81z9" class="article-share-link" data-share="baidu" data-title="基于Docker的java微服务(三) Kubernetes服务发现之环境变量">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/09/26/dockerjavamicroservice3/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/K8s/">K8s</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-dockerjavamicroservice2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/07/dockerjavamicroservice2/" class="article-date">
  <time datetime="2016-09-07T11:23:15.000Z" itemprop="datePublished">2016-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/07/dockerjavamicroservice2/">基于Docker的java微服务(二) CentOS7部署Kubernetes集群</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>本文主要参考美团云的<a href="https://mos.meituan.com/library/37/how-to-setup-k8s-cluster-on-CentOS7/" target="_blank" rel="external">在CentOS7上部署Kubernetes集群</a></p>
<h3 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h3><p>Kubernetes(k8s)是Google开源的大规模容器集群管理系统, 本文将基于CentOS7自带的Kubernetes组件、分布式键值存储系统etcd以及Flannel实现的overlay网络来搭建一个简单的k8s集群。</p>
<h3 id="vagrant_u5B89_u88C5_u591A_u53F0CentOS7"><a href="#vagrant_u5B89_u88C5_u591A_u53F0CentOS7" class="headerlink" title="vagrant安装多台CentOS7"></a>vagrant安装多台CentOS7</h3><p>使用vagrant创建多个CentOS7虚拟机用于集群部署。vagrant的安装非常简单,网上一大堆教程，可以参考<a href="http://www.tuicool.com/articles/miE7vm6" target="_blank" rel="external">这里</a>。我使用的是1.8.5版本。同时还需要下载CentOS的box文件,<br>由于box文件都在国外的网站上下载速度缓慢,可以从我的云盘上下载<a href="https://pan.baidu.com/s/1jI6T4EE" target="_blank" rel="external">CentOS-7-x86_64-Minimal-1511.box</a>。<br>有了box文件后,执行以下命令添加box</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant add box CentOS-<span class="number">7</span>-x86_64-Minimal-<span class="number">1511</span>.box</span><br></pre></td></tr></table></figure>
<p>查看vagrant已添加的box</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant box list</span><br></pre></td></tr></table></figure>
<p>创建单台CentOS很简单，需要下面的步骤</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkidr centos7</span><br><span class="line"><span class="built_in">cd</span> centos7</span><br><span class="line">vagrant init</span><br><span class="line">vagrant up</span><br></pre></td></tr></table></figure>
<p>vagrant init会初始化一个Vagrantfile的文件，CentOS的配置都是这个文件设定的。这里给出创建多台centos的Vagrantfile配置。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- mode: ruby -*-</span></span><br><span class="line"><span class="comment"># vi: set ft=ruby :</span></span><br><span class="line"></span><br><span class="line">boxes = [</span><br><span class="line">  &#123; <span class="symbol">:name</span> =&gt; <span class="symbol">:master</span>,<span class="symbol">:ip</span> =&gt; <span class="string">'192.168.253.7'</span>,<span class="symbol">:cpus</span> =&gt; <span class="number">1</span>,<span class="symbol">:mem</span> =&gt; <span class="number">1024</span>&#125;,</span><br><span class="line">  &#123; <span class="symbol">:name</span> =&gt; <span class="symbol">:worker1</span>,<span class="symbol">:ip</span> =&gt; <span class="string">'192.168.253.8'</span>,<span class="symbol">:cpus</span> =&gt; <span class="number">1</span>,<span class="symbol">:mem</span> =&gt; <span class="number">1024</span>&#125;,</span><br><span class="line">  &#123; <span class="symbol">:name</span> =&gt; <span class="symbol">:worker2</span>,<span class="symbol">:ip</span> =&gt; <span class="string">'192.168.253.9'</span>,<span class="symbol">:cpus</span> =&gt; <span class="number">1</span>,<span class="symbol">:mem</span> =&gt; <span class="number">1024</span>&#125;,</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="constant">VAGRANTFILE_API_VERSION</span> = <span class="string">"2"</span></span><br><span class="line"></span><br><span class="line"><span class="constant">Vagrant</span>.configure(<span class="constant">VAGRANTFILE_API_VERSION</span>) <span class="keyword">do</span> |config|</span><br><span class="line">    boxes.each <span class="keyword">do</span> |opts|</span><br><span class="line">        config.vm.define opts[<span class="symbol">:name</span>] <span class="keyword">do</span> |config|</span><br><span class="line">            config.vm.box       = <span class="string">"centos7"</span></span><br><span class="line">            config.vm.boot_timeout = <span class="number">360</span></span><br><span class="line">            config.ssh.username = <span class="string">"vagrant"</span></span><br><span class="line">            config.ssh.password = <span class="string">"vagrant"</span></span><br><span class="line">            config.vm.synced_folder <span class="string">"."</span>, <span class="string">"/vagrant"</span>, <span class="symbol">disabled:</span><span class="keyword">true</span></span><br><span class="line">            config.vm.network  <span class="string">"public_network"</span>, <span class="symbol">ip:</span> opts[<span class="symbol">:ip</span>]</span><br><span class="line">            config.vm.hostname = <span class="string">"%s.vagrant"</span> % opts[<span class="symbol">:name</span>].to_s</span><br><span class="line">            config.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> |vb|</span><br><span class="line">                vb.customize [<span class="string">"modifyvm"</span>, <span class="symbol">:id</span>, <span class="string">"--cpus"</span>, opts[<span class="symbol">:cpus</span>] ] <span class="keyword">if</span> opts[<span class="symbol">:cpus</span>]</span><br><span class="line">                vb.customize [<span class="string">"modifyvm"</span>, <span class="symbol">:id</span>, <span class="string">"--memory"</span>, opts[<span class="symbol">:mem</span>] ] <span class="keyword">if</span> opts[<span class="symbol">:mem</span>]</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">#config.vm.provision "shell", inline: $update_script</span></span><br><span class="line">            <span class="comment">#config.vm.provision "shell", path: opts[:provision] if opts[:provision]</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在这个文件的目录下执行<code>vagrant up</code>就可以创建3台虚拟机。我们把其中master作为k8s的Master节点，worker1，worker2作为k8s的Node节点来创建k8s集群。</p>
<h3 id="u73AF_u5883_u51C6_u5907"><a href="#u73AF_u5883_u51C6_u5907" class="headerlink" title="环境准备"></a>环境准备</h3><table>
<thead>
<tr>
<th>master</th>
<th style="text-align:center">worker1</th>
<th style="text-align:center">worker2</th>
</tr>
</thead>
<tbody>
<tr>
<td>192.168.253.7</td>
<td style="text-align:center">192.168.253.8</td>
<td style="text-align:center">192.168.253.9</td>
</tr>
<tr>
<td>kubernetes</td>
<td style="text-align:center">ntpd</td>
<td style="text-align:center">ntpd</td>
</tr>
<tr>
<td>etcd</td>
<td style="text-align:center">flannel</td>
<td style="text-align:center">flannel</td>
</tr>
<tr>
<td>ntpd</td>
<td style="text-align:center">kubernetes</td>
<td style="text-align:center">kubernetes</td>
</tr>
</tbody>
</table>
<p>Master节点禁用CentOS7自带防火墙，安装kubernetes、etcd、ntpd等软件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop firewalld &amp;&amp; sudo systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line">sudo yum install -y kubernetes etcd ntp.x86_64</span><br></pre></td></tr></table></figure>
<p>Node节点同样禁用CentOS7自带防火墙，安装kubernetes、flannel、ntpd等软件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop firewalld &amp;&amp; sudo systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line">sudo yum install -y ntp.x86_64 flannel kubernetes</span><br></pre></td></tr></table></figure>
<h3 id="Master_u914D_u7F6E"><a href="#Master_u914D_u7F6E" class="headerlink" title="Master配置"></a>Master配置</h3><p>修改etcd配置<code>/etc/etcd/etcd.conf</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETCD_LISTEN_CLIENT_URLS=<span class="string">"http://0.0.0.0:2379"</span></span><br></pre></td></tr></table></figure>
<p>修改kubernetes全局配置<code>/etc/kubernetes/config</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KUBE_LOG_LEVEL=<span class="string">"--v=2"</span></span><br></pre></td></tr></table></figure>
<p>修改kubernetes apiserver的配置<code>/etc/kubernetes/apiserver</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KUBE_API_ADDRESS=<span class="string">"--address=0.0.0.0"</span></span><br><span class="line">KUBE_API_PORT=<span class="string">"--port=8080"</span></span><br><span class="line">KUBELET_PORT=<span class="string">"--kubelet_port=10250"</span></span><br></pre></td></tr></table></figure>
<p>启动master的ntpd、etcd、kube-apiserver、kube-scheduler、kube-controller-manager服务，设置为开机启动，并查看启动后的状态。如果每一个服务都启动成功，那么sudo systemctl status $SRV显示的信息则包含Active: active (running)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> SRV <span class="keyword">in</span> ntpd etcd kube-apiserver kube-scheduler kube-controller-manager;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    sudo systemctl start <span class="variable">$SRV</span></span><br><span class="line">    sudo systemctl <span class="built_in">enable</span> <span class="variable">$SRV</span></span><br><span class="line">    sudo systemctl status <span class="variable">$SRV</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>修改etcd配置，在设定Node中flannel所使用的子网范围为172.17.1.0~172.17.254.0（每一个Node节点都有一个独立的flannel子网）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl mk /coreos.com/network/config <span class="string">'&#123;"Network":"172.17.0.0/16", "SubnetMin": "172.17.1.0", "SubnetMax": "172.17.254.0"&#125;'</span></span><br></pre></td></tr></table></figure>
<h3 id="Node_u914D_u7F6E"><a href="#Node_u914D_u7F6E" class="headerlink" title="Node配置"></a>Node配置</h3><p>修改Node节点上flannel的配置<code>/etc/sysconfig/</code>flanneld，设定etcd的相关信息，其中192.168.253.7为Master的IP地址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLANNEL_ETCD=<span class="string">"http://192.168.253.7:2379"</span></span><br></pre></td></tr></table></figure>
<p>修改Node节点kubernetes的全局配置文件<code>/etc/kubernetes/config</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KUBE_LOG_LEVEL=<span class="string">"--v=2"</span></span><br><span class="line">KUBE_MASTER=<span class="string">"--master=http://192.168.253.7:8080"</span></span><br></pre></td></tr></table></figure>
<p>修改Node节点上kubernetes kubelet的配置<code>/etc/kubernetes/kubelet</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KUBELET_ADDRESS=<span class="string">"--address=0.0.0.0"</span></span><br><span class="line">KUBELET_PORT=<span class="string">"--port=10250"</span></span><br><span class="line">KUBELET_API_SERVER=<span class="string">"--api_servers=http://192.168.253.7:8080"</span></span><br><span class="line">KUBELET_HOSTNAME=<span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>启动Node节点上的相关服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> SRV <span class="keyword">in</span> ntpd flanneld docker kube-proxy kubelet;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    sudo systemctl start <span class="variable">$SRV</span></span><br><span class="line">    sudo systemctl <span class="built_in">enable</span> <span class="variable">$SRV</span></span><br><span class="line">    sudo systemctl status <span class="variable">$SRV</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>类似Master节点，如果每一个服务都启动成功，那么sudo systemctl status $SRV显示的信息则包含Active: active (running)。</p>
<p>配置步骤都是参考<a href="https://mos.meituan.com/library/37/how-to-setup-k8s-cluster-on-CentOS7/" target="_blank" rel="external">美团云在CentOS7上部署Kubernetes集群</a>。<br>不巧的是，我在这一步上花了1周的时间。。。。Node节点上的flanneld和docker服务死活起不起来。<br>通过<code>systemctl status flanneld</code>，发现一直报错<code>Failed to retrieve network config</code>。</p>
<p><strong>解决方法</strong>：</p>
<p>修改Node节点上的flanneld配置 <code>/etc/sysconfig/flanneld</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLANNEL_ETCD_KEY=<span class="string">"/coreos.com/network"</span></span><br></pre></td></tr></table></figure>
<p>然后重新启动flanneld和docker服务即可。</p>
<h3 id="u6D4B_u8BD5"><a href="#u6D4B_u8BD5" class="headerlink" title="测试"></a>测试</h3><p>在Master上查看节点信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@master ~]$ kubectl get nodes</span><br><span class="line">NAME              STATUS    AGE</span><br><span class="line">worker1.vagrant   Ready     <span class="number">4</span>m</span><br><span class="line">worker2.vagrant   Ready     <span class="number">10</span>s</span><br></pre></td></tr></table></figure>
<p>在Master节点查看flannel子网分配情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@master ~]$ etcdctl ls /coreos.com/network/subnets</span><br><span class="line">/coreos.com/network/subnets/<span class="number">172.17</span>.<span class="number">29.0</span>-<span class="number">24</span></span><br></pre></td></tr></table></figure>
<h3 id="Guestbook_u90E8_u7F72_u5230k8s_u4E2D"><a href="#Guestbook_u90E8_u7F72_u5230k8s_u4E2D" class="headerlink" title="Guestbook部署到k8s中"></a>Guestbook部署到k8s中</h3><p><a href="https://github.com/kubernetes/kubernetes/blob/release-1.2/examples/guestbook/README.md" target="_blank" rel="external">Guestbook example</a></p>
<p>部署的过程中遇到2个问题</p>
<ol>
<li><p>通过<code>kubectl create -f xxx.yaml</code>创建pod显示成功，但是通过 <code>kubectl get pod</code>命令确查询不到任何pod信息。解决方案可以参考：<a href="http://www.voidcn.com/blog/jinzhencs/article/p-5975011.html" target="_blank" rel="external"> kubenetes无法创建pod/创建RC时无法自动创建pod的问题</a></p>
</li>
<li><p>解决了上面的问题后，可以get到pod信息，但是node节点通过查询docker images并未发现任何镜像，原因是因为国内的网络问题，无法下载到镜像所致。可以手动pull<br>镜像：<code>registry.access.redhat.com/rhel7/pod-infrastructure</code>以及你所需的其他镜像。</p>
</li>
</ol>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>这里的集群部署参考的是美团云分享的。都只是练手用的。</p>
<p>k8s部署还可以更简单，一键部署。使用vagrant+coreOs，安装完虚拟机后，Master节点c1会自动下在k8s所需的环境，奈何大陆的程序员比较苦逼，有墙的存在。在翻墙的情况下可以尝试一键部署k8s集群。详情请移步<a href="https://coreos.com/kubernetes/docs/latest/kubernetes-on-vagrant.html" target="_blank" rel="external">要翻才能看的到</a>。</p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/09/07/dockerjavamicroservice2/" data-id="cj26adtxh000y2suqw460io50" class="article-share-link" data-share="baidu" data-title="基于Docker的java微服务(二) CentOS7部署Kubernetes集群">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/09/07/dockerjavamicroservice2/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/K8s/">K8s</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-dockerjavamicroservice1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/24/dockerjavamicroservice1/" class="article-date">
  <time datetime="2016-08-24T11:23:15.000Z" itemprop="datePublished">2016-08-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/24/dockerjavamicroservice1/">基于Docker的java微服务(一) 部署Chris Richardson的转账案例</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <h3 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h3><p>本文主要参考<a href="http://www.infoq.com/cn/articles/Automate-Docker-Cloud-Java-Microservice-Deployment-with-DCHQ" target="_blank" rel="external">使用DCHQ自动部署和管理基于Docker的云/虚拟化环境Java微服务</a></p>
<p>最近在学习微服务,前两周了解基于Spring Cloud的微服务框架,这两天开始看看关于Docker的微服务。</p>
<p>Spring Cloud整合了Netflix开源的Eureka,Hystrix,Ribbon,Feign,ZUUL等,<br>是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、<br>分布式会话和集群状态管理等操作提供了一种简单的开发方式(<a href="http://blog.didispace.com/springcloud1/" target="_blank" rel="external">参考DIDI</a>)。</p>
<p>那么Docker的微服务是什么样的呢。有空的同学可以看看Spring Cloud和Docker的比较<br><a href="http://www.infoq.com/cn/articles/netflix-oss-spring-cloud-kubernetes?utm_campaign=rightbar_v2&amp;utm_source=infoq&amp;utm_medium=articles_link&amp;utm_content=link_text" target="_blank" rel="external">Netflix OSS、Spring Cloud还是Kubernetes?</a>。<br>简单的说,就是基于Docker的调度器Kubernetes可以帮忙把大家从服务发现、负载均衡、容错等功能中解放出来,更专注于业务逻辑开发。</p>
<p>Kubernetes是个什么鬼?要了解它,我们得先了解下,我们开发好的项目是怎么在Docker上部署应用的,多个Docker容器又是如何管理的。<br>这篇文章是Chris Richardson针对事件溯源、CQRS和Docker所创建的转账<a href="https://github.com/cer/event-sourcing-examples" target="_blank" rel="external">案例</a>。</p>
<p>案例主要功能如下:</p>
<ul>
<li>基于一个初始的余额，创建新账户</li>
<li>查询某个账户，得到其余额</li>
<li>从一个账户到另一个账户进行转账</li>
</ul>
<p>我们就用这个例子,来了解下整个开发部署流程(<strong>仅仅是了解</strong>)。案例的具体业务逻辑介绍请移步<a href="https://github.com/cer/event-sourcing-examples" target="_blank" rel="external">event-sourcing-examples</a></p>
<h3 id="u83B7_u53D6Event_Store_u51ED_u8BC1"><a href="#u83B7_u53D6Event_Store_u51ED_u8BC1" class="headerlink" title="获取Event Store凭证"></a>获取Event Store凭证</h3><p>架构使用事件驱动的方式来确保数据的一致性,这里面使用的是Event Store。</p>
<p>在使用之前,需要获取Event Store凭证。<br>进入<a href="http://eventuate.io/" target="_blank" rel="external">Event Store</a>官网,注册个账号,过几个小时一般就会收到来自<a href="/chris@chrisrichardson.net">chris</a>的邮件。<br>邮件中有EVENTUATE_API_KEY_ID和EVENTUATE_API_KEY_SECRET,这个在后面的yml模板里会用到。</p>
<h3 id="gradle_u6784_u5EFA"><a href="#gradle_u6784_u5EFA" class="headerlink" title="gradle构建"></a>gradle构建</h3><p>从<a href="https://github.com/cer/event-sourcing-examples" target="_blank" rel="external">event-sourcing-examples</a>clone项目到本地。</p>
<p>直接下载下来的例子，部署测试的时候，会报几个错误，需要对代码做部分修改</p>
<ul>
<li>修改 xx-xx-side-service模块中build.gradle文件,添加如下内容<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes <span class="string">'Main-Class'</span>: <span class="string">'net.chrisrichardson.eventstore.javaexamples.banking.web.main.XxxxSideServiceMain'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>添加这个解决部署时遇到的找不到manifest错误</p>
<ul>
<li>xx-xx-side-service主方法添加注解@SpringBootApplication</li>
</ul>
<p>主方法没有@SpringBootApplication这个注解，是无法启动spring boot滴。</p>
<p>修改后，使用gradle的assemble命令构建，构建成功后，模块的/build/libs会生成jar包。</p>
<h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h3><p>gradle构建完毕后，我们要把service模块的jar包放到一个docker镜像中，然后启动这个docker。<br>这里使用了docker-compose来生成启动镜像。</p>
<p>docker-compose的安装及介绍，请移步：<a href="https://yeasy.gitbooks.io/docker_practice/content/compose/" target="_blank" rel="external">Docker Compose 项目</a></p>
<h4 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h4><p>docker-compose管理调度docker容器默认是根据docker-compose.yml模板进行的。这个模板里定义了生成镜像部署镜像的一些步骤。</p>
<p>本案例的yml如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accountscommandside:&#10;  image: openjdk:8u92-jdk-alpine&#10;  working_dir: /app&#10;  volumes:&#10;    - ./accounts-command-side-service/build/libs:/app&#10;  command: java -jar /app/accounts-command-side-service.jar&#10;  ports:&#10;    - &#34;8080:8080&#34;&#10;  environment:&#10;    EVENTUATE_API_KEY_ID: 5NJSVTRJ6UTYVL8U4RN8TKDRM&#10;    EVENTUATE_API_KEY_SECRET: fiAKWYEEj7EVxNi6yKXF8WDcVLbYA8Cu5RnFFKjwVOw&#10;&#10;transactionscommandside:&#10;  image: openjdk:8u92-jdk-alpine&#10;  working_dir: /app&#10;  volumes:&#10;    - ./transactions-command-side-service/build/libs:/app&#10;  command: java -jar /app/transactions-command-side-service.jar&#10;  ports:&#10;    - &#34;8082:8080&#34;&#10;  environment:&#10;    EVENTUATE_API_KEY_ID: 5NJSVTRJ6UTYVL8U4RN8TKDRM&#10;    EVENTUATE_API_KEY_SECRET: fiAKWYEEj7EVxNi6yKXF8WDcVLbYA8Cu5RnFFKjwVOw&#10;&#10;&#10;accountsqueryside:&#10;  image: openjdk:8u92-jdk-alpine&#10;  working_dir: /app&#10;  volumes:&#10;    - ./accounts-query-side-service/build/libs:/app&#10;  command: java -jar /app/accounts-query-side-service.jar&#10;  ports:&#10;    - &#34;8081:8080&#34;&#10;  links:&#10;    - mongodb&#10;  environment:&#10;    EVENTUATE_API_KEY_ID: 5NJSVTRJ6UTYVL8U4RN8TKDRM&#10;    EVENTUATE_API_KEY_SECRET: fiAKWYEEj7EVxNi6yKXF8WDcVLbYA8Cu5RnFFKjwVOw&#10;    SPRING_DATA_MONGODB_URI: mongodb://mongodb/mydb&#10;&#10;mongodb:&#10;  image: mongo:3.2.9&#10;  hostname: mongodb&#10;  command: mongod --smallfiles&#10;  ports:&#10;    - &#34;27017:27017&#34;</span><br></pre></td></tr></table></figure>
<p>这里面定义了4个容器内容，分别是accountscommandside，transactionscommandside，accountsqueryside，mongodb</p>
<ul>
<li>image：指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像</li>
<li>volumes：卷挂载路径设置，这里是将容器的/app路径挂载到宿主机/build/libs 路径上</li>
<li>command：覆盖容器启动后默认执行的命令，这里是默认直接启动spring boot项目</li>
<li>ports：暴露端口信息，格式如下<ul>
<li>宿主：容器 （HOST:CONTAINER）</li>
<li>容器（宿主会随机选择端口）</li>
</ul>
</li>
<li>links：链接到其它服务中的容器。使用服务名称（同时作为别名）或服务名称：服务别名 （SERVICE:ALIAS）格式都可以。 <ul>
<li>db</li>
<li>db:database</li>
<li>redis</li>
</ul>
</li>
<li>environment：设置环境变量</li>
</ul>
<p>替换成你自己的EVENTUATE_API_KEY_ID和EVENTUATE_API_KEY_SECRET，否则部署后运行测试，会报401未授权错误。</p>
<h4 id="docker-compse_up"><a href="#docker-compse_up" class="headerlink" title="docker-compse up"></a>docker-compse up</h4><p>设置好yml模板以后，使用docker-compse up来启动这4个容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  java-spring git:(master) ✗ docker-compose up</span><br></pre></td></tr></table></figure>
<p>再开个shell，看下启动的四个容器的状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  java-spring git:(master) ✗ docker-compose ps</span><br><span class="line">                Name                              Command               State            Ports</span><br><span class="line">--------------------------------------------------------------------------------------------------------</span><br><span class="line">javaspring_accountscommandside_1       java -jar /app/accounts-co ...   Up      <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">8080</span>-&gt;<span class="number">8080</span>/tcp</span><br><span class="line">javaspring_accountsqueryside_1         java -jar /app/accounts-qu ...   Up      <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">8081</span>-&gt;<span class="number">8080</span>/tcp</span><br><span class="line">javaspring_mongodb_1                   /entrypoint.sh mongod --sm ...   Up      <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">27017</span>-&gt;<span class="number">27017</span>/tcp</span><br><span class="line">javaspring_transactionscommandside_1   java -jar /app/transaction ...   Up      <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">8082</span>-&gt;<span class="number">8080</span>/tcp</span><br></pre></td></tr></table></figure>
<p>四个状态都是up，好了，访问服务测试下。</p>
<h3 id="u6D4B_u8BD5"><a href="#u6D4B_u8BD5" class="headerlink" title="测试"></a>测试</h3><p>先创建2个账户，每个都初始500美元<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  java-spring git:(master) ✗ curl -X POST -H <span class="string">"Content-Type: application/json"</span> -H <span class="string">"Cache-Control: no-cache"</span> <span class="operator">-d</span> <span class="string">'&#123;"initialBalance": 500&#125;'</span> <span class="string">"http://localhost:8080/accounts"</span></span><br><span class="line">&#123;<span class="string">"accountId"</span>:<span class="string">"00000156bfc1c044-0242ac1100460000"</span>&#125;%                                                                            </span><br><span class="line">➜  java-spring git:(master) ✗ curl -X POST -H <span class="string">"Content-Type: application/json"</span> -H <span class="string">"Cache-Control: no-cache"</span> <span class="operator">-d</span> <span class="string">'&#123;"initialBalance": 500&#125;'</span> <span class="string">"http://localhost:8080/accounts"</span></span><br><span class="line">&#123;<span class="string">"accountId"</span>:<span class="string">"00000156bfc1da88-0242ac1100960000"</span>&#125;%</span><br></pre></td></tr></table></figure></p>
<p>根据账户ID查询<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  java-spring git:(master) ✗ curl -X GET <span class="string">"http://localhost:8081/accounts/00000156bfc1c044-0242ac1100460000"</span></span><br><span class="line">&#123;<span class="string">"accountId"</span>:<span class="string">"00000156bfc1c044-0242ac1100460000"</span>,<span class="string">"balance"</span>:<span class="number">50000</span>&#125;%                                                        </span><br><span class="line">➜  java-spring git:(master) ✗ curl -X GET <span class="string">"http://localhost:8081/accounts/00000156bfc1da88-0242ac1100960000"</span></span><br><span class="line">&#123;<span class="string">"accountId"</span>:<span class="string">"00000156bfc1da88-0242ac1100960000"</span>,<span class="string">"balance"</span>:<span class="number">50000</span>&#125;%</span><br></pre></td></tr></table></figure></p>
<p>可以看到每个账户里都有50000美分。试试转账，然后再查询<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  java-spring git:(master) ✗ curl -X POST -H <span class="string">"Content-Type: application/json"</span> <span class="operator">-d</span> <span class="string">'&#123;"fromAccountId" : "00000156bfc1c044-0242ac1100460000", "toAccountId" : "00000156bfc1da88-0242ac1100960000", "amount" : 500&#125;'</span> <span class="string">"http://localhost:8082/transfers"</span></span><br><span class="line">&#123;<span class="string">"moneyTransferId"</span>:<span class="string">"00000156bfc75387-0242ac1100ac0000"</span>&#125;%                                                                                                                                                    </span><br><span class="line">➜  java-spring git:(master) ✗ curl -X GET <span class="string">"http://localhost:8081/accounts/00000156bfc1da88-0242ac1100960000"</span></span><br><span class="line">&#123;<span class="string">"accountId"</span>:<span class="string">"00000156bfc1da88-0242ac1100960000"</span>,<span class="string">"balance"</span>:<span class="number">50000</span>&#125;%                                                                                                                                          </span><br><span class="line">➜  java-spring git:(master) ✗ curl -X GET <span class="string">"http://localhost:8081/accounts/00000156bfc1c044-0242ac1100460000"</span></span><br><span class="line">&#123;<span class="string">"accountId"</span>:<span class="string">"00000156bfc1c044-0242ac1100460000"</span>,<span class="string">"balance"</span>:<span class="number">0</span>&#125;%                                                                                                                                              </span><br><span class="line">➜  java-spring git:(master) ✗ curl -X GET <span class="string">"http://localhost:8081/accounts/00000156bfc1da88-0242ac1100960000"</span></span><br><span class="line">&#123;<span class="string">"accountId"</span>:<span class="string">"00000156bfc1da88-0242ac1100960000"</span>,<span class="string">"balance"</span>:<span class="number">100000</span>&#125;%</span><br></pre></td></tr></table></figure></p>
<p>可以看到中间有个状态是不对的，这个基于事件驱动的，还没有自己看，应该是有延迟，后来再查询就是准确的了。事件驱动的后面会专门看看再整理篇文章。</p>
<h3 id="u7ED3_u8BED"><a href="#u7ED3_u8BED" class="headerlink" title="结语"></a>结语</h3><p>本篇主要描述了如何使用docker-compose构建基于docker的java微服务框架。后续会对里面的知识点做些详细的学习。</p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/08/24/dockerjavamicroservice1/" data-id="cj26adtxj00112suq2reity56" class="article-share-link" data-share="baidu" data-title="基于Docker的java微服务(一) 部署Chris Richardson的转账案例">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/08/24/dockerjavamicroservice1/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CQRS/">CQRS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Event-Sourcing/">Event-Sourcing</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringBoot/">SpringBoot</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-springcloud6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/09/springcloud6/" class="article-date">
  <time datetime="2016-08-09T07:47:33.000Z" itemprop="datePublished">2016-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/09/springcloud6/">Spring Cloud构建微服务架构（六）服务网关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>原文 : <a href="http://blog.didispace.com/springcloud5/" target="_blank" rel="external">Spring Cloud构建微服务架构（五）服务网关</a></p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/08/09/springcloud6/" data-id="cj26adtx5000f2suq9pp54ly6" class="article-share-link" data-share="baidu" data-title="Spring Cloud构建微服务架构（六）服务网关">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/08/09/springcloud6/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SpringCloud5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/09/SpringCloud5/" class="article-date">
  <time datetime="2016-08-09T02:38:46.000Z" itemprop="datePublished">2016-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/09/SpringCloud5/">Spring Cloud构建微服务架构（五）分布式配置中心</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>原文 : <a href="http://blog.didispace.com/springcloud4/" target="_blank" rel="external">Spring Cloud构建微服务架构（四）分布式配置中心</a></p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/08/09/SpringCloud5/" data-id="cj26adty3001y2suq8dv6eqkt" class="article-share-link" data-share="baidu" data-title="Spring Cloud构建微服务架构（五）分布式配置中心">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/08/09/SpringCloud5/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring-Cloud构建微服务架构（四）集群" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/05/Spring-Cloud构建微服务架构（四）集群/" class="article-date">
  <time datetime="2016-08-05T02:07:59.000Z" itemprop="datePublished">2016-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/05/Spring-Cloud构建微服务架构（四）集群/">Spring Cloud构建微服务架构（四）集群</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>前面三篇都分享自<a href="http://blog.didispace.com/" target="_blank" rel="external">程序猿DD</a>的博客,暂时(2016年08月05日)还没有更新关于Eureka集群的博客。<br>这里参考了<a href="https://segmentfault.com/blog/mumubin" target="_blank" rel="external">木木彬</a>的<a href="https://segmentfault.com/a/1190000006149891" target="_blank" rel="external">Spring Cloud实战(二)-Spring Cloud Eureka</a>博客内容。<br>对集群配置简单记录下,方便以后查阅。同时也期待<code>程序猿DD</code>更新更多更精彩的博客。</p>
<p>本文代码基于<a href="https://git.oschina.net/didispace/SpringBoot-Learning/tree/master/Chapter9-1-3?dir=1&amp;filepath=Chapter9-1-3&amp;oid=cc93af44af30b42320041332790d071ed72a2450&amp;sha=4329c564d673b6cf7a53893ad9770abb7a67b328" target="_blank" rel="external">程序猿DD / SpringBoot-Learning / Chapter9-1-3</a>进行集群配置。</p>
<p>Spring Cloud 官方文档上对集群配置介绍的非常简单，对Eureka Server进行<a href="http://cloud.spring.io/spring-cloud-static/docs/1.0.x/spring-cloud.html#_peer_awareness" target="_blank" rel="external">Peer Awareness</a>配置，这样多个服务端就可以关联到一起。好了，下面看看具体的配置。</p>
<h4 id="hosts_u4FEE_u6539"><a href="#hosts_u4FEE_u6539" class="headerlink" title="hosts修改"></a>hosts修改</h4><p>在hosts（路径：/etc/hosts）文件中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1       eureka-primary&#10;127.0.0.1       eureka-secondary&#10;127.0.0.1       eureka-tertiary</span><br></pre></td></tr></table></figure>
<h4 id="u670D_u52A1_u7AEF_u914D_u7F6E"><a href="#u670D_u52A1_u7AEF_u914D_u7F6E" class="headerlink" title="服务端配置"></a>服务端配置</h4><p>先注释掉application.properties中的配置，添加application.yml，在yml添加多个profiles,和instanceId，此时Eureka Server 同时也是个Eureka Client,需要设置eureka.client.serviceUrl.defaultZone,值是另外两个（这就是官网所说的<code>Peer Awareness</code>）:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---&#10;spring:&#10;  application:&#10;    name: eureka-server-clustered&#10;  profiles: primary&#10;server:&#10;  port: 1111&#10;eureka:&#10;  instance:&#10;    hostname: eureka-primary&#10;  client:&#10;    registerWithEureka: true&#10;    fetchRegistry: true&#10;    serviceUrl:&#10;      defaultZone: http://eureka-secondary:1112/eureka/,http://eureka-tertiary:1113/eureka/&#10;---&#10;spring:&#10;  application:&#10;    name: eureka-server-clustered&#10;  profiles: secondary&#10;server:&#10;  port: 1112&#10;eureka:&#10;  instance:&#10;    hostname: eureka-secondary&#10;  client:&#10;    registerWithEureka: true&#10;    fetchRegistry: true&#10;    serviceUrl:&#10;      defaultZone: http://eureka-secondary:1111/eureka/,http://eureka-tertiary:1113/eureka/&#10;---&#10;spring:&#10;  application:&#10;    name: eureka-server-clustered&#10;  profiles: tertiary&#10;server:&#10;  port: 1113&#10;eureka:&#10;  instance:&#10;    hostname: eureka-tertiary&#10;  client:&#10;    registerWithEureka: true&#10;    fetchRegistry: true&#10;    serviceUrl:&#10;      defaultZone: http://eureka-secondary:1111/eureka/,http://eureka-tertiary:1112/eureka/</span><br></pre></td></tr></table></figure>
<h4 id="u670D_u52A1_u7AEF_u542F_u52A8"><a href="#u670D_u52A1_u7AEF_u542F_u52A8" class="headerlink" title="服务端启动"></a>服务端启动</h4><p>配置完成，要分别启动3个Server，分别执行下面的命令即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  eureka-server git:(master) ✗ mvn clean &amp;&amp; mvn install</span><br><span class="line">➜  eureka-server git:(master) ✗ <span class="built_in">cd</span> target</span><br><span class="line">➜  target git:(master) ✗ java -Dspring.profiles.active=primary -jar eureka-server-<span class="number">0.0</span>.<span class="number">1</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  target git:(master) ✗ java -Dspring.profiles.active=secondary -jar eureka-server-<span class="number">0.0</span>.<span class="number">1</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  target git:(master) ✗ java -Dspring.profiles.active=tertiary -jar eureka-server-<span class="number">0.0</span>.<span class="number">1</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<p>我们访问其中一个服务地址<a href="http://localhost:1111/" target="_blank" rel="external">http://localhost:1111/</a> 可以看到如下内容，说明服务启动成功：</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/eureka-server-1.png" alt="Eureka Server"></p>
<h4 id="u5BA2_u6237_u7AEF_u914D_u7F6E"><a href="#u5BA2_u6237_u7AEF_u914D_u7F6E" class="headerlink" title="客户端配置"></a>客户端配置</h4><p>服务端已准备就绪，客户端如何注册到多个服务地址呢？其实在服务端配置defaultZone时，指定多个地址，就告诉我们客户端也这么指定就可以啦。</p>
<p>修改compute-service的application.properties中的defaultZone值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#25351;&#23450;&#24494;&#26381;&#21153;&#30340;&#21517;&#31216;&#21518;&#32493;&#22312;&#35843;&#29992;&#30340;&#26102;&#20505;&#21482;&#38656;&#35201;&#20351;&#29992;&#35813;&#21517;&#31216;&#23601;&#21487;&#20197;&#36827;&#34892;&#26381;&#21153;&#30340;&#35775;&#38382;&#10;spring.application.name=compute-service&#10;#&#24212;&#29992;&#31471;&#21475;&#10;server.port=2222&#10;#&#25351;&#23450;&#26381;&#21153;&#27880;&#20876;&#20013;&#24515;&#30340;&#20301;&#32622;&#10;#eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/&#10;eureka.client.serviceUrl.defaultZone=http://eureka-primary:1111/eureka/,http://eureka-secondary:1112/eureka/,http://eureka-tertiary:1113/eureka/</span><br></pre></td></tr></table></figure>
<h4 id="u542F_u52A8_u5BA2_u6237_u7AEF"><a href="#u542F_u52A8_u5BA2_u6237_u7AEF" class="headerlink" title="启动客户端"></a>启动客户端</h4><p>客户端默认端口是2222，我们启动2个客户端，另一个端口用2223好了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  compute-service git:(master) ✗ mvn clean &amp;&amp; mvn insatll</span><br><span class="line">➜  compute-service git:(master) ✗ <span class="built_in">cd</span> target</span><br><span class="line">➜  target git:(master) ✗ java -jar compute-service-<span class="number">0.0</span>.<span class="number">1</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  target git:(master) ✗ java -DServer.port=<span class="number">2223</span> -jar compute-service-<span class="number">0.0</span>.<span class="number">1</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<p>重新查看下<a href="http://localhost:1111/" target="_blank" rel="external">http://localhost:1111/</a></p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/eureka-server-2.png" alt="client starting"></p>
<p>2个客户端启动成功了。</p>
<h4 id="u6D4B_u8BD5"><a href="#u6D4B_u8BD5" class="headerlink" title="测试"></a>测试</h4><p>启动消费者eureka-ribbon成功后，简单测试下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ curl localhost:<span class="number">3333</span>/add</span><br><span class="line"><span class="number">30</span>%</span><br></pre></td></tr></table></figure>
<p>一个客户端也打出了日志</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">08</span>-<span class="number">05</span> <span class="number">11</span>:<span class="number">18</span>:<span class="number">23.554</span>  INFO <span class="number">5127</span> --- [nio-<span class="number">2223</span>-exec-<span class="number">1</span>] com.ow.wises.web.ComputeController       : /add, host:<span class="number">192.168</span>.<span class="number">1.145</span>, service_id:compute-service, result:<span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>好了，就先这样了。</p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/08/05/Spring-Cloud构建微服务架构（四）集群/" data-id="cj26adty400202suqjj8ng1zm" class="article-share-link" data-share="baidu" data-title="Spring Cloud构建微服务架构（四）集群">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/08/05/Spring-Cloud构建微服务架构（四）集群/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring-Cloud构建微服务架构（三）断路器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/05/Spring-Cloud构建微服务架构（三）断路器/" class="article-date">
  <time datetime="2016-08-05T02:02:21.000Z" itemprop="datePublished">2016-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/05/Spring-Cloud构建微服务架构（三）断路器/">Spring Cloud构建微服务架构（三）断路器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>原文 : <a href="http://blog.didispace.com/springcloud3/" target="_blank" rel="external">Spring Cloud构建微服务架构（三）断路器</a></p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/08/05/Spring-Cloud构建微服务架构（三）断路器/" data-id="cj26adty900242suqodc3oef6" class="article-share-link" data-share="baidu" data-title="Spring Cloud构建微服务架构（三）断路器">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/08/05/Spring-Cloud构建微服务架构（三）断路器/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring-Cloud构建微服务架构（二）服务消费者" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/05/Spring-Cloud构建微服务架构（二）服务消费者/" class="article-date">
  <time datetime="2016-08-05T02:00:33.000Z" itemprop="datePublished">2016-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/05/Spring-Cloud构建微服务架构（二）服务消费者/">Spring Cloud构建微服务架构（二）服务消费者</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>原文 : <a href="http://blog.didispace.com/springcloud2/" target="_blank" rel="external">Spring Cloud构建微服务架构（二）服务消费者</a></p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/08/05/Spring-Cloud构建微服务架构（二）服务消费者/" data-id="cj26adty700222suqvkwek689" class="article-share-link" data-share="baidu" data-title="Spring Cloud构建微服务架构（二）服务消费者">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/08/05/Spring-Cloud构建微服务架构（二）服务消费者/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring-Cloud构建微服务架构（一）服务注册与发现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/05/Spring-Cloud构建微服务架构（一）服务注册与发现/" class="article-date">
  <time datetime="2016-08-05T01:55:21.000Z" itemprop="datePublished">2016-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/05/Spring-Cloud构建微服务架构（一）服务注册与发现/">Spring Cloud构建微服务架构（一）服务注册与发现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>原文 : <a href="http://blog.didispace.com/springcloud1/" target="_blank" rel="external">Spring Cloud构建微服务架构（一）服务注册与发现</a></p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/08/05/Spring-Cloud构建微服务架构（一）服务注册与发现/" data-id="cj26adtyc00262suq951jtd2g" class="article-share-link" data-share="baidu" data-title="Spring Cloud构建微服务架构（一）服务注册与发现">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/08/05/Spring-Cloud构建微服务架构（一）服务注册与发现/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java-NIO-Buffer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/28/Java-NIO-Buffer/" class="article-date">
  <time datetime="2016-06-28T14:10:31.000Z" itemprop="datePublished">2016-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/28/Java-NIO-Buffer/">Java NIO Buffer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>原文：<a href="http://tutorials.jenkov.com/java-nio/buffers.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-nio/buffers.html</a></p>
<p>Java NIO Buffers是和NIO的Channels交互使用的。你知道的，数据是从Channel中读到Buffer里，数据从Buffer里写入到Channel中。 </p>
<p>Buffer本质上是可以读写数据的内存块。这个内存块被NIO的Buffer对象包裹，然后提供很多方法以便能够简单的操作这个内存块。</p>
<h4 id="Buffer_u57FA_u7840_u7528_u6CD5"><a href="#Buffer_u57FA_u7840_u7528_u6CD5" class="headerlink" title="Buffer基础用法"></a>Buffer基础用法</h4><p>使用Buffer读写数据基本上就4步：</p>
<ol>
<li>数据写入Buffer</li>
<li>调用 <code>buffer.flip()</code></li>
<li>从Buffer中读出数据</li>
<li>调用<code>buffer.clear()</code>或者<code>buffer.compact()</code>方法</li>
</ol>
<p>当你将数据写入buffer，buffer会一直留意你已经写了多少数据。一旦你需要读数据，你必须调用<code>flip()</code>方法将buffer从写模式切换到读模式中。进入读模式后，buffer允许你读取其中被写入的数据。</p>
<p>一旦你读完了所有的数据，你需要清空buffer，以备buffer可以继续被写入。这么做有两种方式：调用<code>clear()</code>方法或者调用<code>compact()</code>方法。<code>clear()</code>方法会清空buffer中的所有数据。<code>compact()</code>方法只会清楚掉你已经读过的数据。那些没读的数据会移到buffer的起始处，然后数据会接着这些未读数据后面继续写入。</p>
<p><strong>栗子</strong></p>
<p>下面是Buffer用法的🌰，用到的write，flip，read，clear等操作会作注释说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaNIOBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String path = Thread.currentThread().getContextClassLoader().getResource(<span class="string">""</span>).getPath();</span><br><span class="line">        RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(path+<span class="string">"/nio-data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        FileChannel inChannel = aFile.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//create buffer with capacity of 48 bytes</span></span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> bytesRead = inChannel.read(buf); <span class="comment">//read into buffer.</span></span><br><span class="line">        <span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            buf.flip();  <span class="comment">//make buffer ready for read</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) buf.get()); <span class="comment">// read 1 byte at a time</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            buf.clear(); <span class="comment">//make buffer ready for writing</span></span><br><span class="line">            bytesRead = inChannel.read(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        aFile.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Buffer_Capacity_2C_Position_and_Limit"><a href="#Buffer_Capacity_2C_Position_and_Limit" class="headerlink" title="Buffer Capacity, Position and Limit"></a>Buffer Capacity, Position and Limit</h4><p>buffer本质上就是一个你写入数据，然后读取数据的内存块。这个内存块被NIO Buffer对象包裹后，提供了一系列简单操作内存块的方法。</p>
<p>Buffer有3个你需要了解的属性：</p>
<ul>
<li>capacity</li>
<li>position</li>
<li>imit</li>
</ul>
<p>position和limit的含义取决于Buffer处在读模式还是写模式。capacity含义一直都是一样的，和Buffer模式无关。</p>
<p>这是一个关于capacity，position和limit的说明，后面会对其进行说明。</p>
<p><img src="http://tutorials.jenkov.com/images/java-nio/buffers-modes.png" alt="buffers-modes"></p>
<h5 id="Capacity"><a href="#Capacity" class="headerlink" title="Capacity"></a>Capacity</h5><p>Buffer作为一个内存块是有固定的大小值，称之为『capacity』。你只能向Buffer中写入byte，long，char等类型数据。一旦Buffer满了，在向其写入数据之前你需要清空它（读取数据或者清空数据）</p>
<h5 id="Position"><a href="#Position" class="headerlink" title="Position"></a>Position</h5><p>向Buffer中写数据是从一个确定的position开始，初始的position是0。当byte，long等数据写入Buffer，position会向前移动到下一个可供插入数据的单元。position最大值为capacity-1。</p>
<p>从Buffer中读数据也是从一个给定的位置开始。当你将Buffer从写模式切换到读模式后，position的值重置为0。从Buffer中读数据就是从position读，读取后，position会向前移动到下一个可供读取的单元。</p>
<h5 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h5><p>写模式中，limit就是写入buffer的数据量。Limit等于buffer的capacity。</p>
<p>当切换到读模式后，limit就是buffer中可以读取的数据量。就是说，切换到读模式时，limit就是设置为写模式中position的值。也就是说，buffer中写入的数据都可以读取到。</p>
<h4 id="Buffer_u7684_u7C7B_u578B"><a href="#Buffer_u7684_u7C7B_u578B" class="headerlink" title="Buffer的类型"></a>Buffer的类型</h4><p>伴随Java NIO的Buffer类型有:</p>
<ul>
<li>ByteBuffer</li>
<li>MappedByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>可以看到，这些Buffer类型表示了不同的数据类型。换句话说，就是可以通过char，short，int，long，float 或 double类型来操作缓冲区中的字节。</p>
<p>MappedByteBuffer有点特殊，在它的专门章节中再描述。</p>
<h4 id="Buffer_u7684_u5206_u914D"><a href="#Buffer_u7684_u5206_u914D" class="headerlink" title="Buffer的分配"></a>Buffer的分配</h4><p>在获取到Buffer对象后首先要去分配。每个Buffer类都有个<code>allocate()</code>方法。下面的例子是ByteBuffer分配capacity为48字节的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br></pre></td></tr></table></figure>
<p>Here is an example allocating a CharBuffer with space for 1024 characters:<br>下面是CharBuffer分配1024个字符的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharBuffer buf = CharBuffer.allocate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="u5411Buffer_u4E2D_u5199_u5165_u6570_u636E"><a href="#u5411Buffer_u4E2D_u5199_u5165_u6570_u636E" class="headerlink" title="向Buffer中写入数据"></a>向Buffer中写入数据</h4><p>向Buffer中写入数据有两种方式：</p>
<ul>
<li>从Channel中获取数据写入Buffer</li>
<li>通过buffer的<code>put()</code>方法写入数据</li>
</ul>
<p>从Channel中获取数据写入buffer的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);<span class="comment">//read into buffer.</span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>put()</code>方法写入数据的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.put(<span class="number">127</span>);</span><br></pre></td></tr></table></figure>
<p>有不同的版本的<code>put()</code>方法，允许你使用不同的方式写入数据。比如，在特定的位置写入，写入字节或数组。查看JavaDoc获取buffer具体的实现。</p>
<h4 id="flip_28_29"><a href="#flip_28_29" class="headerlink" title="flip()"></a>flip()</h4><p><code>flip()</code>方法用来切换Buffer的读和写模式。调用<code>flip()</code>，设置position为0，设置limit为原来的position值。就是说，position现在用来标记读的位置，Limit用来标记可以读多少。</p>
<h4 id="u4ECEBuffer_u4E2D_u8BFB_u6570_u636E"><a href="#u4ECEBuffer_u4E2D_u8BFB_u6570_u636E" class="headerlink" title="从Buffer中读数据"></a>从Buffer中读数据</h4><p>从Buffer中读取数据有两种方式：</p>
<ul>
<li>将buffer中的数据读入到channel中</li>
<li>调用buffer自带的<code>get()</code>方法直接读</li>
</ul>
<p>举个🌰：将Buffer中的数据读到channel中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//read from buffer into channel.</span></span><br><span class="line"><span class="keyword">int</span> bytesWritten = inChannel.write(buf);</span><br></pre></td></tr></table></figure>
<p>举个🌰：使用<code>get()</code>方法读取Buffer<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> aByte = buf.get();</span><br></pre></td></tr></table></figure></p>
<p>有不同的版本的<code>get()</code>方法，允许你使用不同的方式写入数据。比如，在特定的位置写入，写入字节或数组。查看JavaDoc获取buffer具体的实现。</p>
<h4 id="rewind_28_29"><a href="#rewind_28_29" class="headerlink" title="rewind()"></a>rewind()</h4><p><code>Buffer.rewind()</code>重置position为0，这样就可以重新读buffer的数据。limit不受影响，始终可以标记buffer中可读的数据量。</p>
<h4 id="clear_28_29_and_compact_28_29"><a href="#clear_28_29_and_compact_28_29" class="headerlink" title="clear() and compact()"></a>clear() and compact()</h4><p>从Buffer中读完数据以后要做好Buffer写的准备。可以调用<code>clear()</code>方法或者<code>compact()</code>方法。</p>
<p>调用<code>clear()</code>方法会重置position的值为0，Limit的值为capacity。意思是，Buffer已经清空。Buffer中的数据并没有清楚掉。只是告诉你从Buffer的哪个位置可以写入数据。</p>
<p>如果存在没有读取的数据，调用<code>clear()</code>方法后，该数据会被标记为’遗忘的’，因为这些数据再也没有什么标记其实被读过的还是没被读过的。</p>
<p>如果你必须先向Buffer中写入数据，然后还想读那些没有被读过的数据。需要调用<code>compact()</code>方法代替<code>clear()</code>方法。</p>
<p><code>compact()</code>方法把所有没有读过的数据复制到Buffer的起始处。然后设置position的值为味道数据后面的值。Limit仍然设置为capacity。这样，Buffer就做好写的准备，而不必覆盖掉未读的数据。</p>
<h4 id="mark_28_29_and_reset_28_29"><a href="#mark_28_29_and_reset_28_29" class="headerlink" title="mark() and reset()"></a>mark() and reset()</h4><p>使用<code>Buffer.mark()</code>方法可以标记一个指定的position。这样再之后调用<code>Buffer.reset()</code>方法重置position到标记的地方。</p>
<p>举个🌰：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.mark();</span><br><span class="line"><span class="comment">//call buffer.get() a couple of times, e.g. during parsing.</span></span><br><span class="line">buffer.reset();  <span class="comment">//set position back to mark.</span></span><br></pre></td></tr></table></figure></p>
<h4 id="equals_28_29_and_compareTo_28_29"><a href="#equals_28_29_and_compareTo_28_29" class="headerlink" title="equals() and compareTo()"></a>equals() and compareTo()</h4><p>比较两个buffers仍然可以使用<code>equals()</code>和<code>compareTo()</code>方法。</p>
<h5 id="equals_28_29"><a href="#equals_28_29" class="headerlink" title="equals()"></a>equals()</h5><p>两个buffers相等，那么： </p>
<ul>
<li>有相同的类型（byte、char、int等）。</li>
<li>Buffer中剩余的byte、char等的个数相等。</li>
<li>Buffer中所有剩余的byte、char等都相同。</li>
</ul>
<p>就是说：equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。</p>
<h5 id="compareTo_28_29"><a href="#compareTo_28_29" class="headerlink" title="compareTo()"></a>compareTo()</h5><p>compareTo()方法比较两个Buffer的剩余元素(byte、char等)， 如果满足下列条件，则认为一个Buffer“小于”另一个Buffer：</p>
<ul>
<li>第一个不相等的元素小于另一个Buffer中对应的元素 。</li>
<li>所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。</li>
</ul>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/06/28/Java-NIO-Buffer/" data-id="cj26adtzo003r2suqxrfl4qn2" class="article-share-link" data-share="baidu" data-title="Java NIO Buffer">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/06/28/Java-NIO-Buffer/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-NIO/">Java NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java-NIO-Channel" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/26/Java-NIO-Channel/" class="article-date">
  <time datetime="2016-06-26T13:04:43.000Z" itemprop="datePublished">2016-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/26/Java-NIO-Channel/">Java NIO Channel</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>Java NIO 的Channels有些像流，但是也有一些区别：</p>
<ul>
<li>可以向一个Channel即读又写。流是典型的单向的（写或者读）</li>
<li>Channels的读写是异步的</li>
<li>Channels总是读数据到Buffer中，或者将Buffer中的数据写入Channel</li>
</ul>
<p>上面提到的，从channel中读取数据至buffer中，将buffer中的数据写入channel中：</p>
<p><img src="http://tutorials.jenkov.com/images/java-nio/overview-channels-buffers.png" alt="Java NIO: Channels read data into Buffers, and Buffers write data into Channels"><br><strong>Java NIO: Channels read data into Buffers, and Buffers write data into Channels</strong></p>
<h4 id="Channel_Implementations"><a href="#Channel_Implementations" class="headerlink" title="Channel Implementations"></a>Channel Implementations</h4><p>在Java NIO中有一些比较重要的channel实现类：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p><code>FileChannel</code>从文件中读取数据。<br><code>DatagramChannel</code>通过UDP读写网络中的数据。<br><code>SocketChannel</code>通过TCP读写网络中的数据。<br><code>ServerSocketChannel</code>可以监听新进来的TCP连接，像Web服务器那样，对每一个新进来的连接都会创建一个SocketChannel。</p>
<h4 id="Basic_Channel_Example"><a href="#Basic_Channel_Example" class="headerlink" title="Basic Channel Example"></a>Basic Channel Example</h4><p>下面是一个使用<code>FileChannel</code>读数据到Buffer中的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RandomAccessFile accessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"nio-data.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line">        FileChannel fileChannel = accessFile.getChannel();</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> bytesRead = fileChannel.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Read "</span> + bytesRead);</span><br><span class="line">            buffer.flip();<span class="comment">//切换读写模式，此处是由写切换到下面的读</span></span><br><span class="line">            <span class="keyword">if</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) buffer.get());</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.clear();</span><br><span class="line">            bytesRead = fileChannel.read(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        accessFile.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 buf.flip() 的调用，首先读取数据到Buffer，然后反转Buffer，接着再从Buffer中读取数据。下一节会深入讲解Buffer的更多细节。</p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/06/26/Java-NIO-Channel/" data-id="cj26adtzl003n2suqwj95dizf" class="article-share-link" data-share="baidu" data-title="Java NIO Channel">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/06/26/Java-NIO-Channel/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-NIO/">Java NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java-NIO-Overview" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/25/Java-NIO-Overview/" class="article-date">
  <time datetime="2016-06-25T05:27:34.000Z" itemprop="datePublished">2016-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/25/Java-NIO-Overview/">Java NIO 概述</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>Java NIO 包含下面三个核心组件:</p>
<ul>
<li>Channels</li>
<li>Buffers</li>
<li>Selectors</li>
</ul>
<p>Java NIO 还有很多其他的类和组件,Channel,Buffer,Selector是核心的API。其他的组件,诸如Pipe、FileLock仅仅只是这3个核心组组件的实际应用。</p>
<h4 id="Channels_and_Buffers"><a href="#Channels_and_Buffers" class="headerlink" title="Channels  and Buffers"></a>Channels  and Buffers</h4><p>典型的,NIO中的所有IO都是起始于Channel。Channel有点像流。可以将Channel中数据读到Buffer里,也可以将Buffer里的数据写入Channel中。说明如下:</p>
<p><img src="http://tutorials.jenkov.com/images/java-nio/overview-channels-buffers.png" alt="Java NIO: Channels read data into Buffers, and Buffers write data into Channels"><br><strong>Java NIO: Channels read data into Buffers, and Buffers write data into Channels</strong></p>
<p>Java NIO中主要的Channel实现类有：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>可以看出,这些channels覆盖了UDP+TCP的网络IO,以及文件IO。</p>
<p>Java NIO中主要的Buffer实现类有:</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些实现类也包含了通过IO发送数据所需要的基本的数据类型：byte、short、int、long、float、double、Char型。</p>
<p>Java NIO也有 MappedByteBuffer类型，用于表示内存映射文件。</p>
<h4 id="Selectors"><a href="#Selectors" class="headerlink" title="Selectors"></a>Selectors</h4><p>一个Selectors允许一个单线程同时处理多个Channel。如果应用中有很多打开的连接（Channels）这么做是很方便的，但是每个连接的流量都很低。比如，聊天服务器。</p>
<p>下面是一个Selector处理3个Channel的说明：</p>
<p><img src="http://tutorials.jenkov.com/images/java-nio/overview-selectors.png" alt="Java NIO: A Thread uses a Selector to handle 3 Channel&#39;s"><br><strong>Java NIO: A Thread uses a Selector to handle 3 Channel’s</strong></p>
<p>先将Channels注册到Selector中，然后调用他的select()方法。这个方法会阻塞直到有注册的channel相应的事件触发。一旦这个方法返回，线程就可以处理这个事件。比如正在打开的连接，获取到数据的事件等等。</p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/06/25/Java-NIO-Overview/" data-id="cj26adtzi003j2suq0kvuotlm" class="article-share-link" data-share="baidu" data-title="Java NIO 概述">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/06/25/Java-NIO-Overview/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-NIO/">Java NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java-NIO-Tutorial" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/25/Java-NIO-Tutorial/" class="article-date">
  <time datetime="2016-06-25T05:24:25.000Z" itemprop="datePublished">2016-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/25/Java-NIO-Tutorial/">Java NIO 教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>原文地址<a href="http://tutorials.jenkov.com/java-reflection/classes.html" target="_blank" rel="external">Java Reflection</a></p>
<p>Java NIO(New IO) 是java(从java1.4开始) IO API的一个选择,可以代替Java标准IO和Java网络编程API。对于标准的IO来说,Java NIO提供了不同的处理IO的方式。</p>
<h4 id="Channels_and_Buffers"><a href="#Channels_and_Buffers" class="headerlink" title="Channels and Buffers"></a>Channels and Buffers</h4><p>在标准的IO API中,使用字节流和字符流。在NIO中需要用到channels和buffers。数据总是从channel获取读到buffer中,从buffer中获取写入channel。</p>
<h4 id="Non-blocking_IO"><a href="#Non-blocking_IO" class="headerlink" title="Non-blocking IO"></a>Non-blocking IO</h4><p>Java NIO 可以非阻塞式的处理IO。比如,一个线程将channel的数据读到buffer。在读的过程中,线程可以做其他事情。一旦数据读取完毕放到buffer中,线程在继续处理。写数据也是一样的操作。</p>
<h4 id="Selectors"><a href="#Selectors" class="headerlink" title="Selectors"></a>Selectors</h4><p>Java NIO 有个 『selectors』的概念,一个selector就是一个对象,通过事件(比如:连接打开,数据到达等等)监控多个channels。这样,一个单独的线程就可以监控多个channel的数据。</p>
<p>这些都是如何工作的,本系列的下一章 <a href="/">the Java NIO overview</a>会详细描述。</p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/06/25/Java-NIO-Tutorial/" data-id="cj26adtzd003a2suq79r2kel9" class="article-share-link" data-share="baidu" data-title="Java NIO 教程">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/06/25/Java-NIO-Tutorial/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-NIO/">Java NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaReflectionArray" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/24/JavaReflectionArray/" class="article-date">
  <time datetime="2016-06-24T12:52:55.000Z" itemprop="datePublished">2016-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/24/JavaReflectionArray/">Java反射之数组</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>原文地址<a href="http://tutorials.jenkov.com/java-reflection/arrays.html" target="_blank" rel="external">Java Reflection Arrays</a></p>
<p>在Java反射里面处理数组有时是比较棘手的.特别是你需要获得数组对象的实际类型.例如 int[]等待.这篇文字就来讨论通过反射如何创建数组如何获取数组中的对象.</p>
<h4 id="java-lang-reflect-Array"><a href="#java-lang-reflect-Array" class="headerlink" title="java.lang.reflect.Array"></a>java.lang.reflect.Array</h4><p>通过Java反射使用数组用到的是类java.lang.reflect.Array,不要和Java集合中的java.util.Arrays混淆.</p>
<h4 id="Creating_Arrays"><a href="#Creating_Arrays" class="headerlink" title="Creating Arrays"></a>Creating Arrays</h4><p>通过Java反射创建数组使用类java.lang.reflect.Array,下面给出了创建数组的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = (<span class="keyword">int</span>[]) Array.newInstance(<span class="keyword">int</span>.class,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>这是创建int类型数组的例子. Array.newInstance()方法的第一个参数<code>int.class</code>给出了数组元素类型,第二个参数<code>3</code>是数组需要分配的空间</p>
<h4 id="Accessing_Arrays"><a href="#Accessing_Arrays" class="headerlink" title="Accessing Arrays"></a>Accessing Arrays</h4><p>通过反射访问数组元素可以使用<code>Array.get()</code>和<code>Array.set()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = (<span class="keyword">int</span>[]) Array.newInstance(<span class="keyword">int</span>.class,<span class="number">3</span>);</span><br><span class="line">Array.set(intArray,<span class="number">0</span>,<span class="number">123</span>)</span><br><span class="line">Array.set(intArray,<span class="number">1</span>,<span class="number">456</span>)</span><br><span class="line">Array.set(intArray,<span class="number">1</span>,<span class="number">789</span>)</span><br><span class="line">   </span><br><span class="line">System.out.println(<span class="string">"intArray[0] = "</span> + Array.get(intArray, <span class="number">0</span>));</span><br><span class="line">System.out.println(<span class="string">"intArray[1] = "</span> + Array.get(intArray, <span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">"intArray[2] = "</span> + Array.get(intArray, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>打印出来的结果为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">intArray[<span class="number">0</span>] = <span class="number">123</span></span><br><span class="line">intArray[<span class="number">1</span>] = <span class="number">456</span></span><br><span class="line">intArray[<span class="number">2</span>] = <span class="number">789</span></span><br></pre></td></tr></table></figure>
<h4 id="u83B7_u53D6_u6570_u7EC4_u7684Class_u5BF9_u8C61"><a href="#u83B7_u53D6_u6570_u7EC4_u7684Class_u5BF9_u8C61" class="headerlink" title="获取数组的Class对象"></a>获取数组的Class对象</h4><p>在我编写<a href="http://butterfly.jenkov.com/" target="_blank" rel="external">Butterfly DI Container</a>的脚本语言时，当我想通过反射获取数组的Class对象时遇到了一点麻烦。如果不通过反射的话你可以这样来获取数组的Class对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class stringArrayClass = String[].class;</span><br></pre></td></tr></table></figure>
<p>如果使用Class.forName()方法来获取Class对象则不是那么简单。比如你可以像这样来获得一个原生数据类型（primitive）int数组的Class对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class intArray = Class.forName(<span class="string">"[I"</span>);</span><br></pre></td></tr></table></figure>
<p>在JVM中字母I代表int类型，左边的‘[’代表我想要的是一个int类型的数组，这个规则同样适用于其他的原生数据类型。对于普通对象类型的数组有一点细微的不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class stringArrayClass = Class.forName(<span class="string">"[Ljava.lang.String;"</span>);</span><br></pre></td></tr></table></figure>
<p>注意‘[L’的右边是类名，类名的右边是一个‘;’符号。这个的含义是一个指定类型的数组。需要注意的是，你不能通过Class.forName()方法获取一个原生数据类型的Class对象。下面这两个例子都会报ClassNotFoundException：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class intClass1 = Class.forName(<span class="string">"I"</span>);</span><br><span class="line">Class intClass2 = Class.forName(<span class="string">"int"</span>);</span><br></pre></td></tr></table></figure>
<p>我通常会用下面这个方法来获取普通对象以及原生对象的Class对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">getClass</span><span class="params">(String className)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="string">"int"</span> .equals(className)) <span class="keyword">return</span> <span class="keyword">int</span> .class;</span><br><span class="line">  <span class="keyword">if</span>(<span class="string">"long"</span>.equals(className)) <span class="keyword">return</span> <span class="keyword">long</span>.class;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> Class.forName(className);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦你获取了类型的Class对象，你就有办法轻松的获取到它的数组的Class对象，你可以通过指定的类型创建一个空的数组，然后通过这个空的数组来获取数组的Class对象。这样做有点讨巧，不过很有效。如下例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class theClass = getClass(theClassName);</span><br><span class="line">Class stringArrayClass = Array.newInstance(theClass, <span class="number">0</span>).getClass();</span><br></pre></td></tr></table></figure>
<p>这是一个特别的方式来获取指定类型的指定数组的Class对象。无需使用类名或其他方式来获取这个Class对象。<br>为了确保Class对象是不是代表一个数组，你可以使用Class.isArray()方法来进行校验：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class stringArrayClass = Array.newInstance(String.class, <span class="number">0</span>).getClass();</span><br><span class="line">System.out.println(<span class="string">"is array: "</span> + stringArrayClass.isArray());</span><br></pre></td></tr></table></figure>
<h4 id="u83B7_u53D6_u6570_u7EC4_u7684_u6210_u5458_u7C7B_u578B"><a href="#u83B7_u53D6_u6570_u7EC4_u7684_u6210_u5458_u7C7B_u578B" class="headerlink" title="获取数组的成员类型"></a>获取数组的成员类型</h4><p>一旦你获取了一个数组的Class对象，你就可以通过Class.getComponentType()方法获取这个数组的成员类型。成员类型就是数组存储的数据类型。例如，数组int[]的成员类型就是一个Class对象int.class。String[]的成员类型就是java.lang.String类的Class对象。<br>下面是一个访问数组成员类型的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] strings = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">Class stringArrayClass = strings.getClass();</span><br><span class="line">Class stringArrayComponentType = stringArrayClass.getComponentType();</span><br><span class="line">System.out.println(stringArrayComponentType);</span><br></pre></td></tr></table></figure>
<p>下面这个例子会打印<code>java.lang.String</code>代表这个数组的成员类型是字符串。</p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/06/24/JavaReflectionArray/" data-id="cj26adtza00362suqdn7mq4v2" class="article-share-link" data-share="baidu" data-title="Java反射之数组">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/06/24/JavaReflectionArray/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-SE/">Java SE</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaReflectionGenerics" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/21/JavaReflectionGenerics/" class="article-date">
  <time datetime="2016-05-20T16:52:55.000Z" itemprop="datePublished">2016-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/21/JavaReflectionGenerics/">Java反射之泛型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>原文地址<a href="http://tutorials.jenkov.com/java-reflection/generics.html" target="_blank" rel="external">Java Reflection Generics</a></p>
<h4 id="Generic_Method_Return_Types"><a href="#Generic_Method_Return_Types" class="headerlink" title="Generic Method Return Types"></a>Generic Method Return Types</h4><p>如果你已经获取一个<code>java.lang.reflect.Method</code>的对象，就可以获取到该对象上的泛型返回类型信息。如果方法是在一个被参数化类型之中（如T fun()）那么你无法获取他的具体类型，但是如果方法返回一个泛型类（如List fun()）那么你就可以获得这个泛型类的具体参数化类型。下面这个例子定义了一个类这个类中的方法返回类型是一个泛型类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getStringList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子是可以获取到<code>getStringList()</code>方法的泛型返回类型。可以检测到<code>getStringList()</code>方法返回的List并不仅仅是一个List。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">       Method method = MyClass.class.getMethod(<span class="string">"getStringList"</span>);</span><br><span class="line">       Type returnType = method.getGenericReturnType();</span><br><span class="line">       <span class="keyword">if</span> (returnType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">           ParameterizedType type = (ParameterizedType) returnType;</span><br><span class="line">           Type[] typeArguments = type.getActualTypeArguments();</span><br><span class="line">           <span class="keyword">for</span> (Type typeArgument : typeArguments) &#123;</span><br><span class="line">               Class typeArgClass = (Class) typeArgument;</span><br><span class="line">               System.out.println(<span class="string">"typeArgClass:"</span> + typeArgClass);<span class="comment">//typeArgClass:class java.lang.String</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Type[]数组typeArguments只有一个结果 – 一个代表java.lang.String的Class类的实例。Class类实现了Type接口。</p>
<h4 id="Generic_Method_Parameter_Types"><a href="#Generic_Method_Parameter_Types" class="headerlink" title="Generic Method Parameter Types"></a>Generic Method Parameter Types</h4><p>使用Java反射还可以获取参数上的泛型，例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStringList</span><span class="params">(List&lt;String&gt; stringList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stringList = stringList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像下面这样获取参数上的泛型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Method method2 = MyClass.class.getMethod(<span class="string">"setStringList"</span>, List.class);</span><br><span class="line">Type[] genericParameterTypes = method2.getGenericParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (Type genericParameterType : genericParameterTypes) &#123;</span><br><span class="line">    <span class="keyword">if</span>(genericParameterType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">        ParameterizedType aType = (ParameterizedType) genericParameterType;</span><br><span class="line">        Type[] parameterArgTypes = aType.getActualTypeArguments();</span><br><span class="line">        <span class="keyword">for</span>(Type parameterArgType : parameterArgTypes)&#123;</span><br><span class="line">            Class parameterArgClass = (Class) parameterArgType;</span><br><span class="line">            System.out.println(<span class="string">"parameterArgClass = "</span> + parameterArgClass);<span class="comment">//parameterArgClass = class java.lang.String</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码打印出”parameterArgType = java.lang.String”。parameterArgTypes这个数组包含的是代表java.lang.String的Class类的实例。Class类实现了Type接口。</p>
<h4 id="Generic_Field_Types"><a href="#Generic_Field_Types" class="headerlink" title="Generic Field Types"></a>Generic Field Types</h4><p>访问public的泛型变量，无论这个变量是一个类的静态成员变量或是实例成员变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Field field = MyClass.class.getField(<span class="string">"stringList"</span>);</span><br><span class="line"></span><br><span class="line">Type genericFieldType = field.getGenericType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(genericFieldType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">    ParameterizedType aType = (ParameterizedType) genericFieldType;</span><br><span class="line">    Type[] fieldArgTypes = aType.getActualTypeArguments();</span><br><span class="line">    <span class="keyword">for</span>(Type fieldArgType : fieldArgTypes)&#123;</span><br><span class="line">        Class fieldArgClass = (Class) fieldArgType;</span><br><span class="line">        System.out.println(<span class="string">"fieldArgClass = "</span> + fieldArgClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码打印出”fieldArgClass = java.lang.String”。fieldArgTypes这个数组包含的是代表java.lang.String的Class类的实例。Class类实现了Type接口。</p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/05/21/JavaReflectionGenerics/" data-id="cj26adtyz002y2suq6io1jwbv" class="article-share-link" data-share="baidu" data-title="Java反射之泛型">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/05/21/JavaReflectionGenerics/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-SE/">Java SE</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaReflectionAnnotations" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/18/JavaReflectionAnnotations/" class="article-date">
  <time datetime="2016-05-17T16:52:55.000Z" itemprop="datePublished">2016-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/18/JavaReflectionAnnotations/">Java反射之注解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>原文地址<a href="http://tutorials.jenkov.com/java-reflection/annotations.html" target="_blank" rel="external">Java Reflection Annotations</a></p>
<p>在运行时状态下，你可以通过反射获取java对象上的注解。</p>
<h4 id="What_are_Java_Annotations_3F"><a href="#What_are_Java_Annotations_3F" class="headerlink" title="What are Java Annotations?"></a>What are Java Annotations?</h4><p>注解是Java5增加的功能。注解是一种注释或者是元数据可以直接插入到Java代码中。在编译时，通过预编译工具处理；或者在运行时，通过java反射处理。下面是个注解的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@MyAnnotation</span>(name=<span class="string">"someName"</span>,  value = <span class="string">"Hello World"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类TheClass的上面有个<code>@MyAnnotation</code>的注解。注解的定义类似接口定义，下面是注解定义的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="annotation">@Target</span>(ElementType.TYPE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建注解是，在interface前面使用<code>@</code>即可。创建之后就可以在代码里使用了，例如上面的例子。</p>
<p><code>@Retention(RetentionPolicy.RUNTIME)</code> 和 <code>@Target(ElementType.TYPE)</code>这两个指令，指明了这个注解如何被使用。</p>
<p><code>@Retention(RetentionPolicy.RUNTIME)</code> 意味着在运行时状态可以使用java反射获取注解，如果不设置这个指令，在运行时状态，注解不会被保存，同样的也就不能通过反射获取。 </p>
<p><code>@Target(ElementType.TYPE)</code>意味着注解只能用在Types上（比如类和接口）。你也可以指定为<code>METHOD</code>或者是<code>FIELD</code>，或者是不使用Target这个指令，这样你就可以在类，方法，变量上使用了。</p>
<h4 id="Class_Annotations"><a href="#Class_Annotations" class="headerlink" title="Class Annotations"></a>Class Annotations</h4><p>你可以在运行期访问类，方法，变量的注解。下面是类注解的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = TheClass.class;</span><br><span class="line">Annotation[] annotations = aClass.getAnnotations();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">    <span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">        MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">        System.out.println(<span class="string">"name: "</span> + myAnnotation.name());</span><br><span class="line">        System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以指定类进行访问，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = TheClass.class;</span><br><span class="line">Annotation annotation = aClass.getAnnotation(MyAnnotation.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">    MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">    System.out.println(<span class="string">"name: "</span> + myAnnotation.name());</span><br><span class="line">    System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Method_Annotations"><a href="#Method_Annotations" class="headerlink" title="Method Annotations"></a>Method Annotations</h4><p>下面是注解在方法上的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheClass2</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@MyAnnotation</span>(name=<span class="string">"someName"</span>,  value = <span class="string">"Hello World"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以像下面这样访问方法注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Method method = TheClass2.class.getMethod(<span class="string">"doSomething"</span>);</span><br><span class="line">Annotation[] annotations = method.getDeclaredAnnotations();</span><br><span class="line"><span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">    <span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">        MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">        System.out.println(<span class="string">"name: "</span> + myAnnotation.name());</span><br><span class="line">        System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者是指定方法注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Method method = TheClass2.class.getMethod(<span class="string">"doSomething"</span>);</span><br><span class="line">Annotation annotation = method.getAnnotation(MyAnnotation.class);</span><br><span class="line"><span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> MyAnnotation) &#123;</span><br><span class="line">    MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">    System.out.println(<span class="string">"name:"</span>+myAnnotation.name());</span><br><span class="line">    System.out.println(<span class="string">"value:"</span>+myAnnotation.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Parameter_Annotations"><a href="#Parameter_Annotations" class="headerlink" title="Parameter Annotations"></a>Parameter Annotations</h4><p>在方法的参数上使用注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheClass3</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomethingElse</span><span class="params">(</span><br><span class="line">        @MyAnnotation(name=<span class="string">"aName"</span>, value=<span class="string">"aValue"</span>)</span> String parameter)</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问方法参数上的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Method method = TheClass3.class.getMethod(<span class="string">"doSomethingElse"</span>);</span><br><span class="line">Annotation[][] parameterAnnotations = method.getParameterAnnotations();</span><br><span class="line">Class[] parameterTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(Annotation[] annotations : parameterAnnotations)&#123;</span><br><span class="line">  Class parameterType = parameterTypes[i++];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">    <span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">        MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">        System.out.println(<span class="string">"param: "</span> + parameterType.getName());</span><br><span class="line">        System.out.println(<span class="string">"name : "</span> + myAnnotation.name());</span><br><span class="line">        System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意Method.getParameterAnnotations()返回的是二维数组，包含每个参数的注解数组。</p>
<h4 id="Field_Annotations"><a href="#Field_Annotations" class="headerlink" title="Field Annotations"></a>Field Annotations</h4><p>变量上的注解使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheClass4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@MyAnnotation</span>(name=<span class="string">"someName"</span>,  value = <span class="string">"Hello World"</span>)</span><br><span class="line">  <span class="keyword">public</span> String myField = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问变量上的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Field field = TheClass4.class.getField(<span class="string">"myField"</span>);</span><br><span class="line">Annotation[] annotations = field.getDeclaredAnnotations();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">    <span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">        MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">        System.out.println(<span class="string">"name: "</span> + myAnnotation.name());</span><br><span class="line">        System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Field field = TheClass4.class.getField(<span class="string">"myField"</span>);</span><br><span class="line">Annotation annotation = field.getAnnotation(MyAnnotation.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">    MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">    System.out.println(<span class="string">"name: "</span> + myAnnotation.name());</span><br><span class="line">    System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/05/18/JavaReflectionAnnotations/" data-id="cj26adtzb00382suqgt8w8y39" class="article-share-link" data-share="baidu" data-title="Java反射之注解">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/05/18/JavaReflectionAnnotations/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-SE/">Java SE</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaReflectionPrivateFieldsAndMethods" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/14/JavaReflectionPrivateFieldsAndMethods/" class="article-date">
  <time datetime="2016-05-13T16:52:55.000Z" itemprop="datePublished">2016-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/14/JavaReflectionPrivateFieldsAndMethods/">Java反射之私有变量和私有方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>原文地址<a href="http://tutorials.jenkov.com/java-reflection/private-fields-and-methods.html" target="_blank" rel="external">Java Reflection Methods</a></p>
<p>通常情况下，从对象外部访问私有变量和私有方法是不被允许的，但是通过反射可以很容易获取私有变量和私有方法，在单元测试的时候很有用。</p>
<h6 id="Accessing_Private_Fields"><a href="#Accessing_Private_Fields" class="headerlink" title="Accessing Private Fields"></a>Accessing Private Fields</h6><p>获取私有变量你需要用到<code>Class.getDeclaredField(String name)</code>或者<code>Class.getDeclaredFields(String name)</code>方法。<code>Class.getField(String name)</code>和<code>Class.getFields(String name)</code>方法只能返回公有变量。下面是通过java的反射获取私有变量代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Order privateObject = <span class="keyword">new</span> Order(<span class="string">"2016051901"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Field privateField = Order.class.getDeclaredField(<span class="string">"orderId"</span>);</span><br><span class="line">    privateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    String orderId = (String) privateField.get(privateObject);</span><br><span class="line">    System.out.println(<span class="string">"orderId:"</span> + orderId);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码会打印出『orderId:2016051901』，值为Order实例私有变量orderId的值。</p>
<p><code>Order.class.getDeclaredField(&quot;orderId&quot;)</code>这个方法返回一个私有变量，这个私有变量是Order类中自己定义的变量，而不是继承自其父类的变量。</p>
<p><code>privateField.setAccessible(true);</code>这个方法会关闭实例类的反射访问检查。现在你可以访问私有的，受保护的和包级访问的变量。</p>
<h6 id="Accessing_Private_Methods"><a href="#Accessing_Private_Methods" class="headerlink" title="Accessing Private Methods"></a>Accessing Private Methods</h6><p>要获取私有方法你需要使用方法<code>Class.getDeclaredMethod(String name, Class[] parameterTypes)</code>或者<code>Class.getDeclaredMethods()</code>。<code>Class.getMethod()</code>和<code>Class.getMethods()</code>方法只是返回的公有方法。下面是使用java反射访问私有方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Order privateObject = <span class="keyword">new</span> Order(<span class="string">"2016051901"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Method privateMethod = Order.class.getDeclaredMethod(<span class="string">"getOrderId"</span>);</span><br><span class="line">    privateMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    String returnValue = (String) privateMethod.invoke(privateObject);</span><br><span class="line">    System.out.println(<span class="string">"returnValue = "</span> + returnValue);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码会打印出『returnValue=2016051901』，其值是通过反射调用Order实例的私有方法『getOrderId()』获取到的。</p>
<p><code>Order.class.getDeclaredMethod(&quot;getOrderId&quot;)</code>,这个方法也之后返回Order类自己的私有方法，而非其继承自父类的私有方法。</p>
<p><code>privateMethod.setAcessible(true)</code>，这个方法会关闭实例类的私有方法反射访问检查，现在你可以通过反射获取的实例的私有，受保护和包级访问权限的方法。 </p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/05/14/JavaReflectionPrivateFieldsAndMethods/" data-id="cj26adtyw002t2suquyiwaf5q" class="article-share-link" data-share="baidu" data-title="Java反射之私有变量和私有方法">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/05/14/JavaReflectionPrivateFieldsAndMethods/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-SE/">Java SE</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaReflectionMethods" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/13/JavaReflectionMethods/" class="article-date">
  <time datetime="2016-05-12T16:52:55.000Z" itemprop="datePublished">2016-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/13/JavaReflectionMethods/">Java反射之方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <p>原文地址<a href="http://tutorials.jenkov.com/java-reflection/methods.html" target="_blank" rel="external">Java Reflection Methods</a></p>
<h5 id="Obtaining_Method_Objects"><a href="#Obtaining_Method_Objects" class="headerlink" title="Obtaining Method Objects"></a>Obtaining Method Objects</h5><p>获取类的方法，Method[]数组里面只包含类中public修饰的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = orderClass.getMethods();</span><br></pre></td></tr></table></figure>
<p>也可以使用具体的方法名及参数类型直接获取,以Order类中的getState()，setState()方法为例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Method methodHaveNoParameter = orderClass.getMethod(<span class="string">"getState"</span>,<span class="keyword">null</span>);<span class="comment">//该方法没有参数,null省略也可以</span></span><br><span class="line">    System.out.println(methodHaveNoParameter.getName());<span class="comment">//getState</span></span><br><span class="line">    </span><br><span class="line">    Method methodHaveParameter = orderClass.getMethod(<span class="string">"setState"</span>,<span class="keyword">new</span> Class[]&#123;String.class&#125;);<span class="comment">//该方有String类型参数</span></span><br><span class="line">    System.out.println(methodHaveParameter.getName());<span class="comment">//setState</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Method_Parameters_and_Return_Types"><a href="#Method_Parameters_and_Return_Types" class="headerlink" title="Method Parameters and Return Types"></a>Method Parameters and Return Types</h4><p>获取方法的参数类型及返回类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class[] parameters = methodHaveParameter.getParameterTypes();</span><br><span class="line">System.out.println(parameters[<span class="number">0</span>].getName());<span class="comment">//class java.lang.String</span></span><br><span class="line"></span><br><span class="line">Class returnType = methodHaveParameter.getReturnType();</span><br><span class="line">System.out.println(returnType);<span class="comment">//void</span></span><br></pre></td></tr></table></figure>
<h4 id="Invoking_Methods_using_Method_Object"><a href="#Invoking_Methods_using_Method_Object" class="headerlink" title="Invoking Methods using Method Object"></a>Invoking Methods using Method Object</h4><p>使用<code>invoke</code>调用方法,以Order类中的pay()方法为例，该方法直接返回一个字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Method methodPay = orderClass.getMethod(<span class="string">"pay"</span>,<span class="keyword">new</span> Class[]&#123;String.class&#125;);</span><br><span class="line">    Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    Object returnValue = methodPay.invoke(order,<span class="string">"2016050902"</span>);</span><br><span class="line">    System.out.println(returnValue);<span class="comment">//2016050902 pay success</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果方法是static的，那么在调用invoke时，第一个参数（类的实例）可以传null(传入类的实例也是可以的)。</p>
<h5 id="u83B7_u53D6getter/setter_u65B9_u6CD5"><a href="#u83B7_u53D6getter/setter_u65B9_u6CD5" class="headerlink" title="获取getter/setter方法"></a>获取getter/setter方法</h5><p>使用反射时，如果需要获取类的getter和setter方法，需要获取所有methods，并根据getter/setter的特点找到他们。</p>
<ul>
<li>Getter<br>  getter方法以「get」开头，没有参数，有返回值</li>
<li>Setter<br>  setter方法以「set」开头，有一个参数，返回值可能有可能没有</li>
</ul>
<p>下面是从类中找到get/set方法的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printGettersSetters</span><span class="params">(Class aClass)</span></span>&#123;</span><br><span class="line">  Method[] methods = aClass.getMethods();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">    <span class="keyword">if</span>(isGetter(method)) System.out.println(<span class="string">"getter: "</span> + method);</span><br><span class="line">    <span class="keyword">if</span>(isSetter(method)) System.out.println(<span class="string">"setter: "</span> + method);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isGetter</span><span class="params">(Method method)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!method.getName().startsWith(<span class="string">"get"</span>))      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(method.getParameterTypes().length != <span class="number">0</span>)   <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">void</span>.class.equals(method.getReturnType()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSetter</span><span class="params">(Method method)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!method.getName().startsWith(<span class="string">"set"</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(method.getParameterTypes().length != <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/05/13/JavaReflectionMethods/" data-id="cj26adtyy002w2suqgc3liv62" class="article-share-link" data-share="baidu" data-title="Java反射之方法">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/05/13/JavaReflectionMethods/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-SE/">Java SE</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaReflectionFields" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/12/JavaReflectionFields/" class="article-date">
  <time datetime="2016-05-11T16:52:55.000Z" itemprop="datePublished">2016-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/12/JavaReflectionFields/">Java反射之变量</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      

      <h3 id="Java_Reflection_Fields"><a href="#Java_Reflection_Fields" class="headerlink" title="Java Reflection Fields"></a>Java Reflection Fields</h3><p>原文地址<a href="http://tutorials.jenkov.com/java-reflection/fields.html" target="_blank" rel="external">Java Reflection Fields</a></p>
<h4 id="Obtaining_Field_Objects"><a href="#Obtaining_Field_Objects" class="headerlink" title="Obtaining Field Objects"></a>Obtaining Field Objects</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field[] fields = orderClass.getFields();</span><br></pre></td></tr></table></figure>
<p>Field[]数组里面只包含类中public修饰的成员变量</p>
<p>如果知道类的成员变量名称，可以直接通过getField()方法获取到，成员变量的访问权限同样需要是public的</p>
<h4 id="Field_Name_and_Type"><a href="#Field_Name_and_Type" class="headerlink" title="Field Name and Type"></a>Field Name and Type</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Field field = orderClass.getField(<span class="string">"description"</span>);</span><br><span class="line">    System.out.println(field.getName());<span class="comment">//成员变量名称description</span></span><br><span class="line">    System.out.println(field.getType());<span class="comment">//成员变量类型class java.lang.String</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;<span class="comment">//如果不存在description的变量，会抛出NoSuchFieldException</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Getting_and_Setting_Field_Values"><a href="#Getting_and_Setting_Field_Values" class="headerlink" title="Getting and Setting Field Values"></a>Getting and Setting Field Values</h4><p>获得了field的引用，就可以通过get()，set()方法，获取和设置成员变量的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Field field = orderClass.getField(<span class="string">"description"</span>);</span><br><span class="line">    Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    Object value = field.get(order);</span><br><span class="line">    field.set(order, value);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入Field.get()/Field.set()方法的参数order是Order类的实例。<br>如果变量是静态变量的话(public static)那么在调用Field.get()/Field.set()方法的时候传入null做为参数而不用传递拥有该变量的类的实例(传入类的实例也是可以的)。</p>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://suqun.github.io/2016/05/12/JavaReflectionFields/" data-id="cj26adtz000302suqorqd1mk7" class="article-share-link" data-share="baidu" data-title="Java反射之变量">分享到</a>
      

      
        <a href="http://suqun.github.io/2016/05/12/JavaReflectionFields/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-SE/">Java SE</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
      
      <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CQRS/">CQRS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event-Sourcing/">Event-Sourcing</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IntelliJ/">IntelliJ</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-NIO/">Java NIO</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-SE/">Java SE</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java多线程/">Java多线程</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/">K8s</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/">SpringBoot</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/">SpringCloud</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zookeeper/">zookeeper</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 18.33px;">Algorithm</a> <a href="/tags/CQRS/" style="font-size: 10px;">CQRS</a> <a href="/tags/Docker/" style="font-size: 18.33px;">Docker</a> <a href="/tags/Event-Sourcing/" style="font-size: 10px;">Event-Sourcing</a> <a href="/tags/IntelliJ/" style="font-size: 10px;">IntelliJ</a> <a href="/tags/JVM/" style="font-size: 16.67px;">JVM</a> <a href="/tags/Java-NIO/" style="font-size: 20px;">Java NIO</a> <a href="/tags/Java-SE/" style="font-size: 18.33px;">Java SE</a> <a href="/tags/Java多线程/" style="font-size: 15px;">Java多线程</a> <a href="/tags/Jenkins/" style="font-size: 10px;">Jenkins</a> <a href="/tags/K8s/" style="font-size: 13.33px;">K8s</a> <a href="/tags/SpringBoot/" style="font-size: 13.33px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 15px;">SpringCloud</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/shell/" style="font-size: 13.33px;">shell</a> <a href="/tags/zookeeper/" style="font-size: 11.67px;">zookeeper</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">5</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/05/01/algorithm-8/">算法之排序-归并排序</a>
          </li>
        
          <li>
            <a href="/2017/04/30/algorithm-7/">算法之排序-希尔排序</a>
          </li>
        
          <li>
            <a href="/2017/04/30/algorithm-6/">算法之排序-选择排序与插入排序的比较</a>
          </li>
        
          <li>
            <a href="/2017/04/29/MultiThread-5/">等待超时模式</a>
          </li>
        
          <li>
            <a href="/2017/04/29/MultiThread-4/">Thread.join()的使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="" target="_blank">程序猿DD</a>
          </li>
        
          <li>
            <a href="" target="_blank">并发编程网</a>
          </li>
        
          <li>
            <a href="" target="_blank">鸟窝</a>
          </li>
        
          <li>
            <a href="" target="_blank">极客学院</a>
          </li>
        
          <li>
            <a href="" target="_blank">慕课网</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Larry<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">所有文章</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"suqun"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js" type="text/javascript"></script>

</div>
</body>
</html>
