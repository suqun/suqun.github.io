<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[入耳箸心]]></title>
  <subtitle><![CDATA[成长路上的点滴记录]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://suqun.github.io/"/>
  <updated>2017-04-16T16:11:19.000Z</updated>
  <id>http://suqun.github.io/</id>
  
  <author>
    <name><![CDATA[Larry]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[算法之数据结构——树]]></title>
    <link href="http://suqun.github.io/2017/04/17/algorithm-3/"/>
    <id>http://suqun.github.io/2017/04/17/algorithm-3/</id>
    <published>2017-04-16T16:08:44.000Z</published>
    <updated>2017-04-16T16:11:19.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="Algorithm" scheme="http://suqun.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法之数据结构——链表]]></title>
    <link href="http://suqun.github.io/2017/04/03/algorithm-2/"/>
    <id>http://suqun.github.io/2017/04/03/algorithm-2/</id>
    <published>2017-04-03T11:09:59.000Z</published>
    <updated>2017-04-16T16:10:06.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5355_u94FE_u8868_u7684_u521B_u5EFA_u548C_u5220_u9664"><a href="#u5355_u94FE_u8868_u7684_u521B_u5EFA_u548C_u5220_u9664" class="headerlink" title="单链表的创建和删除"></a>单链表的创建和删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * LinkList java单向链表实现及基础操作</span><br><span class="line"> * Created by larry.su on 2017/4/3.</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 指向头结点</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 指向尾节点</span><br><span class="line">     * 需要根据尾节点操作时就不用每次都从头结点循环得到尾节点</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 添加元素到链表尾端</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> value 添加的数据</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToTail</span><span class="params">(E value)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//        if (null == first) &#123;</span></span><br><span class="line"><span class="comment">//            first = node;</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            Node pNode = first;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            while (null != pNode.next) &#123;</span></span><br><span class="line"><span class="comment">//                pNode = pNode.next;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            pNode.next = node;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == first) &#123;</span><br><span class="line">            first = node;</span><br><span class="line">            last = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last.next = node;</span><br><span class="line">            last = node;<span class="comment">//使用last 可以减少循环获取最后节点步骤</span></span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 删除第一个含有该值的节点</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> object</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != first) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.getValue().equals(object)) &#123;</span><br><span class="line">                first.next = <span class="keyword">null</span>;</span><br><span class="line">                first.value = <span class="keyword">null</span>;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Node preDeleteNode = first;<span class="comment">//待删除的前一个节点</span></span><br><span class="line">            Node deleteNode;<span class="comment">//待删除的节点</span></span><br><span class="line">            <span class="keyword">while</span> (preDeleteNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (preDeleteNode.next.getValue() == object) &#123;</span><br><span class="line">                    deleteNode = preDeleteNode.next;</span><br><span class="line">                    preDeleteNode.next = deleteNode.next;</span><br><span class="line">                    deleteNode.next = <span class="keyword">null</span>;</span><br><span class="line">                    deleteNode.value = <span class="keyword">null</span>;</span><br><span class="line">                    size--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    preDeleteNode = preDeleteNode.getNext();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@AllArgsConstructor</span></span><br><span class="line">    <span class="annotation">@ToString</span></span><br><span class="line">    <span class="annotation">@Data</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E value;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkList linkList = <span class="keyword">new</span> LinkList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            linkList.addToTail(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        linkList.remove(<span class="number">5</span>);</span><br><span class="line">        System.out.println(linkList);</span><br><span class="line">        linkList.remove(<span class="number">3</span>);</span><br><span class="line">        System.out.println(linkList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkList(size=<span class="number">6</span>, first=LinkList.Node(value=<span class="number">0</span>, next=LinkList.Node(value=<span class="number">1</span>, next=LinkList.Node(value=<span class="number">2</span>, next=LinkList.Node(value=<span class="number">3</span>, next=LinkList.Node(value=<span class="number">4</span>, next=<span class="keyword">null</span>))))), last=LinkList.Node(value=<span class="keyword">null</span>, next=<span class="keyword">null</span>))</span><br><span class="line">LinkList(size=<span class="number">6</span>, first=LinkList.Node(value=<span class="number">0</span>, next=LinkList.Node(value=<span class="number">1</span>, next=LinkList.Node(value=<span class="number">2</span>, next=LinkList.Node(value=<span class="number">4</span>, next=<span class="keyword">null</span>)))), last=LinkList.Node(value=<span class="keyword">null</span>, next=<span class="keyword">null</span>))</span><br></pre></td></tr></table></figure>
<h2 id="u4ECE_u5C3E_u5230_u5934_u6253_u5370_u5355_u94FE_u8868"><a href="#u4ECE_u5C3E_u5230_u5934_u6253_u5370_u5355_u94FE_u8868" class="headerlink" title="从尾到头打印单链表"></a>从尾到头打印单链表</h2><h3 id="u6808_u5B9E_u73B0"><a href="#u6808_u5B9E_u73B0" class="headerlink" title="栈实现"></a>栈实现</h3><p>遍历的顺序是从头到尾的顺序，输出的顺序是从尾到头，也就是说第一个遍历的节点最后一个输出，这个是典型的『后进先出』。可以使用栈实现这种顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * 使用栈的方式反向输出单链表</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> linkList 单向链表</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printListByStack</span><span class="params">(LinkList linkList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (linkList.first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            LinkList.Node node = linkList.first;</span><br><span class="line">            Stack&lt;LinkList.Node&gt; stack = <span class="keyword">new</span> Stack&lt;LinkList.Node&gt;();</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                LinkList.Node node2 = stack.pop();</span><br><span class="line">                System.out.print(node2.getValue() + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="u9012_u5F52_u5B9E_u73B0"><a href="#u9012_u5F52_u5B9E_u73B0" class="headerlink" title="递归实现"></a>递归实现</h3><p>既然想到了栈实现，而递归本质上也是个栈结构。要实现反过来输出链表，我们每访问到一个节点的时候，先递归输出他后面的节点，再输出该节点自身。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 递归方式反向输出单链表</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> node 单向链表中的节点</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printListByRecursion</span><span class="params">(LinkList.Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != node.next) &#123;</span><br><span class="line">            printListByRecursion(node.next);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(node.getValue() + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u533A_u522B"><a href="#u533A_u522B" class="headerlink" title="区别"></a>区别</h3><p>递归的代码看起来简洁，但是有个问题，当链表非常长的时候，就会导致函数调用层级很深，从而导致栈溢出。基于栈实现的代码鲁棒性更好一些。</p>
<p>我们来测试下两种方式的性能及异常，测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testProfile</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    LinkList linkList = <span class="keyword">new</span> LinkList();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        linkList.addToTail(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Profiler.begin();</span><br><span class="line">    printListByStack(linkList);</span><br><span class="line">    System.out.println(<span class="string">"========"</span>);</span><br><span class="line">    System.out.println(<span class="string">"Stack Cost: "</span> + Profiler.end() + <span class="string">" mills"</span>);</span><br><span class="line"></span><br><span class="line">    Profiler.begin();</span><br><span class="line">    printListByRecursion(linkList.first);</span><br><span class="line">    System.out.println(<span class="string">"========"</span>);</span><br><span class="line">    System.out.println(<span class="string">"Rescursion Cost: "</span> + Profiler.end() + <span class="string">" mills"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先测试下10000个节点的单链表反向输出，结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stack Cost: <span class="number">30</span> mills</span><br><span class="line">Rescursion Cost: <span class="number">47</span> mills</span><br></pre></td></tr></table></figure>
<p>再测试下50000个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack Cost: <span class="number">117</span> mills</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br></pre></td></tr></table></figure>
<p>可以看到，性能上使用栈反向输出要更好一些，当节点过多时，使用递归的方式会导致栈溢出。</p>
<h2 id="u5728O_281_29_u65F6_u95F4_u5220_u9664_u5355_u94FE_u8868_u8282_u70B9"><a href="#u5728O_281_29_u65F6_u95F4_u5220_u9664_u5355_u94FE_u8868_u8282_u70B9" class="headerlink" title="在O(1)时间删除单链表节点"></a>在O(1)时间删除单链表节点</h2><p><strong>给定单向链表的头节点和一个节点，定义一个函数在O(1)时间删除该节点。</strong></p>
<p>最常规的做法无疑是从链表的头结点开始，顺序遍历查找要删除的节点，并在链表中删除该节点。但是这种时间复杂度为O(n)。</p>
<p><strong>O(1)的解决方法为</strong>：把待删除节点（假设为C）的下一个节点（D）的内容复制到该节点上，覆盖原有的内容，然后将待删除的下一个节点（D）删除即可。</p>
<p>需要注意的是：（1）若待删除的节点为尾节点，则需要顺序遍历链表得到待删除节点的前序节点，然后删除尾节点；（2）若待删除的节点为头节点，则删除头节点。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * 在O(1)时间删除单链表节点</span><br><span class="line">    * <span class="doctag">@param</span> first 头节点</span><br><span class="line">    * <span class="doctag">@param</span> toBeDelete 待删除节点</span><br><span class="line">    * <span class="doctag">@return</span> 返回删除的节点内容</span><br><span class="line">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="function">String <span class="title">deleteNode</span><span class="params">(LinkList.Node first, LinkList.Node toBeDelete)</span> </span>&#123;</span><br><span class="line">       String returnValue = <span class="string">""</span>;</span><br><span class="line">       <span class="comment">//链表只有一个节点</span></span><br><span class="line">       <span class="keyword">if</span> (toBeDelete.next == first.next) &#123;</span><br><span class="line">           returnValue = first.value.toString();<span class="comment">//待删除节点的内容</span></span><br><span class="line">           first.value = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">return</span>  returnValue;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//待删除节点不是尾节点</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">null</span> != toBeDelete.next)&#123;</span><br><span class="line">           LinkList.Node toBeDeleteNext = toBeDelete.next;</span><br><span class="line">           toBeDelete.value = toBeDeleteNext.value;</span><br><span class="line">           toBeDelete.next = toBeDeleteNext.next;</span><br><span class="line"></span><br><span class="line">           returnValue = toBeDeleteNext.value.toString();<span class="comment">//待删除节点的下一个节点的内容</span></span><br><span class="line"></span><br><span class="line">           toBeDeleteNext.value = <span class="keyword">null</span>;</span><br><span class="line">           toBeDeleteNext.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span>  returnValue;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//待删除节点为尾节点(顺序遍历链表得到待删除节点的前序节点)</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">null</span> == toBeDelete.next)&#123;</span><br><span class="line">           LinkList.Node node = first;</span><br><span class="line">           <span class="keyword">while</span> (toBeDelete != node.next) &#123;</span><br><span class="line">               node = node.next;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           returnValue = toBeDelete.value.toString();<span class="comment">//待删除节点的内容</span></span><br><span class="line"></span><br><span class="line">           toBeDelete.value = <span class="keyword">null</span>;</span><br><span class="line">           node.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span>  returnValue;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>  returnValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>测试用例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNodeTheFirstNode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    LinkList linkList = generatorALinkList(<span class="number">1</span>);</span><br><span class="line">    DeleteNodeO1 deleteNode = <span class="keyword">new</span> DeleteNodeO1();</span><br><span class="line"></span><br><span class="line">    String returnValue = deleteNode.deleteNode(linkList.first,linkList.first);</span><br><span class="line"></span><br><span class="line">    Assert.assertEquals(<span class="string">"0"</span>,returnValue);<span class="comment">//删除的是头节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNodeTheLastNode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    LinkList linkList = generatorALinkList(<span class="number">9</span>);</span><br><span class="line">    DeleteNodeO1 deleteNode = <span class="keyword">new</span> DeleteNodeO1();</span><br><span class="line"></span><br><span class="line">    String returnValue = deleteNode.deleteNode(linkList.first,linkList.last);</span><br><span class="line"></span><br><span class="line">    Assert.assertEquals(<span class="string">"8"</span>,returnValue);<span class="comment">//删除的是尾节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNodeNotFirstAndLastNode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    LinkList linkList = generatorALinkList(<span class="number">9</span>);</span><br><span class="line">    DeleteNodeO1 deleteNode = <span class="keyword">new</span> DeleteNodeO1();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除第二个节点，将第三个节点内容（值为2）复制到第二个节点上，删除第三个节点</span></span><br><span class="line">    String returnValue = deleteNode.deleteNode(linkList.first,linkList.first.next);</span><br><span class="line"></span><br><span class="line">    Assert.assertEquals(<span class="string">"2"</span>,returnValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> LinkList <span class="title">generatorALinkList</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    LinkList linkList = <span class="keyword">new</span> LinkList();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        linkList.addToTail(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  linkList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u94FE_u8868_u4E2D_u5012_u6570_u7B2Ck_u4E2A_u8282_u70B9"><a href="#u94FE_u8868_u4E2D_u5012_u6570_u7B2Ck_u4E2A_u8282_u70B9" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h2><p><strong>输入一个链表，输出该链表中倒数第K个节点。从1开始计数，例如一个链表6个节点，从头到尾的顺序为1，2，3，4，5，6。这个链表的倒数第3个节点是值为4的节点。</strong></p>
<p>遍历2次的思路：第一次遍历获取整个链表的长度n，第二次遍历找到第k个节点n-k+1</p>
<p>遍历1次的思路：定义两个指针，第一个指针从链表头部开始遍历向前走k-1时，第二个指针不动；从第K步开始，第二个指针开始从链表头部遍历。两个指针距离保持在K-1，当第一个指针走到尾部的时候，第二个指针正好是倒数第K个节点。</p>
<p>一次遍历的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LinkList.<span class="function">Node <span class="title">findNodeToTail</span><span class="params">(LinkList linkList, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == linkList || <span class="keyword">null</span> == linkList.first || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkList.Node ahead = linkList.first;</span><br><span class="line">        LinkList.Node behind = linkList.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ahead.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ahead = ahead.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ahead.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ahead = ahead.next;</span><br><span class="line">            behind = behind.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> behind;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>单元测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findNodeToTail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">//正常情况下，6个节点，倒数第3个</span></span><br><span class="line">    FindToTail findToTail = <span class="keyword">new</span> FindToTail();</span><br><span class="line">    LinkList linkList = generatorALinkList(<span class="number">6</span>);</span><br><span class="line">    LinkList.Node node = findToTail.findNodeToTail(linkList,<span class="number">3</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">3</span>,node.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findNodeToTailKEqual0</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">//k等于0</span></span><br><span class="line">    FindToTail findToTail = <span class="keyword">new</span> FindToTail();</span><br><span class="line">    LinkList linkList = generatorALinkList(<span class="number">6</span>);</span><br><span class="line">    LinkList.Node node = findToTail.findNodeToTail(linkList,<span class="number">0</span>);</span><br><span class="line">    Assert.assertEquals(<span class="keyword">null</span>,node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findNodeToTailListIsNull</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">//单向链表null</span></span><br><span class="line">    FindToTail findToTail = <span class="keyword">new</span> FindToTail();</span><br><span class="line">    LinkList.Node node = findToTail.findNodeToTail(<span class="keyword">null</span>,<span class="number">1</span>);</span><br><span class="line">    Assert.assertEquals(<span class="keyword">null</span>,node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findNodeToTailListSize0</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">//只有头结点</span></span><br><span class="line">    FindToTail findToTail = <span class="keyword">new</span> FindToTail();</span><br><span class="line">    LinkList linkList =  generatorALinkList(<span class="number">1</span>);</span><br><span class="line">    LinkList.Node node = findToTail.findNodeToTail(linkList,<span class="number">8</span>);<span class="comment">//链表节点总数少于k</span></span><br><span class="line">    Assert.assertEquals(<span class="keyword">null</span>,node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u53CD_u8F6C_u94FE_u8868"><a href="#u53CD_u8F6C_u94FE_u8868" class="headerlink" title="反转链表"></a>反转链表</h2><p><strong>定义一个函数，输入一个链表的头结点，反转链表并输出反转后链表的头结点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LinkList.<span class="function">Node <span class="title">reverseAndPrintHead</span><span class="params">(LinkList.Node first)</span> </span>&#123;</span><br><span class="line">    LinkList.Node reverseHead = <span class="keyword">null</span>;</span><br><span class="line">    LinkList.Node node = first;<span class="comment">//当前结点</span></span><br><span class="line">    LinkList.Node prevNode = <span class="keyword">null</span>;<span class="comment">//当前结点的前结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LinkList.Node nextNode = node.next;<span class="comment">//当前结点的后结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            reverseHead = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.next = prevNode;<span class="comment">//反转</span></span><br><span class="line">            nextNode.next = node;<span class="comment">//反转</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = nextNode;<span class="comment">//下一个循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reverseHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单元测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseAndPrintHead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ReverseList reverse = <span class="keyword">new</span> ReverseList();</span><br><span class="line">    <span class="comment">//链表有多个结点</span></span><br><span class="line">    LinkList.Node node = reverse</span><br><span class="line">            .reverseAndPrintHead(generatorALinkList(<span class="number">6</span>).first);</span><br><span class="line">    Assert.assertEquals(<span class="number">5</span>,node.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseAndPrintHead1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ReverseList reverse = <span class="keyword">new</span> ReverseList();</span><br><span class="line">    <span class="comment">//链表头节点为null</span></span><br><span class="line">    LinkList.Node node = reverse</span><br><span class="line">            .reverseAndPrintHead(generatorALinkList(<span class="number">0</span>).first);</span><br><span class="line">    Assert.assertEquals(<span class="keyword">null</span>,node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseAndPrintHead2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ReverseList reverse = <span class="keyword">new</span> ReverseList();</span><br><span class="line">    <span class="comment">//链表只有一个节点</span></span><br><span class="line">    LinkList.Node node = reverse</span><br><span class="line">            .reverseAndPrintHead(generatorALinkList(<span class="number">1</span>).first);</span><br><span class="line">    Assert.assertEquals(<span class="number">0</span>,node.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u5408_u5E76_u4E24_u4E2A_u6709_u5E8F_u7684_u94FE_u8868"><a href="#u5408_u5E76_u4E24_u4E2A_u6709_u5E8F_u7684_u94FE_u8868" class="headerlink" title="合并两个有序的链表"></a>合并两个有序的链表</h2><p><strong>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然按照递增顺序排序。</strong></p>
<p>首先定义一个合并列表M，然后同时遍历2个链表L1,L2，比较相同位置结点（P1，P2）值大小，将小的节点（假设P1&lt;P2,则P1）合并到M，然后将P1的下一个节点P1.next和P2节点值比较，重复上述步骤直到某个链表结束，另外一个链表多余的直接合并到M。</p>
<p>合并的时候，注意特殊情况：</p>
<ul>
<li>L1空，直接返回L2</li>
<li>L2空，直接返回L1</li>
<li>L1，L2都空，返回空</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u5355_u94FE_u8868_u7684_u521B_u5EFA_u548C_u5220_u9664"><a href="#u5355_u94FE_u8868_u7684_u521B_u5EFA_u548C_u5220_u9664" class="headerlink" title="单链表的创建和删除"></a>单链表的创建和删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * LinkList java单向链表实现及基础操作</span><br><span class="line"> * Created by larry.su on 2017/4/3.</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 指向头结点</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 指向尾节点</span><br><span class="line">     * 需要根据尾节点操作时就不用每次都从头结点循环得到尾节点</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 添加元素到链表尾端</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> value 添加的数据</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToTail</span><span class="params">(E value)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//        if (null == first) &#123;</span></span><br><span class="line"><span class="comment">//            first = node;</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            Node pNode = first;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            while (null != pNode.next) &#123;</span></span><br><span class="line"><span class="comment">//                pNode = pNode.next;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            pNode.next = node;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == first) &#123;</span><br><span class="line">            first = node;</span><br><span class="line">            last = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last.next = node;</span><br><span class="line">            last = node;<span class="comment">//使用last 可以减少循环获取最后节点步骤</span></span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 删除第一个含有该值的节点</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> object</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != first) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.getValue().equals(object)) &#123;</span><br><span class="line">                first.next = <span class="keyword">null</span>;</span><br><span class="line">                first.value = <span class="keyword">null</span>;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Node preDeleteNode = first;<span class="comment">//待删除的前一个节点</span></span><br><span class="line">            Node deleteNode;<span class="comment">//待删除的节点</span></span><br><span class="line">            <span class="keyword">while</span> (preDeleteNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (preDeleteNode.next.getValue() == object) &#123;</span><br><span class="line">                    deleteNode = preDeleteNode.next;</span><br><span class="line">                    preDeleteNode.next = deleteNode.next;</span><br><span class="line">                    deleteNode.next = <span class="keyword">null</span>;</span><br><span class="line">                    deleteNode.value = <span class="keyword">null</span>;</span><br><span class="line">                    size--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    preDeleteNode = preDeleteNode.getNext();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@AllArgsConstructor</span></span><br><span class="line">    <span class="annotation">@ToString</span></span><br><span class="line">    <span class="annotation">@Data</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E value;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkList linkList = <span class="keyword">new</span> LinkList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            linkList.addToTail(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        linkList.remove(<span class="number">5</span>);</span><br><span class="line">        System.out.println(linkList);</span><br><span class="line">        linkList.remove(<span class="number">3</span>);</span><br><span class="line">        System.out.println(linkList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://suqun.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法之数据结构——数组]]></title>
    <link href="http://suqun.github.io/2017/03/22/algorithm-1/"/>
    <id>http://suqun.github.io/2017/03/22/algorithm-1/</id>
    <published>2017-03-22T02:25:07.000Z</published>
    <updated>2017-04-16T16:11:06.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u4E8C_u7EF4_u6570_u7EC4_u4E2D_u7684_u67E5_u627E"><a href="#u4E8C_u7EF4_u6570_u7EC4_u4E2D_u7684_u67E5_u627E" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p>在一个二维数组中，每一行按照从左到右递增顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h3 id="u89E3_u51B3_u65B9_u6CD5"><a href="#u89E3_u51B3_u65B9_u6CD5" class="headerlink" title="解决方法"></a>解决方法</h3><p>当我们要解决一个复杂的问题时，一个很有效的方法就是从一个具体的问题入手，通过分析简单的例子，试图寻找普遍的规律。</p>
<p><strong>具体的🌰</strong>：例如下面的数组就是每行每列递增排序。如果在这个数组中查找到数字7则返回true；如果查找数字5，则返回false。</p>
<p><strong>解决方法</strong>：从数组的一个角上选取数字来和要查找的数字做比较。情况会变的简单</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/algoritm-array-1.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumberExist</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> columns, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arrays = generalArray();</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> column = columns-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (column &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrays[row][column] &gt; number) &#123;</span><br><span class="line">            column--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arrays[row][column] &lt; number) &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] generalArray() &#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arrays = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span>&#125;, &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arrays;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4E8C_u7EF4_u6570_u7EC4_u4E2D_u7684_u67E5_u627E"><a href="#u4E8C_u7EF4_u6570_u7EC4_u4E2D_u7684_u67E5_u627E" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p>在一个二维数组中，每一行按照从左到右递增顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h3 id="u89E3_u51B3_u65B9_u6CD5"><a href="#u89E3_u51B3_u65B9_u6CD5" class="headerlink" title="解决方法"></a>解决方法</h3><p>当我们要解决一个复杂的问题时，一个很有效的方法就是从一个具体的问题入手，通过分析简单的例子，试图寻找普遍的规律。</p>
<p><strong>具体的🌰</strong>：例如下面的数组就是每行每列递增排序。如果在这个数组中查找到数字7则返回true；如果查找数字5，则返回false。</p>
<p><strong>解决方法</strong>：从数组的一个角上选取数字来和要查找的数字做比较。情况会变的简单</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/algoritm-array-1.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumberExist</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> columns, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arrays = generalArray();</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> column = columns-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (column &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrays[row][column] &gt; number) &#123;</span><br><span class="line">            column--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arrays[row][column] &lt; number) &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] generalArray() &#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arrays = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span>&#125;, &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arrays;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://suqun.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM笔记八：Sun JDK监控和故障处理工具]]></title>
    <link href="http://suqun.github.io/2017/03/08/JVM-note-8/"/>
    <id>http://suqun.github.io/2017/03/08/JVM-note-8/</id>
    <published>2017-03-08T14:14:36.000Z</published>
    <updated>2017-04-06T02:56:22.000Z</updated>
    <content type="html"><![CDATA[<p>Sun JDK监控和故障处理工具:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:center">主要作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>jps</td>
<td style="text-align:center">JVM Process Status Tool，显示指定系统内所有HotSpot虚拟机进程</td>
</tr>
<tr>
<td>jstat</td>
<td style="text-align:center">JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面的运行数据</td>
</tr>
<tr>
<td>jinfo</td>
<td style="text-align:center">Configuration Info for Java，显示虚拟机配置信息</td>
</tr>
<tr>
<td>jmap</td>
<td style="text-align:center">Memory Map for Java,生成虚拟机的内存转出快照(heapdump)文件</td>
</tr>
<tr>
<td>jhat</td>
<td style="text-align:center">JVM Heap Dump Browser,用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户在浏览器上查看分析结果</td>
</tr>
<tr>
<td>jstack</td>
<td style="text-align:center">Stack Trace for Java,显示虚拟机的线程快照</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="jps_3A_u865A_u62DF_u673A_u7EBF_u7A0B_u72B6_u51B5_u5DE5_u5177"><a href="#jps_3A_u865A_u62DF_u673A_u7EBF_u7A0B_u72B6_u51B5_u5DE5_u5177" class="headerlink" title="jps:虚拟机线程状况工具"></a>jps:虚拟机线程状况工具</h2><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-jps-1.png" alt=""></p>
<h2 id="jstat_3A_u865A_u62DF_u673A_u7EDF_u8BA1_u4FE1_u606F_u76D1_u89C6_u5DE5_u5177"><a href="#jstat_3A_u865A_u62DF_u673A_u7EDF_u8BA1_u4FE1_u606F_u76D1_u89C6_u5DE5_u5177" class="headerlink" title="jstat:虚拟机统计信息监视工具"></a>jstat:虚拟机统计信息监视工具</h2><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-jstat.png" alt=""></p>
<p>🌰 查看线程51710线程垃圾收集情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ jstat -gc <span class="number">51710</span> <span class="number">250</span> <span class="number">5</span></span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"><span class="number">24576.0</span> <span class="number">46592.0</span> <span class="number">24077.9</span>  <span class="number">0.0</span>   <span class="number">773632.0</span> <span class="number">109440.9</span>  <span class="number">139776.0</span>   <span class="number">50009.5</span>   <span class="number">34560.0</span> <span class="number">33710.1</span> <span class="number">4096.0</span> <span class="number">3911.8</span>     <span class="number">10</span>    <span class="number">0.191</span>   <span class="number">1</span>      <span class="number">0.052</span>    <span class="number">0.243</span></span><br><span class="line"><span class="number">24576.0</span> <span class="number">46592.0</span> <span class="number">24077.9</span>  <span class="number">0.0</span>   <span class="number">773632.0</span> <span class="number">109440.9</span>  <span class="number">139776.0</span>   <span class="number">50009.5</span>   <span class="number">34560.0</span> <span class="number">33710.1</span> <span class="number">4096.0</span> <span class="number">3911.8</span>     <span class="number">10</span>    <span class="number">0.191</span>   <span class="number">1</span>      <span class="number">0.052</span>    <span class="number">0.243</span></span><br><span class="line"><span class="number">24576.0</span> <span class="number">46592.0</span> <span class="number">24077.9</span>  <span class="number">0.0</span>   <span class="number">773632.0</span> <span class="number">109440.9</span>  <span class="number">139776.0</span>   <span class="number">50009.5</span>   <span class="number">34560.0</span> <span class="number">33710.1</span> <span class="number">4096.0</span> <span class="number">3911.8</span>     <span class="number">10</span>    <span class="number">0.191</span>   <span class="number">1</span>      <span class="number">0.052</span>    <span class="number">0.243</span></span><br><span class="line"><span class="number">24576.0</span> <span class="number">46592.0</span> <span class="number">24077.9</span>  <span class="number">0.0</span>   <span class="number">773632.0</span> <span class="number">109440.9</span>  <span class="number">139776.0</span>   <span class="number">50009.5</span>   <span class="number">34560.0</span> <span class="number">33710.1</span> <span class="number">4096.0</span> <span class="number">3911.8</span>     <span class="number">10</span>    <span class="number">0.191</span>   <span class="number">1</span>      <span class="number">0.052</span>    <span class="number">0.243</span></span><br><span class="line"><span class="number">24576.0</span> <span class="number">46592.0</span> <span class="number">24077.9</span>  <span class="number">0.0</span>   <span class="number">773632.0</span> <span class="number">109440.9</span>  <span class="number">139776.0</span>   <span class="number">50009.5</span>   <span class="number">34560.0</span> <span class="number">33710.1</span> <span class="number">4096.0</span> <span class="number">3911.8</span>     <span class="number">10</span>    <span class="number">0.191</span>   <span class="number">1</span>      <span class="number">0.052</span>    <span class="number">0.243</span></span><br><span class="line">➜  ~ jstat -gcutil <span class="number">51710</span> <span class="number">250</span> <span class="number">5</span></span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"> <span class="number">97.97</span>   <span class="number">0.00</span>  <span class="number">14.15</span>  <span class="number">35.78</span>  <span class="number">97.54</span>  <span class="number">95.50</span>     <span class="number">10</span>    <span class="number">0.191</span>     <span class="number">1</span>    <span class="number">0.052</span>    <span class="number">0.243</span></span><br><span class="line"> <span class="number">97.97</span>   <span class="number">0.00</span>  <span class="number">14.15</span>  <span class="number">35.78</span>  <span class="number">97.54</span>  <span class="number">95.50</span>     <span class="number">10</span>    <span class="number">0.191</span>     <span class="number">1</span>    <span class="number">0.052</span>    <span class="number">0.243</span></span><br><span class="line"> <span class="number">97.97</span>   <span class="number">0.00</span>  <span class="number">14.15</span>  <span class="number">35.78</span>  <span class="number">97.54</span>  <span class="number">95.50</span>     <span class="number">10</span>    <span class="number">0.191</span>     <span class="number">1</span>    <span class="number">0.052</span>    <span class="number">0.243</span></span><br><span class="line"> <span class="number">97.97</span>   <span class="number">0.00</span>  <span class="number">14.15</span>  <span class="number">35.78</span>  <span class="number">97.54</span>  <span class="number">95.50</span>     <span class="number">10</span>    <span class="number">0.191</span>     <span class="number">1</span>    <span class="number">0.052</span>    <span class="number">0.243</span></span><br><span class="line"> <span class="number">97.97</span>   <span class="number">0.00</span>  <span class="number">14.15</span>  <span class="number">35.78</span>  <span class="number">97.54</span>  <span class="number">95.50</span>     <span class="number">10</span>    <span class="number">0.191</span>     <span class="number">1</span>    <span class="number">0.052</span>    <span class="number">0.243</span></span><br><span class="line">➜  ~ jstat -gccause <span class="number">51710</span> <span class="number">250</span> <span class="number">5</span></span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC</span><br><span class="line"> <span class="number">97.97</span>   <span class="number">0.00</span>  <span class="number">15.15</span>  <span class="number">35.78</span>  <span class="number">97.54</span>  <span class="number">95.50</span>     <span class="number">10</span>    <span class="number">0.191</span>     <span class="number">1</span>    <span class="number">0.052</span>    <span class="number">0.243</span> Allocation Failure   No GC</span><br><span class="line"> <span class="number">97.97</span>   <span class="number">0.00</span>  <span class="number">15.15</span>  <span class="number">35.78</span>  <span class="number">97.54</span>  <span class="number">95.50</span>     <span class="number">10</span>    <span class="number">0.191</span>     <span class="number">1</span>    <span class="number">0.052</span>    <span class="number">0.243</span> Allocation Failure   No GC</span><br><span class="line"> <span class="number">97.97</span>   <span class="number">0.00</span>  <span class="number">15.15</span>  <span class="number">35.78</span>  <span class="number">97.54</span>  <span class="number">95.50</span>     <span class="number">10</span>    <span class="number">0.191</span>     <span class="number">1</span>    <span class="number">0.052</span>    <span class="number">0.243</span> Allocation Failure   No GC</span><br><span class="line"> <span class="number">97.97</span>   <span class="number">0.00</span>  <span class="number">15.15</span>  <span class="number">35.78</span>  <span class="number">97.54</span>  <span class="number">95.50</span>     <span class="number">10</span>    <span class="number">0.191</span>     <span class="number">1</span>    <span class="number">0.052</span>    <span class="number">0.243</span> Allocation Failure   No GC</span><br><span class="line"> <span class="number">97.97</span>   <span class="number">0.00</span>  <span class="number">15.15</span>  <span class="number">35.78</span>  <span class="number">97.54</span>  <span class="number">95.50</span>     <span class="number">10</span>    <span class="number">0.191</span>     <span class="number">1</span>    <span class="number">0.052</span>    <span class="number">0.243</span> Allocation Failure   No GC</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>列</th>
<th>说明</th>
<th>jstat参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>S0C</td>
<td>输出Survivor0空间的大小,单位KB</td>
<td>-gc<br>-gccapacity<br>-gcnew<br>-gcnewcapacity</td>
</tr>
<tr>
<td>S1C</td>
<td>输出Survivor1空间的大小。单位KB</td>
<td>-gc<br> -gccapacity <br>-gcnew <br>-gcnewcapacity</td>
</tr>
<tr>
<td>S0U</td>
<td>输出Survivor0已用空间的大小。单位KB</td>
<td>-gc<br> -gcnew</td>
</tr>
<tr>
<td>S1U</td>
<td>输出Survivor1已用空间的大小。单位KB</td>
<td>-gc<br>-gcnew</td>
</tr>
<tr>
<td>EC</td>
<td>输出Eden空间的大小。单位KB。</td>
<td>-gc<br> -gccapacity <br>-gcnew <br>-gcnewcapacity</td>
</tr>
<tr>
<td>EU</td>
<td>输出Eden已用空间的大小。单位KB</td>
<td>-gc<br> -gcnew</td>
</tr>
<tr>
<td>OC</td>
<td>输出老年代空间的大小。单位KB</td>
<td>-gc <br>-gccapacity <br>-gcold <br>-gcoldcapacity</td>
</tr>
<tr>
<td>OU</td>
<td>输出老年代已用空间的大小。单位KB</td>
<td>-gc <br>-gcold</td>
</tr>
<tr>
<td>PC</td>
<td>输出持久代空间的大小。单位KB</td>
<td>-gc <br>-gccapacity <br>-gcold <br>-gcoldcapacity <br>-gcpermcapacity</td>
</tr>
<tr>
<td>PU</td>
<td>输出持久代已用空间的大小。单位KB</td>
<td>-gc <br>-gcold</td>
</tr>
<tr>
<td>YGC</td>
<td>新生代空间GC时间发生的次数</td>
<td>-gc <br>-gccapacity <br>-gcnew <br>-gcnewcapacity <br>-gcold <br>-gcoldcapacity <br>-gcpermcapacity <br>-gcutil <br>-gccause</td>
</tr>
<tr>
<td>YGCT</td>
<td>新生代GC处理花费的时间。</td>
<td><br>-gc <br>-gcnew <br>-gcutil <br>-gccause</td>
</tr>
<tr>
<td>FGC</td>
<td>full GC发生的次数。</td>
<td>-gc <br>-gccapacity <br>-gcnew <br>-gcnewcapacity <br>-gcold <br>-gcoldcapacity <br>-gcpermcapacity <br>-gcutil <br>-gccause</td>
</tr>
<tr>
<td>FGCT</td>
<td>full GC操作花费的时间</td>
<td>-gc <br>-gcold <br>-gcoldcapacity <br>-gcpermcapacity <br>-gcutil <br>-gccause</td>
</tr>
<tr>
<td>GCT</td>
<td>GC操作花费的总时间。</td>
<td>-gc <br>-gcold <br>-gcoldcapacity <br>-gcpermcapacity <br>-gcutil <br>-gccause</td>
</tr>
<tr>
<td>NGCMN</td>
<td>新生代最小空间容量，单位KB</td>
<td>-gccapacity <br>-gcnewcapacity</td>
</tr>
<tr>
<td>NGCMX</td>
<td>新生代最大空间容量，单位KB</td>
<td>-gccapacity <br>-gcnewcapacity</td>
</tr>
<tr>
<td>NGC</td>
<td>新生代当前空间容量，单位KB</td>
<td>-gccapacity <br>-gcnewcapacity</td>
</tr>
<tr>
<td>OGCMN</td>
<td>老年代最小空间容量，单位KB</td>
<td>-gccapacity <br>-gcoldcapacity</td>
</tr>
<tr>
<td>OGCMX</td>
<td>老年代最大空间容量，单位KB</td>
<td>-gccapacity <br>-gcoldcapacity</td>
</tr>
<tr>
<td>OGC</td>
<td>老年代当前空间容量制，单位KB</td>
<td>-gccapacity <br>-gcoldcapacity</td>
</tr>
<tr>
<td>PGCMN</td>
<td>持久代最小空间容量，单位KB</td>
<td>-gccapacity <br>-gcpermcapacity</td>
</tr>
<tr>
<td>PGCMX</td>
<td>持久代最大空间容量，单位KB</td>
<td>-gccapacity <br>-gcpermcapacity</td>
</tr>
<tr>
<td>PGC</td>
<td>持久代当前空间容量，单位KB</td>
<td>-gccapacity <br>-gcpermcapacity</td>
</tr>
<tr>
<td>PC</td>
<td>持久代当前空间大小，单位KB</td>
<td>-gccapacity<br>-gcpermcapacity</td>
</tr>
<tr>
<td>PU</td>
<td>持久代当前已用空间大小，单位KB</td>
<td>-gc<br>-gcold</td>
</tr>
<tr>
<td>LGCC</td>
<td>最后一次GC发生的原因</td>
<td>-gccause</td>
</tr>
<tr>
<td>GCC</td>
<td>当前GC发生的原因</td>
<td>-gccause</td>
</tr>
<tr>
<td>TT</td>
<td>老年化阈值。被移动到老年代之前，在新生代空存活的次数。</td>
<td>-gcnew</td>
</tr>
<tr>
<td>MTT</td>
<td>最大老年化阈值。被移动到老年代之前，在新生代空存活的次数。</td>
<td>-gcnew</td>
</tr>
<tr>
<td>DSS</td>
<td>幸存者区所需空间大小，单位KB</td>
<td>-gcnew</td>
</tr>
</tbody>
</table>
<h2 id="jinfo_uFF1AJava_u914D_u7F6E_u4FE1_u606F_u5DE5_u5177"><a href="#jinfo_uFF1AJava_u914D_u7F6E_u4FE1_u606F_u5DE5_u5177" class="headerlink" title="jinfo：Java配置信息工具"></a>jinfo：Java配置信息工具</h2><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-jinfo-1.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ jinfo -flag CICompilerCount  <span class="number">51710</span></span><br><span class="line">-XX:CICompilerCount=<span class="number">4</span></span><br><span class="line"></span><br><span class="line">➜  ~ jinfo -sysprops <span class="number">51710</span></span><br><span class="line">Attaching to process ID <span class="number">51710</span>, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is <span class="number">25.65</span>-b01</span><br><span class="line">java.vendor = Oracle CorporationUnnamed_LJS-<span class="number">2</span></span><br><span class="line">sun.management.compiler = HotSpot <span class="number">64</span>-Bit Tiered Compilers</span><br><span class="line">catalina.useNaming = <span class="literal">true</span></span><br><span class="line">os.name = Mac OS X</span><br><span class="line">...</span><br><span class="line">java.vm.name = Java HotSpot(TM) <span class="number">64</span>-Bit Server VM</span><br><span class="line">file.encoding = US-ASCII</span><br><span class="line">java.specification.version = <span class="number">1.8</span></span><br></pre></td></tr></table></figure>
<h2 id="jmap_uFF1AJava_u5185_u5B58_u6620_u50CF_u5DE5_u5177"><a href="#jmap_uFF1AJava_u5185_u5B58_u6620_u50CF_u5DE5_u5177" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h2><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-jmap.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ jmap -dump:format=b,file=idea.bin <span class="number">51710</span></span><br><span class="line">Dumping heap to /Users/larry/idea.bin ...</span><br><span class="line">Heap dump file created</span><br><span class="line"></span><br><span class="line">➜  ~ jmap -heap <span class="number">51710</span></span><br><span class="line">...</span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with <span class="number">8</span> thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   M<span class="keyword">in</span>HeapFreeRatio         = <span class="number">0</span></span><br><span class="line">   MaxHeapFreeRatio         = <span class="number">100</span></span><br><span class="line">   MaxHeapSize              = <span class="number">4294967296</span> (<span class="number">4096.0</span>MB)</span><br><span class="line">   NewSize                  = <span class="number">89128960</span> (<span class="number">85.0</span>MB)</span><br><span class="line">   MaxNewSize               = <span class="number">1431306240</span> (<span class="number">1365.0</span>MB)</span><br><span class="line">   OldSize                  = <span class="number">179306496</span> (<span class="number">171.0</span>MB)</span><br><span class="line">   NewRatio                 = <span class="number">2</span></span><br><span class="line">   SurvivorRatio            = <span class="number">8</span></span><br><span class="line">   MetaspaceSize            = <span class="number">21807104</span> (<span class="number">20.796875</span>MB)</span><br><span class="line">   CompressedClassSpaceSize = <span class="number">1073741824</span> (<span class="number">1024.0</span>MB)</span><br><span class="line">   MaxMetaspaceSize         = <span class="number">17592186044415</span> MB</span><br><span class="line">   G1HeapRegionSize         = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = <span class="number">819462144</span> (<span class="number">781.5</span>MB)</span><br><span class="line">   used     = <span class="number">155157104</span> (<span class="number">147.96934509277344</span>MB)</span><br><span class="line">   free     = <span class="number">664305040</span> (<span class="number">633.5306549072266</span>MB)</span><br><span class="line">   <span class="number">18.93401728634337</span>% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = <span class="number">47710208</span> (<span class="number">45.5</span>MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line">   free     = <span class="number">47710208</span> (<span class="number">45.5</span>MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = <span class="number">49283072</span> (<span class="number">47.0</span>MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line">   free     = <span class="number">49283072</span> (<span class="number">47.0</span>MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = <span class="number">131072000</span> (<span class="number">125.0</span>MB)</span><br><span class="line">   used     = <span class="number">30525568</span> (<span class="number">29.1114501953125</span>MB)</span><br><span class="line">   free     = <span class="number">100546432</span> (<span class="number">95.8885498046875</span>MB)</span><br><span class="line">   <span class="number">23.28916015625</span>% used</span><br><span class="line"></span><br><span class="line"><span class="number">18359</span> interned Strings occupying <span class="number">2261944</span> bytes.</span><br></pre></td></tr></table></figure>
<h2 id="jhat_uFF1A_u865A_u62DF_u673A_u5806_u8F6C_u50A8_u5FEB_u7167_u5206_u6790_u5DE5_u5177"><a href="#jhat_uFF1A_u865A_u62DF_u673A_u5806_u8F6C_u50A8_u5FEB_u7167_u5206_u6790_u5DE5_u5177" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h2><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-jhat.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ jhat idea.bin</span><br><span class="line">Reading from idea.bin...</span><br><span class="line">Dump file created Mon Mar <span class="number">13</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">15</span> CST <span class="number">2017</span></span><br><span class="line">Snapshot <span class="built_in">read</span>, resolving...</span><br><span class="line">Resolving <span class="number">968447</span> objects...</span><br><span class="line">Chasing references, expect <span class="number">193</span> dots.................................................................................................................................................................................................</span><br><span class="line">Eliminating duplicate references.................................................................................................................................................................................................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port <span class="number">7000</span></span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure>
<p>分析结果默认是以包为单位进行分组显示，分析内存漏洞问题主要会用到其中的『Heap Histogram』（与jmap -histo功能一样）与OQL页签的功能。</p>
<h2 id="jstack_uFF1AJava_u5806_u6808_u8DDF_u8E2A_u5DE5_u5177"><a href="#jstack_uFF1AJava_u5806_u6808_u8DDF_u8E2A_u5DE5_u5177" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h2><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-jstack-1.png" alt="Java堆栈跟踪工具"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">➜ </span><br><span class="line">jstack <span class="operator">-l</span> <span class="number">72980</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">11</span>:<span class="number">16</span>:<span class="number">49</span></span><br><span class="line">Full thread dump Java HotSpot(TM) <span class="number">64</span>-Bit Server VM (<span class="number">25.65</span>-b01 mixed mode):</span><br><span class="line"></span><br><span class="line"><span class="string">"Attach Listener"</span> <span class="comment">#52 daemon prio=9 os_prio=31 tid=0x00007fc9ae8bc800 nid=0x9303 waiting on condition [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br><span class="line"></span><br><span class="line"><span class="string">"http-nio-8080-exec-7"</span> <span class="comment">#51 daemon prio=5 os_prio=31 tid=0x00007fc9cc1ac000 nid=0x9103 waiting on condition [0x0000700005057000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to <span class="built_in">wait</span> <span class="keyword">for</span>  &lt;<span class="number">0</span>x00000006c0913a10&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer<span class="variable">$ConditionObject</span>)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span class="number">175</span>)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer<span class="variable">$ConditionObject</span>.await(AbstractQueuedSynchronizer.java:<span class="number">2039</span>)</span><br><span class="line">        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:<span class="number">442</span>)</span><br><span class="line">        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:<span class="number">103</span>)</span><br><span class="line">        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:<span class="number">31</span>)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:<span class="number">1067</span>)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1127</span>)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:<span class="number">617</span>)</span><br><span class="line">        at org.apache.tomcat.util.threads.TaskThread<span class="variable">$WrappingRunnable</span>.run(TaskThread.java:<span class="number">61</span>)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>Sun JDK监控和故障处理工具:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:center">主要作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>jps</td>
<td style="text-align:center">JVM Process Status Tool，显示指定系统内所有HotSpot虚拟机进程</td>
</tr>
<tr>
<td>jstat</td>
<td style="text-align:center">JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面的运行数据</td>
</tr>
<tr>
<td>jinfo</td>
<td style="text-align:center">Configuration Info for Java，显示虚拟机配置信息</td>
</tr>
<tr>
<td>jmap</td>
<td style="text-align:center">Memory Map for Java,生成虚拟机的内存转出快照(heapdump)文件</td>
</tr>
<tr>
<td>jhat</td>
<td style="text-align:center">JVM Heap Dump Browser,用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户在浏览器上查看分析结果</td>
</tr>
<tr>
<td>jstack</td>
<td style="text-align:center">Stack Trace for Java,显示虚拟机的线程快照</td>
</tr>
</tbody>
</table>]]>
    
    </summary>
    
      <category term="JVM" scheme="http://suqun.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM笔记七：垃圾收集器与内存分配策略——内存分配与回收策略]]></title>
    <link href="http://suqun.github.io/2017/02/21/JVM-note-7/"/>
    <id>http://suqun.github.io/2017/02/21/JVM-note-7/</id>
    <published>2017-02-21T02:31:45.000Z</published>
    <updated>2017-04-06T02:56:13.000Z</updated>
    <content type="html"><![CDATA[<p>对象的内存分配，往大方向讲，就是在堆上分配（也可能经过JIT编译后被拆散为标量类型并间接的在栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下分配在老生代上，分配的规则并不是百分百固定的，其细节取决于当前使用的哪种垃圾收集器组合，还有虚拟机内存相关参数的设置。</p>
<h2 id="u5BF9_u8C61_u4F18_u5148_u5728Eden_u533A_u5206_u914D"><a href="#u5BF9_u8C61_u4F18_u5148_u5728Eden_u533A_u5206_u914D" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h2><p>上一篇垃圾收集器的GC示例已经把各个收集器的内存分配测试做了一遍，可以回顾上篇内容。</p>
<a id="more"></a>
<h2 id="u5927_u5BF9_u8C61_u76F4_u63A5_u8FDB_u5165_u8001_u5E74_u4EE3"><a href="#u5927_u5BF9_u8C61_u76F4_u63A5_u8FDB_u5165_u8001_u5E74_u4EE3" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><h2 id="u957F_u671F_u5B58_u6D3B_u7684_u5BF9_u8C61_u5C06_u8FDB_u5165_u8001_u5E74_u4EE3"><a href="#u957F_u671F_u5B58_u6D3B_u7684_u5BF9_u8C61_u5C06_u8FDB_u5165_u8001_u5E74_u4EE3" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><h2 id="u52A8_u6001_u5BF9_u8C61_u5E74_u9F84_u5224_u5B9A"><a href="#u52A8_u6001_u5BF9_u8C61_u5E74_u9F84_u5224_u5B9A" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><h2 id="u7A7A_u95F4_u5206_u914D_u62C5_u4FDD"><a href="#u7A7A_u95F4_u5206_u914D_u62C5_u4FDD" class="headerlink" title="空间分配担保"></a>空间分配担保</h2>]]></content>
    <summary type="html">
    <![CDATA[<p>对象的内存分配，往大方向讲，就是在堆上分配（也可能经过JIT编译后被拆散为标量类型并间接的在栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下分配在老生代上，分配的规则并不是百分百固定的，其细节取决于当前使用的哪种垃圾收集器组合，还有虚拟机内存相关参数的设置。</p>
<h2 id="u5BF9_u8C61_u4F18_u5148_u5728Eden_u533A_u5206_u914D"><a href="#u5BF9_u8C61_u4F18_u5148_u5728Eden_u533A_u5206_u914D" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h2><p>上一篇垃圾收集器的GC示例已经把各个收集器的内存分配测试做了一遍，可以回顾上篇内容。</p>]]>
    
    </summary>
    
      <category term="JVM" scheme="http://suqun.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM笔记六：垃圾收集器与内存分配策略——垃圾收集器]]></title>
    <link href="http://suqun.github.io/2017/02/19/JVM-note-6/"/>
    <id>http://suqun.github.io/2017/02/19/JVM-note-6/</id>
    <published>2017-02-19T01:37:38.000Z</published>
    <updated>2017-04-06T02:56:02.000Z</updated>
    <content type="html"><![CDATA[<p>基于JDK1.7 Update 14之后的HotSpot虚拟机的垃圾收集器。</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-gc.png" alt=""></p>
<p>两个收集器之间有连线，说明他们可以搭配使用。收集器所处的区域，则表示他是属于新生代收集器还是老生代收集器。</p>
<h2 id="Serial_u6536_u96C6_u5668"><a href="#Serial_u6536_u96C6_u5668" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-serial.png" alt=""></p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-serial-1.png" alt="Serial / Serial Old收集器运行示意图"></p>
<p><strong>新生代收集（Minor GC）</strong></p>
<p>下面代码尝试分配3个2MB大小和1个4MB大小的对象</p>
<ul>
<li>运行通过<strong>-Xms20M</strong>（堆初始大小）、<strong>-Xmx20M</strong>（堆最大值）、<strong>-Xmn10M</strong>（新生代值）这3个参数限制了Java堆大小为20MB，不可扩展，其中10MB分配给新生代，剩下的10MB分配给老年代</li>
<li><strong>-XX:SurvivorRatio=8</strong> 决定了新生代中Eden区与一个Survivor区的空间比例为 8:1</li>
<li><strong>新生代总可用空间：9216KB（Eden区+1个Survivor区的总容量）</strong></li>
<li><strong>-XX:+PrintGCDetail</strong>，在发生垃圾收集时打印内存回收日志</li>
</ul>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * MinorGC</span><br><span class="line"> * VM Args: -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span><br><span class="line"> * Created by larry.su on 2017/2/21.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinorGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1M = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1,allocation2,allocation3,allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1M];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1M];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1M];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1M]; <span class="comment">//出现一次MinorGC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>main方法执行后，在分配allocation4对象时，发生一次Minor GC，这次GC的结果是新生代7814K变为423K，而总内存占用量（7814K-&gt;6567K(19456K)）几乎没有减少（因为allocation1、allocation2、allocation3三个对象都是存活的，虚拟机几乎没有找到可回收的对象）。</p>
</li>
<li><p>这次GC的原因是给allocation4分配所需的4MB内存的时候，发现Eden已经被占用了6MB，剩余空间已不足分配allocation4对象所需的4MB，因此发生Minor GC。</p>
</li>
<li><p>GC期间虚拟机又发现已有的3个2MB的对象无法全部放入Survivor空间（Survivor空间只有1MB大小），所以只好通过分配担保机制提前转移到老年代去。</p>
</li>
<li><p>这次GC结束后，4MB的allocation4对象顺利分配在Eden中，因此程序执行完成的结果是Eden占用4MB，Servivor空闲，老年代被占用6MB。</p>
</li>
</ol>
<p>JDK1.6使用Serial收集器的GC日志：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="constant">GC</span> (<span class="constant">Allocation</span> <span class="constant">Failure</span>) [<span class="constant">DefNew</span><span class="symbol">:</span> <span class="number">7814</span>K-&gt;<span class="number">423</span>K(<span class="number">9216</span>K), <span class="number">0</span>.<span class="number">0051201</span> secs] <span class="number">7814</span>K-&gt;<span class="number">6567</span>K(<span class="number">19456</span>K), <span class="number">0</span>.<span class="number">00513</span>87 secs] [<span class="constant">Times</span><span class="symbol">:</span> user=<span class="number">0</span>.<span class="number">00</span> sys=<span class="number">0</span>.<span class="number">00</span>, real=<span class="number">0</span>.<span class="number">00</span> secs]</span><br><span class="line">        <span class="constant">Heap</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">new</span> <span class="title">generation</span>   <span class="title">total</span> 9216<span class="title">K</span>, <span class="title">used</span> 4656<span class="title">K</span> [0<span class="title">x00000007bec00000</span>, 0<span class="title">x00000007bf600000</span>, 0<span class="title">x00000007bf600000</span>)</span></span><br><span class="line">        eden space <span class="number">8192</span>K,  <span class="number">51</span>% used [<span class="number">0x00000007bec00000</span>, <span class="number">0x00000007bf022408</span>, <span class="number">0x00000007bf400000</span>)</span><br><span class="line">        from space <span class="number">1024</span>K,  <span class="number">41</span>% used [<span class="number">0x00000007bf500000</span>, <span class="number">0x00000007bf569ca8</span>, <span class="number">0x00000007bf600000</span>)</span><br><span class="line">        to   space <span class="number">1024</span>K,   <span class="number">0</span>% used [<span class="number">0x00000007bf400000</span>, <span class="number">0x00000007bf400000</span>, <span class="number">0x00000007bf500000</span>)</span><br><span class="line">        tenured generation   total <span class="number">10240</span>K, used <span class="number">6144</span>K [<span class="number">0x00000007bf600000</span>, <span class="number">0x00000007c0000000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">        the space <span class="number">10240</span>K,  <span class="number">60</span>% used [<span class="number">0x00000007bf600000</span>, <span class="number">0x00000007bfc00030</span>, <span class="number">0x00000007bfc00200</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">        <span class="constant">Metaspace</span>       used <span class="number">2917</span>K, capacity <span class="number">4494</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 318<span class="title">K</span>, <span class="title">capacity</span> 386<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure>
<h2 id="ParNew_u6536_u96C6_u5668"><a href="#ParNew_u6536_u96C6_u5668" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>ParNew收集器其实就是Serial收集器的多线程版本，使用多条线程进行垃圾收集。</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-parnew.png" alt=""></p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-parnew-1.png" alt="ParNew / Serial Old收集器运行示意图"></p>
<p>MinorGC示例使用ParNew收集器的GC日志：</p>
<p>JDK8虚拟机参数：</p>
<ul>
<li>-Xms20M</li>
<li>-Xmx20M</li>
<li>-Xmn10M</li>
<li>-XX:+PrintGCDetails</li>
<li><strong>-XX:+UseParNewGC</strong></li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="constant">GC</span> (<span class="constant">Allocation</span> <span class="constant">Failure</span>) [<span class="constant">ParNew</span><span class="symbol">:</span> <span class="number">7814</span>K-&gt;<span class="number">467</span>K(<span class="number">9216</span>K), <span class="number">0</span>.<span class="number">0056367</span> secs] <span class="number">7814</span>K-&gt;<span class="number">6611</span>K(<span class="number">19456</span>K), <span class="number">0</span>.<span class="number">00565</span>88 secs] [<span class="constant">Times</span><span class="symbol">:</span> user=<span class="number">0</span>.<span class="number">01</span> sys=<span class="number">0</span>.<span class="number">00</span>, real=<span class="number">0</span>.<span class="number">00</span> secs]</span><br><span class="line">        <span class="constant">Heap</span></span><br><span class="line">        par new generation   total <span class="number">9216</span>K, used <span class="number">4700</span>K [<span class="number">0x00000007bec00000</span>, <span class="number">0x00000007bf600000</span>, <span class="number">0x00000007bf600000</span>)</span><br><span class="line">        eden space <span class="number">8192</span>K,  <span class="number">51</span>% used [<span class="number">0x00000007bec00000</span>, <span class="number">0x00000007bf022408</span>, <span class="number">0x00000007bf400000</span>)</span><br><span class="line">        from space <span class="number">1024</span>K,  <span class="number">45</span>% used [<span class="number">0x00000007bf500000</span>, <span class="number">0x00000007bf574ed8</span>, <span class="number">0x00000007bf600000</span>)</span><br><span class="line">        to   space <span class="number">1024</span>K,   <span class="number">0</span>% used [<span class="number">0x00000007bf400000</span>, <span class="number">0x00000007bf400000</span>, <span class="number">0x00000007bf500000</span>)</span><br><span class="line">        tenured generation   total <span class="number">10240</span>K, used <span class="number">6144</span>K [<span class="number">0x00000007bf600000</span>, <span class="number">0x00000007c0000000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">        the space <span class="number">10240</span>K,  <span class="number">60</span>% used [<span class="number">0x00000007bf600000</span>, <span class="number">0x00000007bfc00030</span>, <span class="number">0x00000007bfc00200</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">        <span class="constant">Metaspace</span>       used <span class="number">2946</span>K, capacity <span class="number">4494</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 319<span class="title">K</span>, <span class="title">capacity</span> 386<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure>
<p>后面还会接触几款并行和并发的收集器。在谈垃圾收集的上下文语境下，可以解释如下：</p>
<ul>
<li><strong>并行（Parallel）</strong>：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态</li>
<li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行在另一个cpu上</li>
</ul>
<h2 id="Parallel_Scavenge_u6536_u96C6_u5668"><a href="#Parallel_Scavenge_u6536_u96C6_u5668" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-parallel-scavenge.png" alt=""></p>
<h2 id="Serial_Old_u6536_u96C6_u5668"><a href="#Serial_Old_u6536_u96C6_u5668" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-serial-old.png" alt=""></p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-serial-1.png" alt="Serial / Serial Old收集器运行示意图"></p>
<h2 id="Parallel_Old_u6536_u96C6_u5668"><a href="#Parallel_Old_u6536_u96C6_u5668" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-parallel-old.png" alt=""></p>
<p>MinorGC示例使用Parallel Scavenge + Parallel Old收集器的GC日志：</p>
<p>JDK8虚拟机参数：</p>
<ul>
<li>-Xms20M</li>
<li>-Xmx20M</li>
<li>-Xmn10M</li>
<li>-XX:+PrintGCDetails</li>
<li><strong>-XX:+UseParallelOldGC</strong></li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Heap</span></span><br><span class="line">        <span class="constant">PSYoungGen</span>      total <span class="number">9216</span>K, used <span class="number">7979</span>K [<span class="number">0x00000007bf600000</span>, <span class="number">0x00000007c0000000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">        eden space <span class="number">8192</span>K, <span class="number">97</span>% used [<span class="number">0x00000007bf600000</span>,<span class="number">0x00000007bfdcac90</span>,<span class="number">0x00000007bfe00000</span>)</span><br><span class="line">        from space <span class="number">1024</span>K, <span class="number">0</span>% used [<span class="number">0x00000007bff00000</span>,<span class="number">0x00000007bff00000</span>,<span class="number">0x00000007c0000000</span>)</span><br><span class="line">        to   space <span class="number">1024</span>K, <span class="number">0</span>% used [<span class="number">0x00000007bfe00000</span>,<span class="number">0x00000007bfe00000</span>,<span class="number">0x00000007bff00000</span>)</span><br><span class="line">        <span class="constant">ParOldGen</span>       total <span class="number">10240</span>K, used <span class="number">4096</span>K [<span class="number">0x00000007bec00000</span>, <span class="number">0x00000007bf600000</span>, <span class="number">0x00000007bf600000</span>)</span><br><span class="line">        object space <span class="number">10240</span>K, <span class="number">40</span>% used [<span class="number">0x00000007bec00000</span>,<span class="number">0x00000007bf000010</span>,<span class="number">0x00000007bf600000</span>)</span><br><span class="line">        <span class="constant">Metaspace</span>       used <span class="number">2967</span>K, capacity <span class="number">4494</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 322<span class="title">K</span>, <span class="title">capacity</span> 386<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure>
<p>『ParOldGen       total 10240K, used 4096K』看出allocation4直接被分配到老年代中。</p>
<h2 id="CMS_u6536_u96C6_u5668"><a href="#CMS_u6536_u96C6_u5668" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-cms-2.png" alt=""></p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-cms-1.png" alt="Concurrent Mark Sweep 收集器运行示意图"></p>
<p>MinorGC示例使用ParNew + CMS + Serial Old(后备)收集器的GC日志：</p>
<p>JDK8虚拟机参数：</p>
<ul>
<li>-Xms20M</li>
<li>-Xmx20M</li>
<li>-Xmn10M</li>
<li>-XX:+PrintGCDetails</li>
<li><strong>-XX:+UseConcMarkSweepGC</strong></li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [ParNew: 8144K-&gt;455K(9216K), 0.0054356 secs] 8144K-&gt;6601K(19456K), 0.0054911 secs] [Times: user=0.03 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (CMS Initial Mark) [1 CMS-initial-mark: 6146K(10240K)] 10697K(19456K), 0.0002332 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[CMS-concurrent-mark-start]</span><br><span class="line">[CMS-concurrent-mark: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[CMS-concurrent-preclean-start]</span><br><span class="line">[CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[CMS-concurrent-abortable-preclean-start]</span><br><span class="line">[CMS-concurrent-abortable-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (CMS Final Remark) [YG occupancy: 4551 K (9216 K)][Rescan (parallel) , 0.0002916 secs][weak refs processing, 0.0000330 secs][class unloading, 0.0001571 secs][scrub symbol table, 0.0003754 secs][scrub string table, 0.0001245 secs][1 CMS-remark: 6146K(10240K)] 10697K(19456K), 0.0010223 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[CMS-concurrent-sweep-start]</span><br><span class="line">[CMS-concurrent-sweep: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[CMS-concurrent-reset-start]</span><br><span class="line">[CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 9216K, used 4634K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  eden space 8192K,  51% used [0x00000007bec00000, 0x00000007bf014930, 0x00000007bf400000)</span><br><span class="line">  from space 1024K,  44% used [0x00000007bf500000, 0x00000007bf571f58, 0x00000007bf600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)</span><br><span class="line"> concurrent mark-sweep generation total 10240K, used 6146K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 2811K, capacity 4490K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 305K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>新生代使用的ParNew收集器，allocation4分配时新生代已没有足够的空间分配。Survivior只有1M不能够存放allocation1，2，3三个对象，所以这三个对象会复制到concurrent mark-sweep generation 中。最终allocation4分配到par new generation中。</p>
<p>从GC日志可以看出老年代GC的步骤：CMS-initial-mark -&gt; CMS-concurrent-mark -&gt; CMS-remark -&gt; CMS-concurrent-sweep -&gt; CMS-concurrent-reset(重置状态等待下一次触发GC)</p>
<h2 id="G1_u6536_u96C6_u5668"><a href="#G1_u6536_u96C6_u5668" class="headerlink" title="G1收集器"></a>G1收集器</h2><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-g1.png" alt=""></p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-g1-1.png" alt="G1收集器运行示意图"></p>
<h2 id="u5783_u573E_u6536_u96C6_u5668_u53C2_u6570_u603B_u7ED3"><a href="#u5783_u573E_u6536_u96C6_u5668_u53C2_u6570_u603B_u7ED3" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h2><p>垃圾收集相关的常用参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>UseSerialGC</td>
<td style="text-align:center">虚拟机运行在Client模式下的默认值，打开此开关后，使用 <strong>Serial + Serial Old</strong>的收集器组合进行内存回收</td>
</tr>
<tr>
<td>UseParNewGC</td>
<td style="text-align:center">打开此开关后，使用<strong>ParNew + Serial Old</strong>的收集器组合进行内存回收</td>
</tr>
<tr>
<td>UseConcMarkSweepGC</td>
<td style="text-align:center">打开此开关后，使用<strong>ParNew + CMS + Serial Old</strong>的收集器组合进行内存回收。Serial Old作为CMS出现Concurrent Mode Failure失败后的后备收集器使用</td>
</tr>
<tr>
<td>UseParallelGC</td>
<td style="text-align:center">虚拟机运行在Server模式下的默认值，打开此开关后，使用<strong>Parallel Scanvenge + Serial Old</strong> (PS MarkSweep)的收集器组合进行内存回收</td>
</tr>
<tr>
<td>UseParallelOldGC</td>
<td style="text-align:center">打开此开关后，使用 <strong>Parallel Scavenge + Parallel Old</strong>的收集器组合进行内存回收</td>
</tr>
<tr>
<td>SurvivorRatio</td>
<td style="text-align:center">新生代中Eden区域与Survivor区域的容量比值，<strong>默认为8</strong>，代表<strong>Eden:Survivor = 8:1</strong></td>
</tr>
<tr>
<td>PretenureSizeThreshold</td>
<td style="text-align:center"><strong>直接晋级到老年代的对象大小</strong>，设置后，大于这个参数的对象将直接在老年代中分配</td>
</tr>
<tr>
<td>MaxTenuringThreshold</td>
<td style="text-align:center"><strong>晋升到老年代的对象年龄</strong>。每个对象坚持过一次Minor GC之后，年龄就增加1，当超过这个参数值以后就进入老年代</td>
</tr>
<tr>
<td>UseAdaptiveSizePolicy</td>
<td style="text-align:center"><strong>动态调整Java堆中各个区域的大小以及进入老年代的年龄</strong></td>
</tr>
<tr>
<td>HandlePromotionFailure</td>
<td style="text-align:center"><strong>是否允许担保失败</strong>，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区所有对象都存活的极端情况</td>
</tr>
<tr>
<td>ParallelGCThreads</td>
<td style="text-align:center">设置<strong>并行GC时进行内存回收的线程数</strong></td>
</tr>
<tr>
<td>GCTimeRatio</td>
<td style="text-align:center"><strong>GC时间占总时间的比率</strong>，默认值99，即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效</td>
</tr>
<tr>
<td>MaxGCPauseMillis</td>
<td style="text-align:center"><strong>设置GC的最大停顿时间</strong>。仅在使用Parallel Scavenge收集器时生效</td>
</tr>
<tr>
<td>CMSInitiatingOccupancyFraction</td>
<td style="text-align:center">设置<strong>CMS收集器在老年代空间被使用多少后触发垃圾收集</strong>。默认值为<strong>68%</strong>，仅在CMS收集器时生效</td>
</tr>
<tr>
<td>UseCMSCompactAtFullCollection</td>
<td style="text-align:center">设置<strong>CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理</strong>。仅在CMS收集器时生效</td>
</tr>
<tr>
<td>CMSFullGCsBeforeCompaction</td>
<td style="text-align:center">设置<strong>CMS收集器在进行若干次垃圾收集后再启动一次碎片整理</strong>。仅在CMS收集器时生效</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<p>基于JDK1.7 Update 14之后的HotSpot虚拟机的垃圾收集器。</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-gc.png" alt=""></p>
<p>两个收集器之间有连线，说明他们可以搭配使用。收集器所处的区域，则表示他是属于新生代收集器还是老生代收集器。</p>
<h2 id="Serial_u6536_u96C6_u5668"><a href="#Serial_u6536_u96C6_u5668" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-serial.png" alt=""></p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-serial-1.png" alt="Serial / Serial Old收集器运行示意图"></p>
<p><strong>新生代收集（Minor GC）</strong></p>
<p>下面代码尝试分配3个2MB大小和1个4MB大小的对象</p>
<ul>
<li>运行通过<strong>-Xms20M</strong>（堆初始大小）、<strong>-Xmx20M</strong>（堆最大值）、<strong>-Xmn10M</strong>（新生代值）这3个参数限制了Java堆大小为20MB，不可扩展，其中10MB分配给新生代，剩下的10MB分配给老年代</li>
<li><strong>-XX:SurvivorRatio=8</strong> 决定了新生代中Eden区与一个Survivor区的空间比例为 8:1</li>
<li><strong>新生代总可用空间：9216KB（Eden区+1个Survivor区的总容量）</strong></li>
<li><strong>-XX:+PrintGCDetail</strong>，在发生垃圾收集时打印内存回收日志</li>
</ul>]]>
    
    </summary>
    
      <category term="JVM" scheme="http://suqun.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM笔记五：垃圾收集器与内存分配策略——垃圾收集算法]]></title>
    <link href="http://suqun.github.io/2017/02/18/JVM-note-5/"/>
    <id>http://suqun.github.io/2017/02/18/JVM-note-5/</id>
    <published>2017-02-18T13:11:15.000Z</published>
    <updated>2017-04-06T02:55:51.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u6807_u8BB0-_u6E05_u9664_u7B97_u6CD5"><a href="#u6807_u8BB0-_u6E05_u9664_u7B97_u6CD5" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>最基础的垃圾收集算法。</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-mark-sweep-1.png" alt=""></p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-mark-sweep.png" alt=""></p>
<p>参考：<a href="http://www.jianshu.com/p/b0f5d21fe031" target="_blank" rel="external">http://www.jianshu.com/p/b0f5d21fe031</a></p>
<a id="more"></a>
<h3 id="u590D_u5236_u7B97_u6CD5"><a href="#u590D_u5236_u7B97_u6CD5" class="headerlink" title="复制算法"></a>复制算法</h3><p>半区复制算法的目的也是为了更好的缓解内存碎片问题。</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-copying-2.png" alt=""></p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-copying.jpg" alt=""></p>
<font color="red">现在的商业虚拟机都是采用这种收集算法来回收<strong>新生代</strong></font>，新生代中的对象98%是朝生夕死的，所以并不需要安装1:1的比例划分内存空间，而是将内存分为一块较大的Eden区，和两块较小的Survivor空间。<br><font color="red">HotSpot虚拟机默认Eden和Survivor的大小比例是8:1</font>，也就是每次新生代可用内存空间为整个新生代容量的90%，只有10%的内存会被浪费。当Servivor空间不够用时，需要依赖其他内存（这里指老年代）进行分担担保。<br><br><font color="green">复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行担保，以应对被使用的内存中所有对象100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</font>

<h3 id="u6807_u8BB0-_u6574_u7406_u7B97_u6CD5"><a href="#u6807_u8BB0-_u6574_u7406_u7B97_u6CD5" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-mark-compact.png" alt=""></p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-mark-compact.jpg" alt=""></p>
<h3 id="u5206_u4EE3_u6536_u96C6_u7B97_u6CD5"><a href="#u5206_u4EE3_u6536_u96C6_u7B97_u6CD5" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-generation-collection.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u6807_u8BB0-_u6E05_u9664_u7B97_u6CD5"><a href="#u6807_u8BB0-_u6E05_u9664_u7B97_u6CD5" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>最基础的垃圾收集算法。</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-mark-sweep-1.png" alt=""></p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-mark-sweep.png" alt=""></p>
<p>参考：<a href="http://www.jianshu.com/p/b0f5d21fe031">http://www.jianshu.com/p/b0f5d21fe031</a></p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM笔记四：垃圾收集器与内存分配策略——对象]]></title>
    <link href="http://suqun.github.io/2017/02/18/JVM-note-4/"/>
    <id>http://suqun.github.io/2017/02/18/JVM-note-4/</id>
    <published>2017-02-18T02:27:59.000Z</published>
    <updated>2017-04-06T02:55:41.000Z</updated>
    <content type="html"><![CDATA[<p>在堆里存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还存活着，哪些已经死去（即不可能再被任何途径使用的对象）。</p>
<h3 id="u5F15_u7528_u8BA1_u6570_u6CD5"><a href="#u5F15_u7528_u8BA1_u6570_u6CD5" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用计数法（Reference Counting）：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；任何时刻计数器为0的对象是不可能被使用的。主流的Java虚拟机里没有使用引用计数法来管理内存，主要原因是它很难解决对象之间的相互循环引用的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 引用计数器算法的缺陷</span><br><span class="line"> * VM Args：-XX:+PrintGCDetails</span><br><span class="line"> * JDK1.6</span><br><span class="line"> * Created by larry.su on 2017/2/18.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1M = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个成员属性的唯一意义就是占用点内存，以便能在GC中看清楚是否被回收过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1M];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line"></span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//假设此时发生GC，objA和objB是否会被回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System)</span> [CMS: 0K-&gt;423<span class="title">K</span><span class="params">(<span class="number">63872</span>K)</span>, 0.0099285 secs] **6167K-&gt;423K**<span class="params">(<span class="number">83008</span>K)</span>, [CMS Perm : 4749K-&gt;4747<span class="title">K</span><span class="params">(<span class="number">21248</span>K)</span>], 0.0107293 secs] [Times: user</span>=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> par <span class="keyword">new</span> generation   total <span class="number">19136</span>K, used <span class="number">1021</span>K [<span class="number">7f</span>3000000, <span class="number">7f</span>44c0000, <span class="number">7f</span>44c0000)</span><br><span class="line">  eden space <span class="number">17024</span>K,   <span class="number">6</span>% used [<span class="number">7f</span>3000000, <span class="number">7f</span>30ff670, <span class="number">7f</span>40a0000)</span><br><span class="line">  from space <span class="number">2112</span>K,   <span class="number">0</span>% used [<span class="number">7f</span>40a0000, <span class="number">7f</span>40a0000, <span class="number">7f</span>42b0000)</span><br><span class="line">  to   space <span class="number">2112</span>K,   <span class="number">0</span>% used [<span class="number">7f</span>42b0000, <span class="number">7f</span>42b0000, <span class="number">7f</span>44c0000)</span><br><span class="line"> concurrent mark-sweep generation total <span class="number">63872</span>K, used <span class="number">423</span>K [<span class="number">7f</span>44c0000, <span class="number">7f</span>8320000, <span class="number">7f</span>ae00000)</span><br><span class="line"> concurrent-mark-sweep perm gen total <span class="number">21248</span>K, used <span class="number">4880</span>K [<span class="number">7f</span>ae00000, <span class="number">7f</span>c2c0000, <span class="number">800000000</span>)</span><br></pre></td></tr></table></figure>
<p><strong>6167K-&gt;423K(83008K)</strong>意味着虚拟机并没有因为这两个对象并相互引用就不回收他们，也从侧面说明虚拟机并不是通过引用计数法来判断对象是否存活的。</p>
<a id="more"></a>
<h3 id="u53EF_u8FBE_u6027_u5206_u6790_u7B97_u6CD5"><a href="#u53EF_u8FBE_u6027_u5206_u6790_u7B97_u6CD5" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com//jvm-reachabilityAnalysis.png" alt="可达性分析算法"></p>
<h3 id="u518D_u8C08_u5F15_u7528"><a href="#u518D_u8C08_u5F15_u7528" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>在JDK1.2之后，Java对引用的概念进行了扩充，分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com//jvm-reference.png" alt="reference"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在堆里存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还存活着，哪些已经死去（即不可能再被任何途径使用的对象）。</p>
<h3 id="u5F15_u7528_u8BA1_u6570_u6CD5"><a href="#u5F15_u7528_u8BA1_u6570_u6CD5" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用计数法（Reference Counting）：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；任何时刻计数器为0的对象是不可能被使用的。主流的Java虚拟机里没有使用引用计数法来管理内存，主要原因是它很难解决对象之间的相互循环引用的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 引用计数器算法的缺陷</span><br><span class="line"> * VM Args：-XX:+PrintGCDetails</span><br><span class="line"> * JDK1.6</span><br><span class="line"> * Created by larry.su on 2017/2/18.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1M = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个成员属性的唯一意义就是占用点内存，以便能在GC中看清楚是否被回收过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1M];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line"></span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//假设此时发生GC，objA和objB是否会被回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System)</span> [CMS: 0K-&gt;423<span class="title">K</span><span class="params">(<span class="number">63872</span>K)</span>, 0.0099285 secs] **6167K-&gt;423K**<span class="params">(<span class="number">83008</span>K)</span>, [CMS Perm : 4749K-&gt;4747<span class="title">K</span><span class="params">(<span class="number">21248</span>K)</span>], 0.0107293 secs] [Times: user</span>=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> par <span class="keyword">new</span> generation   total <span class="number">19136</span>K, used <span class="number">1021</span>K [<span class="number">7f</span>3000000, <span class="number">7f</span>44c0000, <span class="number">7f</span>44c0000)</span><br><span class="line">  eden space <span class="number">17024</span>K,   <span class="number">6</span>% used [<span class="number">7f</span>3000000, <span class="number">7f</span>30ff670, <span class="number">7f</span>40a0000)</span><br><span class="line">  from space <span class="number">2112</span>K,   <span class="number">0</span>% used [<span class="number">7f</span>40a0000, <span class="number">7f</span>40a0000, <span class="number">7f</span>42b0000)</span><br><span class="line">  to   space <span class="number">2112</span>K,   <span class="number">0</span>% used [<span class="number">7f</span>42b0000, <span class="number">7f</span>42b0000, <span class="number">7f</span>44c0000)</span><br><span class="line"> concurrent mark-sweep generation total <span class="number">63872</span>K, used <span class="number">423</span>K [<span class="number">7f</span>44c0000, <span class="number">7f</span>8320000, <span class="number">7f</span>ae00000)</span><br><span class="line"> concurrent-mark-sweep perm gen total <span class="number">21248</span>K, used <span class="number">4880</span>K [<span class="number">7f</span>ae00000, <span class="number">7f</span>c2c0000, <span class="number">800000000</span>)</span><br></pre></td></tr></table></figure>
<p><strong>6167K-&gt;423K(83008K)</strong>意味着虚拟机并没有因为这两个对象并相互引用就不回收他们，也从侧面说明虚拟机并不是通过引用计数法来判断对象是否存活的。</p>]]>
    
    </summary>
    
      <category term="JVM" scheme="http://suqun.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM笔记三：Java内存区域与内存溢出异常——OutOfMemoryError异常]]></title>
    <link href="http://suqun.github.io/2017/02/16/JVM-note-3/"/>
    <id>http://suqun.github.io/2017/02/16/JVM-note-3/</id>
    <published>2017-02-16T13:35:09.000Z</published>
    <updated>2017-04-06T02:55:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Java_u5806_u6EA2_u51FA"><a href="#Java_u5806_u6EA2_u51FA" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><p>Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大的容量限制后就会产生内存溢出异常。</p>
<p>下面代码限制Java堆的大小为20MB，不可扩展（将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出时Dump出当前的内存堆转储快照以便事后进行分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * HeapOOM</span><br><span class="line"> * Created by larry.su on 2017/2/7.</span><br><span class="line"> * -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid65766.hprof ...</span><br><span class="line">Heap dump file created [<span class="number">27784157</span> bytes in <span class="number">0.137</span> secs]</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="u865A_u62DF_u673A_u6808_u548C_u672C_u5730_u65B9_u6CD5_u6808_u6EA2_u51FA"><a href="#u865A_u62DF_u673A_u6808_u548C_u672C_u5730_u65B9_u6CD5_u6808_u6EA2_u51FA" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><p>HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的。栈容量只由-Xss参数设定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * VM Args: -Xss160k</span><br><span class="line"> * Created by larry.su on 2017/2/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stackLength ++ ;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stackLength:"</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span>  e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br><span class="line">stackLength:<span class="number">744</span></span><br><span class="line">    at com.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:<span class="number">14</span>)</span><br><span class="line">    at com.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:<span class="number">15</span>)</span><br><span class="line">    at com.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:<span class="number">15</span>)</span><br></pre></td></tr></table></figure>
<p>在单线程下，无论是由于栈帧太大还是虚拟机栈帧容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverFlowError异常。</p>
<h3 id="u65B9_u6CD5_u533A_u548C_u8FD0_u884C_u65F6_u5E38_u91CF_u6C60_u6EA2_u51FA"><a href="#u65B9_u6CD5_u533A_u548C_u8FD0_u884C_u65F6_u5E38_u91CF_u6C60_u6EA2_u51FA" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3><p>由于运行时常量池是方法区的一部分，因此这两个区域的溢出测试就放在一起进行。<strong>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。</strong></p>
<p><code>String.intern()</code>。在JDK1.6之前版本中由于常量池分配在永久内存中，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns a canonical representation for the string object.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * A pool of strings, initially empty, is maintained privately by the</span><br><span class="line"> * class &#123;<span class="doctag">@code</span> String&#125;.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * When the intern method is invoked, if the pool already contains a</span><br><span class="line"> * string equal to this &#123;<span class="doctag">@code</span> String&#125; object as determined by</span><br><span class="line"> * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method, then the string from the pool is</span><br><span class="line"> * returned. Otherwise, this &#123;<span class="doctag">@code</span> String&#125; object is added to the</span><br><span class="line"> * pool and a reference to this &#123;<span class="doctag">@code</span> String&#125; object is returned.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * It follows that for any two strings &#123;<span class="doctag">@code</span> s&#125; and &#123;<span class="doctag">@code</span> t&#125;,</span><br><span class="line"> * &#123;<span class="doctag">@code</span> s.intern() == t.intern()&#125; is &#123;<span class="doctag">@code</span> true&#125;</span><br><span class="line"> * if and only if &#123;<span class="doctag">@code</span> s.equals(t)&#125; is &#123;<span class="doctag">@code</span> true&#125;.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * All literal strings and string-valued constant expressions are</span><br><span class="line"> * interned. String literals are defined in section 3.10.5 of the</span><br><span class="line"> * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span>  a string that has the same contents as this string, but is</span><br><span class="line"> *          guaranteed to be from a pool of unique strings.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M</span><br><span class="line"> * Created by larry.su on 2017/2/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantsPoolOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//使用List保持常量池的引用，避免Full GC回收常量池行为</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//10M 的PermSize在Integer范围内足够产生OOM</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                list.add(String.valueOf(i++).intern());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">86889</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">at java.lang.String.intern(Native Method)</span><br><span class="line">at com.jvm.RuntimeConstantsPoolOOM.main(RuntimeConstantsPoolOOM.java:<span class="number">21</span>)</span><br></pre></td></tr></table></figure>
<p>在JDK1.7中运行这段代码就不会得到相同的接口，while会一直循环下去。</p>
<p>在JDK8中，while同样一直循环下去，同时控制台打印如下信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server VM warning: ignoring option PermSize</span>=<span class="number">10</span>M; support was removed in <span class="number">8.0</span></span><br><span class="line"><span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server VM warning: ignoring option MaxPermSize</span>=<span class="number">10</span>M; support was removed in <span class="number">8.0</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Java_u5806_u6EA2_u51FA"><a href="#Java_u5806_u6EA2_u51FA" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><p>Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大的容量限制后就会产生内存溢出异常。</p>
<p>下面代码限制Java堆的大小为20MB，不可扩展（将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出时Dump出当前的内存堆转储快照以便事后进行分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * HeapOOM</span><br><span class="line"> * Created by larry.su on 2017/2/7.</span><br><span class="line"> * -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid65766.hprof ...</span><br><span class="line">Heap dump file created [<span class="number">27784157</span> bytes in <span class="number">0.137</span> secs]</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="JVM" scheme="http://suqun.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM笔记二：Java内存区域与内存溢出异常——HotSpot虚拟机对象探秘]]></title>
    <link href="http://suqun.github.io/2017/02/14/JVM-note-2/"/>
    <id>http://suqun.github.io/2017/02/14/JVM-note-2/</id>
    <published>2017-02-14T12:42:05.000Z</published>
    <updated>2017-04-06T02:55:21.000Z</updated>
    <content type="html"><![CDATA[<p>以常用的虚拟机HotSpot和常用的内存区域Java堆为例，深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。</p>
<h3 id="u5BF9_u8C61_u7684_u521B_u5EFA"><a href="#u5BF9_u8C61_u7684_u521B_u5EFA" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-new.png" alt="java对象的创建"></p>
<ul>
<li>虚拟机遇到一条new指令</li>
<li><strong>检查</strong>这个指令的参数是否能在常量池中定位到一个类的符号引用。并且检查这个符号引用代表的类是否已被加载、解析、初始化过，没有必须先执行相应的类加载过程。</li>
<li><strong>指针碰撞</strong>：若干Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配的内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</li>
<li><strong>空闲列表</strong>：如果java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，JVM必须维护一个空闲列表用来记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</li>
<li>内存分配完成以后，虚拟机需要将<strong>分配到的内存空间都初始化为零值</strong>（不包括对象头），确保对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>
<li>接下来，<strong>JVM对对象进行必要的设置</strong>，例如：这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希值、对象的GC分代年龄等信息。这些信息存放在对象头（Object Header）中。</li>
<li>上面的工作完成之后，<strong>从JVM的角度，一个新的对象以及产生</strong>了。</li>
<li><strong>对Java程序来说，对象所有的字段都为零值</strong>，所以一般来说，执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象就完全产生出来。</init></li>
</ul>
<a id="more"></a>
<h3 id="u5BF9_u8C61_u7684_u5185_u5B58_u5E03_u5C40"><a href="#u5BF9_u8C61_u7684_u5185_u5B58_u5E03_u5C40" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-object.png" alt="对象的内存布局"></p>
<h3 id="u5BF9_u8C61_u7684_u8BBF_u95EE_u5B9A_u4F4D"><a href="#u5BF9_u8C61_u7684_u8BBF_u95EE_u5B9A_u4F4D" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-object-visit.png" alt="对象的访问定位"></p>
<ul>
<li>使用<strong>句柄访问</strong>：Java堆中将划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄地址中包含了对象实例数据与类型数据各自的具体地址信息</li>
<li>使用<strong>直接指针访问</strong>：Java堆对象的布局中必须考虑如何放置访问类型数据相关信息，而reference中存储的直接就是对象地址</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>以常用的虚拟机HotSpot和常用的内存区域Java堆为例，深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。</p>
<h3 id="u5BF9_u8C61_u7684_u521B_u5EFA"><a href="#u5BF9_u8C61_u7684_u521B_u5EFA" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-new.png" alt="java对象的创建"></p>
<ul>
<li>虚拟机遇到一条new指令</li>
<li><strong>检查</strong>这个指令的参数是否能在常量池中定位到一个类的符号引用。并且检查这个符号引用代表的类是否已被加载、解析、初始化过，没有必须先执行相应的类加载过程。</li>
<li><strong>指针碰撞</strong>：若干Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配的内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</li>
<li><strong>空闲列表</strong>：如果java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，JVM必须维护一个空闲列表用来记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</li>
<li>内存分配完成以后，虚拟机需要将<strong>分配到的内存空间都初始化为零值</strong>（不包括对象头），确保对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>
<li>接下来，<strong>JVM对对象进行必要的设置</strong>，例如：这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希值、对象的GC分代年龄等信息。这些信息存放在对象头（Object Header）中。</li>
<li>上面的工作完成之后，<strong>从JVM的角度，一个新的对象以及产生</strong>了。</li>
<li><strong>对Java程序来说，对象所有的字段都为零值</strong>，所以一般来说，执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象就完全产生出来。</li>
</ul>]]>
    
    </summary>
    
      <category term="JVM" scheme="http://suqun.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM笔记一：Java内存区域与内存溢出异常——运行时数据区域]]></title>
    <link href="http://suqun.github.io/2016/12/25/JVM-note-1/"/>
    <id>http://suqun.github.io/2016/12/25/JVM-note-1/</id>
    <published>2016-12-25T06:56:19.000Z</published>
    <updated>2017-04-06T02:55:09.000Z</updated>
    <content type="html"><![CDATA[<p>该系列学习笔记均来自《深入理解Java虚拟机》一书。</p>
<h3 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h3><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com//jvm-runtime-3.png" alt="Java虚拟机运行时数据区"></p>
<a id="more"></a>
<h3 id="u7A0B_u5E8F_u8BA1_u6570_u5668"><a href="#u7A0B_u5E8F_u8BA1_u6570_u5668" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器（Program Counter Register）是一块较小的内存空间，可以看作是线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，<strong>在任何一个确定的时刻，一个处理器（多核处理器的一个内核）都只会执行一条线程的指令。因此为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储</strong>。我们称这类内存区域为『线程私有』的内存。</p>
<p>如果线程正在执行一个Java方法，这个计数器记录的就是正在执行的虚拟机字节码指令的地址；如果执行的是一个Native方法，这个计数器值为空（Undefined）。</p>
<p>此内存区域是唯一一个在Java虚拟机中没有规定任何OutOfMemoryError情况的区域。</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jmv-pcr.png" alt=""></p>
<h3 id="u865A_u62DF_u673A_u6808"><a href="#u865A_u62DF_u673A_u6808" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>与程序计数器一样，<strong>Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的。它的生命周期与线程相同</strong>。</p>
<font color="red">虚拟机栈描述的是Java方法执行的内存模型</font>：<strong>每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中的入栈到出栈的过程</strong>。<br><br><font color="red">局部变量表</font>

<ul>
<li><strong>存放了编译期可知的各种基本数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和<strong>returnAddress类型</strong>（指向了一条字节码指令的地址）。</li>
<li>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用一个。</li>
<li>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法的运行期间不会改变局部变量的大小。</li>
</ul>
<p>在Java虚拟机规范中，对这个区域规定2种异常情况：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机允许的深度，将抛出StackOverflowError异常</li>
<li>如果虚拟机栈可以动态扩展，扩展申请时无法申请到足够的内存，就会抛出OutOfMemoryError异常</li>
</ul>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-vmstack.png" alt=""></p>
<h3 id="u672C_u5730_u65B9_u6CD5_u6808"><a href="#u672C_u5730_u65B9_u6CD5_u6808" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p><font color="red">本地方法栈（Native Method Stack）与虚拟机栈发挥的作用是非常相似的</font>，他们之间的<font color="red">区别</font>：<strong>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，本地方法栈则为虚拟机使用到的Native方法服务</strong>。</p>
<p>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-nativestack.png" alt=""></p>
<h3 id="Java_u5806"><a href="#Java_u5806" class="headerlink" title="Java堆"></a>Java堆</h3><p><font color="red">Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存</font>。</p>
<p>Java堆是垃圾收集器管理的主要区域，也被称为『GC堆』。从内存回收的角度看，由于现在收集器基本上都采用<strong>分代收集算法</strong>，所以java堆还可以细分为：<strong>新生代和老年代</strong>；在细致一点的有Eden空间、From Survivor空间、To Survivor空间等。</p>
<p>根据Java虚拟机规范的规定，<strong>Java堆</strong>可以处于物理上不连续的内存空间中，只要逻辑上的连续即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照<strong>可扩展来</strong>实现的（<strong>通过-Xmx和-Xms控制</strong>）。如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-heap.png" alt="Heap"></p>
<h3 id="u65B9_u6CD5_u533A"><a href="#u65B9_u6CD5_u533A" class="headerlink" title="方法区"></a>方法区</h3><p>方法区（Method Area）与Java堆一样，是<strong>各个线程共享</strong>的内存区域，它用于<strong>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它有一个别名叫Non-Heap（非堆），目的就是与Java堆区分开来。</p>
<p>对于习惯在HotSpot虚拟机上开发、部署程序的开发者来说，很多人更愿意把方法区成为『永久代』（Permanent Generation)，本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去单独为方法区编写内存管理代码的工作。在已经发布的JDK1.7的HotSpot中，已经把原本放在永久代的字符串常量池移出。</p>
<p>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样『永久』存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的内存回收成绩比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。</p>
<p>根据Java虚拟机规范的规定，方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<h4 id="u8FD0_u884C_u65F6_u5E38_u91CF_u6C60"><a href="#u8FD0_u884C_u65F6_u5E38_u91CF_u6C60" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><strong>运行时常量池（Runtime Constant Pool）是方法区的一部分</strong>。Class文件中除了有类的版本、字段、接口等描述信息外，有一项信息是常量池（Constant Pool Table），<strong>用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载进入方法区的运行时常量池中存放</strong>。</p>
<p>既然运行时常量池是方法区的一部分，那么自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jvm-method-area-1.png" alt=""></p>
<h3 id="u76F4_u63A5_u5185_u5B58"><a href="#u76F4_u63A5_u5185_u5B58" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁的使用，而且也可能导致OutOfMemoryError异常出现。所以我们放到一起讲。</p>
<p>在Jdk1.4中新加入了NIO（New Input/Output)类，引入了一种基于通道（Channel）与缓存区（Buffer）的I/O方式，他可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高内存，因为避免了Java堆和Native堆中来回复制数据。</p>
<p>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但是<strong>经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统的限制），从而导致OutOfMemoryError异常</strong>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>该系列学习笔记均来自《深入理解Java虚拟机》一书。</p>
<h3 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h3><p><img src="http://7xpk5e.com1.z0.glb.clouddn.com//jvm-runtime-3.png" alt="Java虚拟机运行时数据区"></p>]]>
    
    </summary>
    
      <category term="JVM" scheme="http://suqun.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java NIO SocketChannel]]></title>
    <link href="http://suqun.github.io/2016/11/27/Java-NIO-SocketChannel/"/>
    <id>http://suqun.github.io/2016/11/27/Java-NIO-SocketChannel/</id>
    <published>2016-11-27T13:12:38.000Z</published>
    <updated>2017-04-06T02:53:16.000Z</updated>
    <content type="html"><![CDATA[<p>原文：<a href="http://tutorials.jenkov.com/java-nio/socketchannel.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-nio/socketchannel.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文：<a href="http://tutorials.jenkov.com/java-nio/socketchannel.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-nio/]]>
    </summary>
    
      <category term="Java NIO" scheme="http://suqun.github.io/tags/Java-NIO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java NIO FileChannel]]></title>
    <link href="http://suqun.github.io/2016/11/22/Java-NIO-FileChannel/"/>
    <id>http://suqun.github.io/2016/11/22/Java-NIO-FileChannel/</id>
    <published>2016-11-21T16:14:33.000Z</published>
    <updated>2017-04-06T02:53:16.000Z</updated>
    <content type="html"><![CDATA[<p>原文：[<a href="http://tutorials.jenkov.com/java-nio/file-channel.html]{http://tutorials.jenkov.com/java-nio/file-channel.html}" target="_blank" rel="external">http://tutorials.jenkov.com/java-nio/file-channel.html]{http://tutorials.jenkov.com/java-nio/file-channel.html}</a></p>
<p>Java NIO中的FileChannel是一个连接文件的channel，可以使用它从文件中读取数据或向文件中写入数据。Java NIO的FileChannel是NIO的一个选择相对标准的Java IO API来说。</p>
<p>FileChannel可以设置成非阻塞模式，但是仍然会按照阻塞模式运行。</p>
<h2 id="u6253_u5F00FileChannel"><a href="#u6253_u5F00FileChannel" class="headerlink" title="打开FileChannel"></a>打开FileChannel</h2><p>在使用FileChannel时需要先打开它，但是不能直接打开。需要借助InputStream,OutputStream或者是RandomAccessFile。</p>
<p>举个🌰： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile     = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      inChannel = aFile.getChannel();</span><br></pre></td></tr></table></figure>
<h2 id="u4ECEFileChannel_u8BFB_u6570_u636E"><a href="#u4ECEFileChannel_u8BFB_u6570_u636E" class="headerlink" title="从FileChannel读数据"></a>从FileChannel读数据</h2><p>从FileChannel读数据可以调用<code>read()</code>方法。</p>
<p>举个🌰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br></pre></td></tr></table></figure>
<p>首先给Buffer分配字节， FileChannel中的数据就是读到Buffer中。</p>
<p>其次，再调用<code>FileChannel.read()</code>方法。从FileChannel中将数据读入buffer。read()的整型返回值告诉我们已经写入Buffer的字节量。如果返回<code>-1</code>,就是读到了文件的结尾。</p>
<h2 id="FileChannel_u5199_u5165_u6570_u636E"><a href="#FileChannel_u5199_u5165_u6570_u636E" class="headerlink" title="FileChannel写入数据"></a>FileChannel写入数据</h2><p>Writing data to a FileChannel is done using the FileChannel.write() method, which takes a Buffer as parameter. Here is an example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Notice how the FileChannel.write() method is called inside a while-loop. There is no guarantee of how many bytes the write() method writes to the FileChannel. Therefore we repeat the write() call until the Buffer has no further bytes to write.</p>
<h2 id="u5173_u95EDFileChannel"><a href="#u5173_u95EDFileChannel" class="headerlink" title="关闭FileChannel"></a>关闭FileChannel</h2><p>When you are done using a FileChannel you must close it. Here is how that is done:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br></pre></td></tr></table></figure>
<h2 id="FileChannel_Position"><a href="#FileChannel_Position" class="headerlink" title="FileChannel Position"></a>FileChannel Position</h2><p>When reading or writing to a FileChannel you do so at a specific position. You can obtain the current position of the FileChannel object by calling the position() method.</p>
<p>You can also set the position of the FileChannel by calling the position(long pos) method.</p>
<p>Here are two examples:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> pos channel.position();</span><br><span class="line"></span><br><span class="line">channel.position(pos +<span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<p>If you set the position after the end of the file, and try to read from the channel, you will get -1 - the end-of-file marker.</p>
<p>If you set the position after the end of the file, and write to the channel, the file will be expanded to fit the position and written data. This may result in a “file hole”, where the physical file on the disk has gaps in the written data.</p>
<h2 id="FileChannel_Size"><a href="#FileChannel_Size" class="headerlink" title="FileChannel Size"></a>FileChannel Size</h2><p>The size() method of the FileChannel object returns the file size of the file the channel is connected to. Here is a simple example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> fileSize = channel.size();</span><br></pre></td></tr></table></figure>
<h2 id="FileChannel_Truncate"><a href="#FileChannel_Truncate" class="headerlink" title="FileChannel Truncate"></a>FileChannel Truncate</h2><p>You can truncate a file by calling the FileChannel.truncate() method. When you truncate a file, you cut it off at a given length. Here is an example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.truncate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
<p>This example truncates the file at 1024 bytes in length.</p>
<h2 id="FileChannel_Force"><a href="#FileChannel_Force" class="headerlink" title="FileChannel Force"></a>FileChannel Force</h2><p>The FileChannel.force() method flushes all unwritten data from the channel to the disk. An operating system may cache data in memory for performance reasons, so you are not guaranteed that data written to the channel is actually written to disk, until you call the force() method.</p>
<p>The force() method takes a boolean as parameter, telling whether the file meta data (permission etc.) should be flushed too.</p>
<p>Here is an example which flushes both data and meta data:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.force(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文：[<a href="http://tutorials.jenkov.com/java-nio/file-channel.html]{http://tutorials.jenkov.com/java-nio/file-channel.html}" target="_bl]]>
    </summary>
    
      <category term="Java NIO" scheme="http://suqun.github.io/tags/Java-NIO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java NIO Selector]]></title>
    <link href="http://suqun.github.io/2016/11/16/Java-NIO-Selector/"/>
    <id>http://suqun.github.io/2016/11/16/Java-NIO-Selector/</id>
    <published>2016-11-16T14:27:08.000Z</published>
    <updated>2017-04-06T02:53:16.000Z</updated>
    <content type="html"><![CDATA[<p>原文：<a href="http://tutorials.jenkov.com/java-nio/selectors.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-nio/selectors.html</a></p>
<p><code>Selector</code>是Java NIO中用来检查一个或多个NIO通道的，决定哪个通道做好准备进行读写的组件。这样，一个单线程就可以管理多个通道，以便管理多个网络连接。</p>
<h2 id="u4E3A_u4F55_u4F7F_u7528Selector_3F"><a href="#u4E3A_u4F55_u4F7F_u7528Selector_3F" class="headerlink" title="为何使用Selector?"></a>为何使用Selector?</h2><p>使用单线程处理多通道的好处就是可以使用更少的线程处理多个通道。实际上可以使用只用一个线程处理多个通道。在操作系统中，线程切换开销很大。每个线程都会占用一些资源（内存）。因此，线程越少越好。</p>
<p>但是，当前操作系统和CPU多任务处理上已经非常好，多线程的开销已经变得很小了。如果一个CPU有多个内核，不使用多任务可能是在浪费CPU能力。不管怎么说，关于那种设计的讨论应该放在另一篇不同的文章中。在这里，只要知道使用Selector能够处理多个通道就足够了。</p>
<p>使用一个Selector处理3个channel的图解如下：</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/JavaNIOSelectors.png" alt="
Java NIO: A Thread uses a Selector to handle 3 Channel&#39;s"></p>
<h2 id="Selector_u7684_u521B_u5EFA"><a href="#Selector_u7684_u521B_u5EFA" class="headerlink" title="Selector的创建"></a>Selector的创建</h2><p>调用<code>Selector.open()</code>方法创建一个selector。像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>
<h2 id="Channel_u6CE8_u518C_u5230Selector_u4E0A"><a href="#Channel_u6CE8_u518C_u5230Selector_u4E0A" class="headerlink" title="Channel注册到Selector上"></a>Channel注册到Selector上</h2><p>为了结合Selector使用Channel，首先要将Channel注册到Selector上。通过方法<code>SelectableChannel.register()</code>实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>
<p>结合Selector使用时，Channel必须是非阻塞师的。这就意味着，你不能把FileChannel和Selector结合使用，因为FileChannel不能切换到非阻塞模式。Socket Channel确可以很好的结合Selector使用。</p>
<p><code>register()</code>方法的第二个参数需要注意下。这是个有趣的设置，意思是在通过Selector监听Channel时刚兴趣的事件。可以监听到以下四种事件：</p>
<ul>
<li>Connect</li>
<li>Accept</li>
<li>Read</li>
<li>Write</li>
</ul>
<p>一个channel触发了事件就是意味着该事件已就绪。因此，channel连接服务成功就是<code>Connect</code>就绪。服务socke channel准备接受进入的连接就是<code>Accept</code>就绪。服务socket channel已经准备好了可以读取的数据就是<code>Read</code>就绪。channel准备好可以写入数据就是<code>Write</code>就绪。</p>
<p>这四种事件用SelectionKey的常量表示： </p>
<ul>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ul>
<p>如果对多个事件感兴趣，那么可以用“位或”操作符将常量连接起来，像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>
<p>下面还会继续提到interest集合。</p>
<h2 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h2><p>通过前面示例可以看到，调用<code>register()</code>方法向selector上注册channel时返回<code>SelectionKey</code>对象。这个<code>SelectionKey</code>对象中包含很多有趣的属性。</p>
<ul>
<li>interest集合</li>
<li>ready 集合</li>
<li>Channel</li>
<li>Selector</li>
<li>附加对象（可选）</li>
</ul>
<p>下面会描述这些属性。</p>
<h3 id="Interest_u96C6_u5408"><a href="#Interest_u96C6_u5408" class="headerlink" title="Interest集合"></a>Interest集合</h3><p>就像向Selector注册通道一节中所描述的，interest集合是你所选择的感兴趣的事件集合。通过SelectionKey可以读写interest集合。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = interestSet &amp; SelectionKey.OP_ACCEPT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>
<p>可以看到，使用『位与』操作interest集合和给定的的SelectionKey常量，可以确定某个确定的世界是否在interest集合中。</p>
<h3 id="Ready_u96C6_u5408"><a href="#Ready_u96C6_u5408" class="headerlink" title="Ready集合"></a>Ready集合</h3><p>ready集合是channel已经准备就绪的channel集合。在一次<code>selection</code>以后，可以先获得ready集合。至于<code>selecton</code>，会再下面的章节解释。可以这样获取ready集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readySet = selectionKey.readyOps();</span><br></pre></td></tr></table></figure>
<p>可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure>
<h3 id="Channel_+_Selector"><a href="#Channel_+_Selector" class="headerlink" title="Channel + Selector"></a>Channel + Selector</h3><p>Accessing the channel + selector from the SelectionKey is trivial. Here is how it’s done:<br>从SelectionKey中获得channel和selector很简单，像这样就好:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure>
<h3 id="u9644_u52A0_u5BF9_u8C61"><a href="#u9644_u52A0_u5BF9_u8C61" class="headerlink" title="附加对象"></a>附加对象</h3><p>可以将一个对象附加到SelectionKey上。这是个识别给定的channel的简便方法，还可以附加更多信息上去。比如，附加个与channel一起使用的buffer，或者聚合更多数据的对象。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure>
<p>也可以在注册时附加对象，像这样： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure>
<h2 id="u901A_u8FC7Selector_u9009_u62E9Channel"><a href="#u901A_u8FC7Selector_u9009_u62E9Channel" class="headerlink" title="通过Selector选择Channel"></a>通过Selector选择Channel</h2><p>一旦向Selector注册了一个或多个channel，就可以调用任一<code>select()</code>方法。这些方法返回那些注册时感兴趣事件（connect，accept，read 或者 write）的channel。<br>也就是说，如果感兴趣的channel已对读数据做好准备，那么在调用<code>select()</code>方法以后，就会返回对读就绪的channel。</p>
<p>select方法有以下几种:</p>
<ol>
<li><code>int select()</code></li>
<li><code>int select(long timeout)</code></li>
<li><code>int selectNow()</code></li>
</ol>
<p><code>select()</code> 阻塞直到至少一个channel已经对监听事件做好准备。</p>
<p><code>select(long timeout)</code> 和<code>select()</code>一样，除了最长会阻塞timeout毫秒(参数)。</p>
<p><code>selectNow()</code> 不会阻塞，无论channel有没有准备好都会直接返回。（没有准备好的直接返回0）</p>
<p>select()方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。如果调用select()方法，因为有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。</p>
<h3 id="selectedKeys_28_29"><a href="#selectedKeys_28_29" class="headerlink" title="selectedKeys()"></a>selectedKeys()</h3><p>调用select()方法后，一旦其返回值表明一个或多个channel就绪，就可以通过<code>selectedKeys()</code>方法访问『selected key set』（已选择键集）中的就绪channel。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure>
<p>调用<code>Channel.register()</code>向selector注册channel以后返回<code>SelectionKey</code>对象。这个对象就代表了注册到selector的channel。可以通过SelectionKey对象的<code>electedKeySet()</code>方法获得这些对象。</p>
<p>遍历已选择的键集获得就绪的channel： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    </span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个循环遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件。</p>
<p>注意在每次遍历后调用<code>keyIterator.remove()</code>方法。Selector不会从已选择键集中自动删除SelectionKey的实例。在处理完channel后必须调用此方法。下次channel会准备好，Selector将其重新添加到已选择的键集中。 （原文：Notice the keyIterator.remove() call at the end of each iteration. The Selector does not remove the SelectionKey instances from the selected key set itself. You have to do this, when you are done processing the channel. The next time the channel becomes “ready” the Selector will add it to the selected key set again.）</p>
<p>调用<code>SelectionKey.channel()</code>方法会返回需要处理的channel。比如ServerSocketChannel或者SocketChannel等。</p>
<h3 id="wakeUp_28_29_u65B9_u6CD5"><a href="#wakeUp_28_29_u65B9_u6CD5" class="headerlink" title="wakeUp()方法"></a>wakeUp()方法</h3><p>某个线程调用select()方法以后会被阻塞，即使没有就绪的channel，也可以使其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。</p>
<p>如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wake up）”。</p>
<h3 id="close_28_29_u65B9_u6CD5"><a href="#close_28_29_u65B9_u6CD5" class="headerlink" title="close()方法"></a>close()方法</h3><p>用完Selector后调用其close()方法会关闭该Selector，且使注册到该Selector上的所有SelectionKey实例无效。通道本身并不会关闭。</p>
<h2 id="u5B8C_u6574_u7684Selector_u793A_u4F8B"><a href="#u5B8C_u6574_u7684Selector_u793A_u4F8B" class="headerlink" title="完整的Selector示例"></a>完整的Selector示例</h2><p>下面是一个完整的selector例子，open,register,监听等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> readyChannels = selector.select();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">  Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文：<a href="http://tutorials.jenkov.com/java-nio/selectors.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-nio/sele]]>
    </summary>
    
      <category term="Java NIO" scheme="http://suqun.github.io/tags/Java-NIO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java NIO Channel之间的数据传输]]></title>
    <link href="http://suqun.github.io/2016/11/10/Java-NIO-Channel-to-Channel-Transfers/"/>
    <id>http://suqun.github.io/2016/11/10/Java-NIO-Channel-to-Channel-Transfers/</id>
    <published>2016-11-10T03:05:11.000Z</published>
    <updated>2017-04-06T02:53:16.000Z</updated>
    <content type="html"><![CDATA[<p>原文：<a href="http://tutorials.jenkov.com/java-nio/channel-to-channel-transfers.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-nio/channel-to-channel-transfers.html</a></p>
<p>在Java NIO 中channel之间可以直接相互传输。比如一个FileChannel类型的channel，FileChannel类提供<code>transferTo()</code>和<code>transferFrom()</code>两个方法做这个事情。</p>
<h2 id="transferFrom_28_29"><a href="#transferFrom_28_29" class="headerlink" title="transferFrom()"></a>transferFrom()</h2><p><code>FileChannel.transferFrom()</code>方法将一个channel的数据传入FileChannel。</p>
<p>代码🌰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count    = fromChannel.size();</span><br><span class="line"></span><br><span class="line">toChannel.transferFrom(fromChannel, position, count);</span><br></pre></td></tr></table></figure>
<p>position参数确定目标文件的传输初始位置，count参数确定传输的最大数量。channel中的字节数若是少于count，就读取全部字节。<br>另外，SocketChannel传输的是其内部此时此处的就绪的数据（SocketChannel后续可能还会有更多的可用数据）。因此，从SocketChannel传输数据时，有可能不能把全部的请求数据（不足count的数据）都传入FileChannel中。</p>
<h2 id="transferTo_28_29"><a href="#transferTo_28_29" class="headerlink" title="transferTo()"></a>transferTo()</h2><p><code>transferTo()</code>方法将FileChannel数据传入其他的channel中。</p>
<p>代码🌰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count    = fromChannel.size();</span><br><span class="line"></span><br><span class="line">fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure>
<p>和上面的例子很相似。区别在于调用方法的FileChannel对象不一样。</p>
<p>关于SocketChannel的问题在transferTo()方法中同样存在。SocketChannel会一直传输数据直到目标buffer被填满。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文：<a href="http://tutorials.jenkov.com/java-nio/channel-to-channel-transfers.html" target="_blank" rel="external">http://tutorials.jenko]]>
    </summary>
    
      <category term="Java NIO" scheme="http://suqun.github.io/tags/Java-NIO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java NIO Scatter / Gather]]></title>
    <link href="http://suqun.github.io/2016/11/09/Java-NIO-Scatter-Gather/"/>
    <id>http://suqun.github.io/2016/11/09/Java-NIO-Scatter-Gather/</id>
    <published>2016-11-09T15:09:19.000Z</published>
    <updated>2017-04-06T02:53:16.000Z</updated>
    <content type="html"><![CDATA[<p>原文：<a href="http://tutorials.jenkov.com/java-nio/scatter-gather.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-nio/scatter-gather.html</a></p>
<p>Java NIO 从一开始就内嵌了scatter/gather的支持。scatter/gather是从channel中读取写入的操作概念。</p>
<p><strong>scatter</strong>：从channel中将数据读到多个buffers中的操作。也就是说，channel的分散器将channel中的数据分散到多个buffers。</p>
<p><strong>gather</strong>：将多个buffers中的数据写入一个channel中的操作。也就是说，channel的收集器，将多个buffers中的数据收集到channel中。</p>
<p>scatter/gatter经常用于需要将传输的数据分开处理的场合。比如，一个信息包含head和body，你可能会将消息体和消息头分散到不同的buffer中，这样你可以方便的处理消息头和消息体。</p>
<h2 id="Scattering_Reads"><a href="#Scattering_Reads" class="headerlink" title="Scattering Reads"></a>Scattering Reads</h2><p>Scattering Reads，将单个channel中的数据读到多个buffers中，下面是原理图示： </p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/java-nio-scatter-read.png" alt="java-nio-scatter-read"></p>
<p>代码🌰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line">channel.read(bufferArray);</span><br></pre></td></tr></table></figure>
<p>注意buffer首先被插入到数组，然后再将数组作为channel.read() 的输入参数。read()方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer，当一个buffer被写满后，channel紧接着向另一个buffer中写。</p>
<p>Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这也意味着它不适用于动态大小消息。换句话说，如果存在消息头和消息体，消息头必须完成填充（例如填满128byte），Scattering Reads才能正常工作。</p>
<h2 id="Gathering_Writes"><a href="#Gathering_Writes" class="headerlink" title="Gathering Writes"></a>Gathering Writes</h2><p>Gathering Writes：将多个buffers中的数据写入单个channel，下面是原理图示：</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/java-nio-gather.png" alt="Gathering Write"></p>
<p>代码🌰：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//write data into buffers</span></span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line"></span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure></p>
<p>The array of buffers are passed into the write() method, which writes the buffers数组是write()方法的入参，write()方法会按照buffer在数组中的顺序，将数据写入到channel，注意只有position和limit之间的数据才会被写入。因此，如果一个buffer的容量为128byte，但是仅仅包含58byte的数据，那么这58byte的数据将被写入到channel中。因此与Scattering Reads相反，Gathering Writes能较好的处理动态消息。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文：<a href="http://tutorials.jenkov.com/java-nio/scatter-gather.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-nio]]>
    </summary>
    
      <category term="Java NIO" scheme="http://suqun.github.io/tags/Java-NIO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IntelliJ 使用说明]]></title>
    <link href="http://suqun.github.io/2016/10/18/IntelliJ/"/>
    <id>http://suqun.github.io/2016/10/18/IntelliJ/</id>
    <published>2016-10-18T09:38:43.000Z</published>
    <updated>2017-04-06T02:53:16.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h3><p>Windows下载地址：<a href="https://www.jetbrains.com/idea/download/#section=windows" target="_blank" rel="external">https://www.jetbrains.com/idea/download/#section=windows</a></p>
<p>版本选择Ultimate</p>
<p>下载的文件直接双击一路next安装即可。安装结束以后运行起来后，通过Server方式破解</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/%E7%A0%B4%E8%A7%A3.png" alt="破解"></p>
<p><a href="http://idea.iteblog.com/key.php" target="_blank" rel="external">http://idea.iteblog.com/key.php</a></p>
<h3 id="u9879_u76EE_u5F15_u5165"><a href="#u9879_u76EE_u5F15_u5165" class="headerlink" title="项目引入"></a>项目引入</h3><p>破解以后，一路默认启动起来。先创建个Project，Intellij里面的project相当于workplace，可以先建一个空的project的，将项目代码检出到project里面（也可以将原有的项目copy到project文件夹下，如果不想copy，直接import也可以），然后在里面import module</p>
<p>检出代码后的效果：<br><img src="http://7xpk5e.com1.z0.glb.clouddn.com/checkout.png" alt="intellij-checkout"></p>
<p>import后的效果：<br><img src="http://7xpk5e.com1.z0.glb.clouddn.com/import1.png" alt="import1"><br><img src="http://7xpk5e.com1.z0.glb.clouddn.com/import2.png" alt="import2"><br><img src="http://7xpk5e.com1.z0.glb.clouddn.com/import3.png" alt="import3"><br><img src="http://7xpk5e.com1.z0.glb.clouddn.com/import4.png" alt="import4"></p>
<h3 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h3><p>intellij的所有配置信息都在 File-&gt;Settings里面，请自行摸索。</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/settings.png" alt="intellij-settings"></p>
<p>这里说说常用的几个配置在哪里。</p>
<p>1、项目结构</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/structure1.png" alt="structure1"></p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/structure2.png" alt="structure2"><br>这里面可以配置module的语言版本，添加jdk，jar引入等</p>
<p>2、maven</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/maven1.png" alt="maven1"></p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/maven2.png" alt="maven2"></p>
<p>3、Server</p>
<p>以tomcat为例</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/Server1.png" alt="tomcat1"></p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/Server2.png" alt="tomcat2"></p>
<p>配置好Server的基本信息，完成这一步保存，然后添加具体的Server</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/Server3.png" alt="tomcat3"></p>
<p>添加本地Server，Server标签页更改端口等配置信息</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/Server4.png" alt="tomcat4"></p>
<p>Deployment里面部署war包，点击加号，选择</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/Server5.png" alt="tomcat5"></p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/Server6.png" alt="tomcat6"></p>
<h3 id="u5916_u89C2_u5B57_u4F53_u6837_u5F0F_u4FEE_u6539"><a href="#u5916_u89C2_u5B57_u4F53_u6837_u5F0F_u4FEE_u6539" class="headerlink" title="外观字体样式修改"></a>外观字体样式修改</h3><p>通过File-&gt;Import Setting可以直接导入Intellij的配置信息。我这里有个jar包，直接导入即可</p>
<p>jar地址：<a href="https://pan.baidu.com/s/1kU6DxZL" target="_blank" rel="external">https://pan.baidu.com/s/1kU6DxZL</a></p>
<p>导入重启即可，调整了字体大小，文件注释模板，默认UTF-8，使用了sublime类似的主题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h3><p>Windows下载地址：<a href="https://www.jetbrains.com/idea/]]>
    </summary>
    
      <category term="IntelliJ" scheme="http://suqun.github.io/tags/IntelliJ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git 常用命令]]></title>
    <link href="http://suqun.github.io/2016/10/18/gitcommands/"/>
    <id>http://suqun.github.io/2016/10/18/gitcommands/</id>
    <published>2016-10-18T08:38:01.000Z</published>
    <updated>2017-04-06T02:53:16.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u57FA_u672C_u547D_u4EE4"><a href="#u57FA_u672C_u547D_u4EE4" class="headerlink" title="基本命令"></a>基本命令</h3><p>代码检出：git clone 地址</p>
<p>文件修改添加到暂存区：git add readme.txt </p>
<p>文件提交：git commit -m “备注” </p>
<p>查看工作区当前状态：git status</p>
<p>查看差异：git diff 文件名</p>
<p>查看历史：git log –pretty=oneline</p>
<p>查看历史提交commit id：git log –pretty=oneline –abbrev-commit</p>
<p>恢复当前版本：git reset –hard HEAD</p>
<p>恢复上一个版本：git reset –hard HEAD^<br>（上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100）</p>
<p>恢复指定版本：git reset –hard 3628164</p>
<p>查看命令历史：git reflog</p>
<p>查看工作区和版本库区别：git diff HEAD – readme.txt</p>
<p>撤销修改：git checkout – readme.txt</p>
<p>撤销缓存区文件：git reset HEAD readme.txt</p>
<p>删除文件：git rm test.txt</p>
<h3 id="u5206_u652F_u547D_u4EE4"><a href="#u5206_u652F_u547D_u4EE4" class="headerlink" title="分支命令"></a>分支命令</h3><p>查看分支：git branch</p>
<p>创建分支：git branch <name></name></p>
<p>切换分支：git checkout <name></name></p>
<p>创建+切换分支：git checkout -b <name></name></p>
<p>推送远程分支：git push origin <name></name></p>
<p>创建远程分支：git checkout -b dev origin/dev</p>
<p>git checkout -b paytest_20151202_online origin/paytest_20151202_online</p>
<p>合并某分支到当前分支：git merge <name></name></p>
<p>合并分支禁用Fast forward：git merge –no-ff -m “备注” dev</p>
<p>删除分支：git branch -d <name></name></p>
<p>删除远程分支：git push origin –delete <branchname></branchname></p>
<p>强制删除分支：git branch -D <name></name></p>
<p>查看分支历史：git log –graph –pretty=oneline –abbrev-commit</p>
<p>分支合并图：git log –graph</p>
<p>储藏工作区：git stash</p>
<p>查看储藏的工作区：git stash list</p>
<p>恢复并删除储藏工作区：git stash pop</p>
<p>恢复指定工作区：git stash apply stash@{0}</p>
<p>恢复储藏工作区：git stash apply</p>
<p>删除储藏工作区：git stash drop</p>
<p>查询远程库详细信息：git remote -v</p>
<p>推送分支：git push origin dev</p>
<p>抓取最新文件：git pull 分支名</p>
<p>取远程分支：git pull origin 分支名</p>
<p>指定分支与远程分支链接：git branch –set-upstream dev origin/dev</p>
<h3 id="u6807_u7B7E_u547D_u4EE4"><a href="#u6807_u7B7E_u547D_u4EE4" class="headerlink" title="标签命令"></a>标签命令</h3><p>创建标签：git tag v1.0</p>
<p>删除本地标签：git tag -d v0.1</p>
<p>删除远程标签：git push origin :refs/tags0.9</p>
<p>删除远程标签：git push origin –delete tag <tagname></tagname></p>
<p>查看标签：git tag</p>
<p>指定commit id创建标签：git tag v0.9 6224937</p>
<p>指定标签信息：git tag -a <tagname> -m “blablabla…”</tagname></p>
<p>可以用PGP签名标签：git tag -s <tagname> -m “blablabla…”</tagname></p>
<p>查看标签信息：git show 标签名</p>
<p>推送标签到远程：git push origin v1.0</p>
<p>推送所有标签到远程：git push origin –tags</p>
<h3 id="u5176_u4ED6"><a href="#u5176_u4ED6" class="headerlink" title="其他"></a>其他</h3><p>配置别名：git config –global alias.st status</p>
<p>在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<p>撤銷git add . =&gt; git rm -r –cached .</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u57FA_u672C_u547D_u4EE4"><a href="#u57FA_u672C_u547D_u4EE4" class="headerlink" title="基本命令"></a>基本命令</h3><p>代码检出：git clone 地址</p>
<p]]>
    </summary>
    
      <category term="git" scheme="http://suqun.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java应用结合Jenkins，docker部署到Kubernetes]]></title>
    <link href="http://suqun.github.io/2016/10/17/docker-jenkins/"/>
    <id>http://suqun.github.io/2016/10/17/docker-jenkins/</id>
    <published>2016-10-17T08:44:51.000Z</published>
    <updated>2017-04-06T02:54:54.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Jenkins_u5B89_u88C5"><a href="#Jenkins_u5B89_u88C5" class="headerlink" title="Jenkins安装"></a>Jenkins安装</h3><p>1、下载Jenkins war包安装，下载地址 <a href="/jenkins.io">jenkins.io</a>。这里使用的是Jenkins2.24版本</p>
<p>2、启动Jenkins</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JENKINS_HOME=~/.jenkins java -jar ~/Downloads/jenkins-<span class="number">2.24</span>.war --httpPort=<span class="number">9090</span></span><br></pre></td></tr></table></figure>
<p>启动后，日志会提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*************************************************************&#10;*************************************************************&#10;*************************************************************&#10; &#10;Jenkins initial setup is required. An admin user has been created and a password generated.&#10;Please use the following password to proceed to installation:&#10; &#10;3521fbc3d40448efa8942f8e464b2dd9&#10; &#10;This may also be found at: /Users/arungupta/.jenkins/secrets/initialAdminPassword&#10; &#10;*************************************************************&#10;*************************************************************&#10;*************************************************************</span><br></pre></td></tr></table></figure></p>
<p>访问localhost:9090，输入上面提示的密码，然后根据提示，安装推荐的插件，并创建用户</p>
<a id="more"></a>
<h3 id="Jenkins_u63D2_u4EF6_u5B89_u88C5"><a href="#Jenkins_u63D2_u4EF6_u5B89_u88C5" class="headerlink" title="Jenkins插件安装"></a>Jenkins插件安装</h3><p>1、maven配置<br>在 系统管理-&gt;Global Tool Configuration-&gt;Maven 中配置Maven信息<br><img src="http://7xpk5e.com1.z0.glb.clouddn.com/jenkis-maven3.png" alt="maven3"></p>
<p>2、其他插件安装<br>在 系统管理-&gt;管理插件-&gt;可选插件中搜索 docker pipe ，选择CloudBees Docker Pipeline进行安装，安装后重启Jenkins</p>
<h3 id="u521B_u5EFAJenkins_u4EFB_u52A1"><a href="#u521B_u5EFAJenkins_u4EFB_u52A1" class="headerlink" title="创建Jenkins任务"></a>创建Jenkins任务</h3><p>新建任务docker-pipeline</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/docker-pipeline.png" alt="docker-pipeline"></p>
<p>选择Pipeline后，点击Ok后对任务进行配置。配置页中，可以根据自己需要进行设置。都比较简单一看就知道。我这里测试的是代码SCM使用的SVN，再Pipeline项选择Pipeline script from scm进行如下设置</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/pipeline-from-scm.png" alt="pipeline-from-scm"></p>
<p>其中script path中设置的Jenkinsfile为具体的构建步骤，在项目地址的目录中。</p>
<p>当然也可以直接选择 Pipeline script，直接在脚本中设置构建步骤</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/pipeline-script.png" alt="pipeline-script"></p>
<p>脚本中主要的就是构建步骤，从scm检出项目，mvn测试打包，生成docker镜像，将docker镜像上传到镜像仓库，然后登录K8s的master上，部署新的镜像包。</p>
<p>来看看Jenkinsfile，里面是如何描述上面的步骤的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node &#123;&#10;    checkout scm&#10;    env.PATH = &#34;$&#123;tool &#39;Maven3&#39;&#125;/bin:$&#123;env.PATH&#125;&#34;&#10;    stage(&#39;Package&#39;) &#123;&#10;        dir(&#39;RpcServerSample&#39;) &#123;&#10;            sh &#39;mvn clean package -DskipTests&#39;&#10;        &#125;&#10;    &#125;&#10;&#10;    stage(&#39;Run Tests&#39;) &#123;&#10;        dir(&#39;RpcServerSample&#39;) &#123;&#10;                sh &#34;mvn test&#34;&#10;        &#125;&#10;    &#125;&#10;&#10;    stage(&#39;Build Image&#39;) &#123;&#10;        dir(&#39;RpcServerSample&#39;) &#123;&#10;            docker.build(&#34;daocloud.io/suqun/docker-jenkins-pipeline:v1&#34;).push()&#10;        &#125;&#10;    &#125;&#10;&#10;    stage(&#39;Deploy&#39;) &#123;&#10;        //&#26367;&#25442;rpcserver.yaml&#30340;&#38236;&#20687;&#29256;&#26412;&#21495;&#65292;&#24453;&#23436;&#25104;&#10;&#10;        dir(&#39;RpcServerSample&#39;) &#123;&#10;            //scp rpcserver.yaml &#21040; k8s&#30340;master&#19978;&#10;            sh &#39;sshpass -p vagrant scp rpcserver.yaml vagrant@192.168.1.10:/home/vagrant/rpcserver.yaml&#39;&#10;&#10;            //&#36828;&#31243;&#30331;&#24405;k8s&#38598;&#32676;master&#20027;&#26426;,&#26356;&#26032;&#38236;&#20687;&#65292;&#36825;&#37324;&#38754;&#35201;&#36827;&#34892;&#21028;&#26029;&#65292;&#31532;&#19968;&#27425;create&#10;            sh &#39;sshpass -p vagrant ssh vagrant@192.168.1.10 &#34;kubectl create -f /home/vagrant/rpcserver.yaml&#34;&#39;&#10;        &#125;&#10;    &#125;&#10;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>docker.build语句通过RpcServerSample路径下的Dockerfile创建镜像</p>
<p>Dockerfile<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM daocloud.io/java:<span class="number">7</span></span><br><span class="line">MAINTAINER <span class="string">"Larry Su &lt;larrys@wicresoft.com&gt;"</span></span><br><span class="line">ADD target/RpcServerSample-<span class="number">1.0</span>-SNAPSHOT-jar-with-dependencies.jar /usr/src/myapp/RpcServerSample.jar</span><br><span class="line">WORKDIR /usr/src/myapp</span><br><span class="line">CMD [<span class="string">"java"</span>,<span class="string">"-jar"</span>, <span class="string">"RpcServerSample.jar"</span>]</span><br></pre></td></tr></table></figure></p>
<p>rpcserver.yaml是K8s中的Deployment和Service</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1&#10;kind: Service&#10;metadata:&#10;  name: rpcserversample&#10;  labels:&#10;    app: rpcserversample&#10;spec:&#10;  # if your cluster supports it, uncomment the following to automatically create&#10;  # an external load-balanced IP for the frontend service.&#10;  #type: NodePort&#10;  ports:&#10;    # the port that this service should serve on&#10;  - port: 9001&#10;  selector:&#10;    app: rpcserversample&#10;---&#10;apiVersion: extensions/v1beta1&#10;kind: Deployment&#10;metadata:&#10;  name: rpcserversample&#10;  # these labels can be applied automatically&#10;  # from the labels in the pod template if not set&#10;  labels:&#10;    app: rpcserversample&#10;spec:&#10;  # this replicas value is default&#10;  # modify it according to your case&#10;  replicas: 2&#10;  # selector can be applied automatically&#10;  # from the labels in the pod template if not set&#10;  # selector:&#10;  #   matchLabels:&#10;  #     app: guestbook&#10;  #     tier: frontend&#10;  template:&#10;    metadata:&#10;      labels:&#10;        app: rpcserversample&#10;    spec:&#10;      containers:&#10;      - name: rpcserversample&#10;        image: daocloud.io/suqun/rpcserversample:v1&#10;        resources:&#10;          requests:&#10;            cpu: 100m&#10;            memory: 100Mi&#10;        ports:&#10;        - containerPort: 80</span><br></pre></td></tr></table></figure>
<p>这里有些Jenkins pipeline最佳实践，可以参考:<a href="http://www.weixinla.com/document/41174312.html" target="_blank" rel="external">Jenkins管道最佳实践Top 10</a></p>
<p>脚本写的比较烂，只是大概的流程，待完善。</p>
<h3 id="u6784_u5EFA"><a href="#u6784_u5EFA" class="headerlink" title="构建"></a>构建</h3><p>进入任务，点击立即构建后结果如下</p>
<p><img src="http://7xpk5e.com1.z0.glb.clouddn.com/Jenkins-build.png" alt="result"></p>
<p>然后可以登录K8s集群的master主机，通过<code>kubectl get po,svc</code> 检查是否部署成功。</p>
<p>参考：<a href="https://dzone.com/articles/deployment-pipeline-using-docker-jenkins-java-and" target="_blank" rel="external">Deployment Pipeline Using Docker, Jenkins, Java, and Couchbase</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Jenkins_u5B89_u88C5"><a href="#Jenkins_u5B89_u88C5" class="headerlink" title="Jenkins安装"></a>Jenkins安装</h3><p>1、下载Jenkins war包安装，下载地址 <a href="/jenkins.io">jenkins.io</a>。这里使用的是Jenkins2.24版本</p>
<p>2、启动Jenkins</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JENKINS_HOME=~/.jenkins java -jar ~/Downloads/jenkins-<span class="number">2.24</span>.war --httpPort=<span class="number">9090</span></span><br></pre></td></tr></table></figure>
<p>启动后，日志会提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*************************************************************&#10;*************************************************************&#10;*************************************************************&#10; &#10;Jenkins initial setup is required. An admin user has been created and a password generated.&#10;Please use the following password to proceed to installation:&#10; &#10;3521fbc3d40448efa8942f8e464b2dd9&#10; &#10;This may also be found at: /Users/arungupta/.jenkins/secrets/initialAdminPassword&#10; &#10;*************************************************************&#10;*************************************************************&#10;*************************************************************</span><br></pre></td></tr></table></figure></p>
<p>访问localhost:9090，输入上面提示的密码，然后根据提示，安装推荐的插件，并创建用户</p>]]>
    
    </summary>
    
      <category term="Docker" scheme="http://suqun.github.io/tags/Docker/"/>
    
      <category term="Jenkins" scheme="http://suqun.github.io/tags/Jenkins/"/>
    
      <category term="K8s" scheme="http://suqun.github.io/tags/K8s/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用kubeadm在CentOS7上安装Kubernetes集群]]></title>
    <link href="http://suqun.github.io/2016/09/27/dockerjavamicroservice4/"/>
    <id>http://suqun.github.io/2016/09/27/dockerjavamicroservice4/</id>
    <published>2016-09-27T02:52:03.000Z</published>
    <updated>2017-04-06T02:53:16.000Z</updated>
    <content type="html"><![CDATA[<p>Kubernetes1.4版本提供kubeadm命令进行简化k8s集群的安装，只要使用2个简单命令就可以完成安装。 安装kubernetes以后，使用<code>kubeadm init</code>启动master，使用<code>kubeadm joins</code>把node添加到集群里。下面是根据官方博客<a href="http://kubernetes.io/docs/getting-started-guides/kubeadm/" target="_blank" rel="external">Installing Kubernetes on Linux with kubeadm</a>练习的记录。</p>
<h4 id="u4F7F_u7528vagrant_u521B_u5EFA_u4E24_u4E2Acentos7"><a href="#u4F7F_u7528vagrant_u521B_u5EFA_u4E24_u4E2Acentos7" class="headerlink" title="使用vagrant创建两个centos7"></a>使用vagrant创建两个centos7</h4><p>在k8s-centos7-cluster文件夹下创建Vagrantfile文件。Vagrantfile配置如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- mode: ruby -*-</span></span><br><span class="line"><span class="comment"># vi: set ft=ruby :</span></span><br><span class="line"></span><br><span class="line">boxes = [</span><br><span class="line">  &#123; <span class="symbol">:name</span> =&gt; <span class="symbol">:master</span>,<span class="symbol">:ip</span> =&gt; <span class="string">'192.168.1.20'</span>,<span class="symbol">:forward</span> =&gt; <span class="number">80</span>,<span class="symbol">:cpus</span> =&gt; <span class="number">1</span>,<span class="symbol">:mem</span> =&gt; <span class="number">1024</span>&#125;,</span><br><span class="line">  &#123; <span class="symbol">:name</span> =&gt; <span class="symbol">:node1</span>,<span class="symbol">:ip</span> =&gt; <span class="string">'192.168.1.21'</span>,<span class="symbol">:forward</span> =&gt; <span class="number">80</span>,<span class="symbol">:cpus</span> =&gt; <span class="number">1</span>,<span class="symbol">:mem</span> =&gt; <span class="number">1024</span>&#125;,</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="constant">VAGRANTFILE_API_VERSION</span> = <span class="string">"2"</span></span><br><span class="line"></span><br><span class="line"><span class="constant">Vagrant</span>.configure(<span class="constant">VAGRANTFILE_API_VERSION</span>) <span class="keyword">do</span> |config|</span><br><span class="line">    boxes.each <span class="keyword">do</span> |opts|</span><br><span class="line">        config.vm.define opts[<span class="symbol">:name</span>] <span class="keyword">do</span> |config|</span><br><span class="line">            config.vm.box       = <span class="string">"centos7"</span></span><br><span class="line">            config.vm.boot_timeout = <span class="number">360</span></span><br><span class="line">            config.ssh.username = <span class="string">"vagrant"</span></span><br><span class="line">            config.ssh.password = <span class="string">"vagrant"</span></span><br><span class="line">            config.vm.synced_folder <span class="string">"."</span>, <span class="string">"/vagrant"</span>, <span class="symbol">disabled:</span><span class="keyword">true</span></span><br><span class="line">            config.vm.network  <span class="string">"public_network"</span>, <span class="symbol">ip:</span> opts[<span class="symbol">:ip</span>]</span><br><span class="line">            <span class="comment">#config.vm.network "forwarded_port", guest: 80, host: 8080</span></span><br><span class="line">            config.vm.hostname = <span class="string">"%s.vagrant"</span> % opts[<span class="symbol">:name</span>].to_s</span><br><span class="line">            config.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> |vb|</span><br><span class="line">                vb.customize [<span class="string">"modifyvm"</span>, <span class="symbol">:id</span>, <span class="string">"--cpus"</span>, opts[<span class="symbol">:cpus</span>] ] <span class="keyword">if</span> opts[<span class="symbol">:cpus</span>]</span><br><span class="line">                vb.customize [<span class="string">"modifyvm"</span>, <span class="symbol">:id</span>, <span class="string">"--memory"</span>, opts[<span class="symbol">:mem</span>] ] <span class="keyword">if</span> opts[<span class="symbol">:mem</span>]</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">#config.vm.provision "shell", inline: $update_script</span></span><br><span class="line">            <span class="comment">#config.vm.provision "shell", path: opts[:provision] if opts[:provision]</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>在Vagrantfile文件目录下，创建两个CentOS7系统，一个作为master，一个作为node<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  k8s-centos7-cluster vagrant up</span><br><span class="line">Bringing machine <span class="string">'master'</span> up with <span class="string">'virtualbox'</span> provider...</span><br><span class="line">Bringing machine <span class="string">'node1'</span> up with <span class="string">'virtualbox'</span> provider...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>Ok，下面我们开始在CentOS7中安装k8s集群</p>
<h4 id="u5B89_u88C5kubelet_u548Ckuebadm"><a href="#u5B89_u88C5kubelet_u548Ckuebadm" class="headerlink" title="安装kubelet和kuebadm"></a>安装kubelet和kuebadm</h4><p>在所有的机子上都必须安装docker，kubelet，kubectl，kubeadm，无论是master还是node。并且使用root权限进行安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  k8s-centos7-cluster vagrant ssh master <span class="comment">#输入密码登录master</span></span><br><span class="line">[vagrant@master ~]$ </span><br><span class="line">[vagrant@master ~]$ sudo su -</span><br></pre></td></tr></table></figure>
<p>登录master，切换到root用户，然后执行下面的命令:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cat &#60;&#60;EOF &#62; /etc/yum.repos.d/k8s.repo&#10;[kubelet]&#10;name=kubelet&#10;baseurl=http://files.rm-rf.ca/rpms/kubelet/&#10;enabled=1&#10;gpgcheck=0&#10;EOF&#10;# yum install docker kubelet kubeadm kubectl kubernetes-cni&#10;# systemctl enable docker &#38;&#38; systemctl start docker&#10;# systemctl enable kubelet &#38;&#38; systemctl start kubelet</span><br></pre></td></tr></table></figure>
<p>等待下载后安装。<br>安装完成后，可以使用<code>systemctl status</code> 查看安装好的组件服务状态。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># systemctl status docker</span></span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Tue <span class="number">2016</span>-<span class="number">09</span>-<span class="number">27</span> <span class="number">04</span>:<span class="number">57</span>:<span class="number">44</span> UTC; <span class="number">41</span>s ago</span><br></pre></td></tr></table></figure>
<h4 id="u521D_u59CB_u5316master"><a href="#u521D_u59CB_u5316master" class="headerlink" title="初始化master"></a>初始化master</h4><p>在master上运行控制组件，包含etcd（集群的数据库），API server（kubectl 客户端沟通用）。这些组件都在pod中通过kubelet启动运行。<br>初始化master，选择上面实现安装过kubelet和kubeadm的主机，然后运行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># kubeadm init --use-kubernetes-version v1.4.0-beta.11</span></span><br></pre></td></tr></table></figure>
<p>运行后，会下载安装集群用的数据库和控制组件，需要等待一些时间，输出内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;master/tokens&gt; generated token: <span class="string">"88958f.2068ff49c1675f8c"</span></span><br><span class="line">&lt;master/pki&gt; created keys and certificates <span class="keyword">in</span> <span class="string">"/etc/kubernetes/pki"</span></span><br><span class="line">&lt;util/kubeconfig&gt; created <span class="string">"/etc/kubernetes/kubelet.conf"</span></span><br><span class="line">&lt;util/kubeconfig&gt; created <span class="string">"/etc/kubernetes/admin.conf"</span></span><br><span class="line">&lt;master/apiclient&gt; created API client configuration</span><br><span class="line">&lt;master/apiclient&gt; created API client, waiting <span class="keyword">for</span> the control plane to become ready</span><br></pre></td></tr></table></figure>
<p>未完待续。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Kubernetes1.4版本提供kubeadm命令进行简化k8s集群的安装，只要使用2个简单命令就可以完成安装。 安装kubernetes以后，使用<code>kubeadm init</code>启动master，使用<code>kubeadm joins</code>]]>
    </summary>
    
      <category term="Docker" scheme="http://suqun.github.io/tags/Docker/"/>
    
      <category term="K8s" scheme="http://suqun.github.io/tags/K8s/"/>
    
  </entry>
  
</feed>
